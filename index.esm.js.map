{"version":3,"file":"index.esm.js","sources":["leopard-master/src/Trigger.ts","leopard-master/src/renderer/Matrix.ts","leopard-master/src/renderer/Rectangle.ts","leopard-master/src/renderer/effectInfo.ts","leopard-master/src/renderer/effectTransformPoint.ts","leopard-master/src/Color.ts","leopard-master/src/lib/decode-adpcm-audio.ts","leopard-master/src/Sound.ts","leopard-master/src/Sprite.ts","leopard-master/src/renderer/Drawable.ts","leopard-master/src/renderer/Skin.ts","leopard-master/src/renderer/BitmapSkin.ts","leopard-master/src/renderer/Shaders.ts","leopard-master/src/renderer/ShaderManager.ts","leopard-master/src/renderer/PenSkin.ts","leopard-master/src/renderer/SpeechBubbleSkin.ts","leopard-master/src/renderer/VectorSkin.ts","leopard-master/src/Costume.ts","leopard-master/src/Renderer.ts","leopard-master/src/Input.ts","leopard-master/src/Loudness.ts","leopard-master/src/Project.ts","leopard-master/src/Watcher.ts"],"sourcesContent":["const GREEN_FLAG = Symbol(\"GREEN_FLAG\");\nconst KEY_PRESSED = Symbol(\"KEY_PRESSED\");\nconst BROADCAST = Symbol(\"BROADCAST\");\nconst CLICKED = Symbol(\"CLICKED\");\nconst CLONE_START = Symbol(\"CLONE_START\");\nconst LOUDNESS_GREATER_THAN = Symbol(\"LOUDNESS_GREATER_THAN\");\nconst TIMER_GREATER_THAN = Symbol(\"TIMER_GREATER_THAN\");\nconst BACKDROP_CHANGED = Symbol(\"BACKDROP_CHANGED\");\n\nexport default class Trigger {\n  constructor(trigger, options, script) {\n    this.trigger = trigger;\n\n    if (typeof script === \"undefined\") {\n      this.options = {};\n      this._script = options;\n    } else {\n      this.options = options;\n      this._script = script;\n    }\n\n    this.done = false;\n    this.stop = () => {};\n  }\n\n  get isEdgeActivated() {\n    return (\n      this.trigger === TIMER_GREATER_THAN ||\n      this.trigger === LOUDNESS_GREATER_THAN\n    );\n  }\n\n  // Evaluate the given trigger option, whether it's a value or a function that\n  // returns a value given a target\n  option(option, target) {\n    let triggerOption = this.options[option];\n    // If the given option is a function, evaluate that function, passing in\n    // the target that we're evaluating the trigger for\n    if (typeof triggerOption === \"function\") {\n      return triggerOption(target);\n    }\n    return triggerOption;\n  }\n\n  matches(trigger, options, target) {\n    if (this.trigger !== trigger) return false;\n    for (let option in options) {\n      if (this.option(option, target) !== options[option]) return false;\n    }\n\n    return true;\n  }\n\n  start(target) {\n    this.stop();\n\n    const boundScript = this._script.bind(target);\n\n    this.done = false;\n    this._runningScript = boundScript();\n\n    return new Promise(resolve => {\n      this.stop = () => {\n        this.done = true;\n        resolve();\n      };\n    });\n  }\n\n  step() {\n    this.done = this._runningScript.next().done;\n    if (this.done) this.stop();\n  }\n\n  static get GREEN_FLAG() {\n    return GREEN_FLAG;\n  }\n  static get KEY_PRESSED() {\n    return KEY_PRESSED;\n  }\n  static get BROADCAST() {\n    return BROADCAST;\n  }\n  static get CLICKED() {\n    return CLICKED;\n  }\n  static get CLONE_START() {\n    return CLONE_START;\n  }\n  static get LOUDNESS_GREATER_THAN() {\n    return LOUDNESS_GREATER_THAN;\n  }\n  static get TIMER_GREATER_THAN() {\n    return TIMER_GREATER_THAN;\n  }\n  static get BACKDROP_CHANGED() {\n    return BACKDROP_CHANGED;\n  }\n}\n","/* Adapted from gl-matrix\n * https://github.com/toji/gl-matrix\n */\n\n// 3x3 transform matrix operations, unrolled 4 da speedz.\nexport default class Matrix {\n  // Create a new 3x3 transform matrix, initialized to the identity matrix.\n  static create() {\n    const matrix = new Float32Array(9);\n    Matrix.identity(matrix);\n    return matrix;\n  }\n\n  // Reset a matrix to the identity matrix\n  static identity(dst) {\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 1;\n    dst[5] = 0;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 1;\n    return dst;\n  }\n\n  // Translate a matrix by the given X and Y values\n  static translate(dst, src, x, y) {\n    const a00 = src[0],\n      a01 = src[1],\n      a02 = src[2],\n      a10 = src[3],\n      a11 = src[4],\n      a12 = src[5],\n      a20 = src[6],\n      a21 = src[7],\n      a22 = src[8];\n\n    dst[0] = a00;\n    dst[1] = a01;\n    dst[2] = a02;\n\n    dst[3] = a10;\n    dst[4] = a11;\n    dst[5] = a12;\n\n    dst[6] = x * a00 + y * a10 + a20;\n    dst[7] = x * a01 + y * a11 + a21;\n    dst[8] = x * a02 + y * a12 + a22;\n    return dst;\n  }\n\n  // Rotate a matrix, in radians\n  static rotate(dst, src, rad) {\n    const a00 = src[0],\n      a01 = src[1],\n      a02 = src[2],\n      a10 = src[3],\n      a11 = src[4],\n      a12 = src[5],\n      a20 = src[6],\n      a21 = src[7],\n      a22 = src[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n\n    dst[0] = c * a00 + s * a10;\n    dst[1] = c * a01 + s * a11;\n    dst[2] = c * a02 + s * a12;\n\n    dst[3] = c * a10 - s * a00;\n    dst[4] = c * a11 - s * a01;\n    dst[5] = c * a12 - s * a02;\n\n    dst[6] = a20;\n    dst[7] = a21;\n    dst[8] = a22;\n    return dst;\n  }\n\n  // Scale a matrix by the given X and Y values\n  static scale(dst, src, x, y) {\n    dst[0] = x * src[0];\n    dst[1] = x * src[1];\n    dst[2] = x * src[2];\n\n    dst[3] = y * src[3];\n    dst[4] = y * src[4];\n    dst[5] = y * src[5];\n\n    dst[6] = src[6];\n    dst[7] = src[7];\n    dst[8] = src[8];\n    return dst;\n  }\n\n  // Transform a 2D point by the given matrix\n  static transformPoint(m, dst, src) {\n    const x = src[0];\n    const y = src[1];\n    dst[0] = m[0] * x + m[3] * y + m[6];\n    dst[1] = m[1] * x + m[4] * y + m[7];\n    return dst;\n  }\n}\n","export default class Rectangle {\n  constructor() {\n    this.left = -Infinity;\n    this.right = Infinity;\n    this.bottom = -Infinity;\n    this.top = Infinity;\n\n    return this;\n  }\n\n  static fromBounds(left, right, bottom, top, result) {\n    if (!result) result = new Rectangle();\n    result.left = left;\n    result.right = right;\n    result.bottom = bottom;\n    result.top = top;\n\n    return result;\n  }\n\n  // Initialize a bounding box around a sprite given the sprite's transform matrix.\n  static fromMatrix(matrix, result) {\n    if (!result) result = new Rectangle();\n\n    // Adapted somewhat from https://github.com/LLK/scratch-render/blob/develop/docs/Rectangle-AABB-Matrix.md\n    const xa = matrix[0] / 2;\n    const xb = matrix[3] / 2;\n    const absx = Math.abs(xa) + Math.abs(xb);\n    const sumx = xa + xb + matrix[6];\n\n    const ya = matrix[1] / 2;\n    const yb = matrix[4] / 2;\n    const absy = Math.abs(ya) + Math.abs(yb);\n    const sumy = ya + yb + matrix[7];\n\n    result.left = sumx - absx;\n    result.right = sumx + absx;\n    result.bottom = sumy - absy;\n    result.top = sumy + absy;\n\n    return result;\n  }\n\n  // Initialize from another rectangle.\n  static copy(src, dst) {\n    dst.left = src.left;\n    dst.right = src.right;\n    dst.bottom = src.bottom;\n    dst.top = src.top;\n    return dst;\n  }\n\n  // Push this rectangle out to integer bounds.\n  // This takes a conservative approach and will always expand the rectangle outwards.\n  snapToInt() {\n    this.left = Math.floor(this.left);\n    this.right = Math.ceil(this.right);\n    this.bottom = Math.floor(this.bottom);\n    this.top = Math.ceil(this.top);\n\n    return this;\n  }\n\n  // Check whether any part of this rectangle touches another rectangle.\n  intersects(rect) {\n    return (\n      this.left <= rect.right &&\n      rect.left <= this.right &&\n      this.top >= rect.bottom &&\n      rect.top >= this.bottom\n    );\n  }\n\n  // Check whether a given point is inside this rectangle.\n  containsPoint(x, y) {\n    return (\n      x >= this.left && x <= this.right && y >= this.bottom && y <= this.top\n    );\n  }\n\n  // Clamp this rectangle within bounds.\n  clamp(left, right, bottom, top) {\n    this.left = Math.min(Math.max(this.left, left), right);\n    this.right = Math.max(Math.min(this.right, right), left);\n    this.bottom = Math.min(Math.max(this.bottom, bottom), top);\n    this.top = Math.max(Math.min(this.top, top), bottom);\n\n    return this;\n  }\n\n  // Compute the union of two rectangles.\n  static union(rect1, rect2, result = new Rectangle()) {\n    result.left = Math.min(rect1.left, rect2.left);\n    result.right = Math.max(rect1.right, rect2.right);\n    result.bottom = Math.min(rect1.bottom, rect2.bottom);\n    result.top = Math.max(rect1.top, rect2.top);\n\n    return result;\n  }\n\n  // Compute the intersection of two rectangles.\n  static intersection(rect1, rect2, result = new Rectangle()) {\n    result.left = Math.max(rect1.left, rect2.left);\n    result.right = Math.min(rect1.right, rect2.right);\n    result.bottom = Math.max(rect1.bottom, rect2.bottom);\n    result.top = Math.min(rect1.top, rect2.top);\n\n    return result;\n  }\n\n  get width() {\n    return this.right - this.left;\n  }\n\n  get height() {\n    return this.top - this.bottom;\n  }\n}\n","// This file exists to specify a mapping from numeric indices to effect names in all places that require it.\nconst effectNames = [\n  \"color\",\n  \"fisheye\",\n  \"whirl\",\n  \"pixelate\",\n  \"mosaic\",\n  \"brightness\",\n  \"ghost\"\n];\n\nconst effectBitmasks = {};\nfor (let i = 0; i < effectNames.length; i++) {\n  effectBitmasks[effectNames[i]] = 1 << i;\n}\n\nexport { effectNames, effectBitmasks };\n","import { effectBitmasks } from \"./effectInfo.ts\";\n\nconst CENTER = 0.5;\nconst EPSILON = 1e-3;\n\n// Transform a texture-space point using the effects defined on the given drawable.\nconst effectTransformPoint = (drawable, src, dst) => {\n  const { effects } = drawable._sprite;\n  const effectBitmask = effects._bitmask;\n\n  dst[0] = src[0];\n  dst[1] = src[1];\n\n  if ((effectBitmask & effectBitmasks.mosaic) !== 0) {\n    // float mosaicFactor = clamp(floor(abs(u_mosaic + 10.0) / 10.0 + 0.5), 1.0, 512.0);\n    const mosaicFactor = Math.max(\n      1,\n      Math.min(Math.floor(Math.abs(effects.mosaic + 10) / 10 + 0.5), 512)\n    );\n    // coord = fract(coord * mosaicFactor);\n    dst[0] = (mosaicFactor * dst[0]) % 1;\n    dst[1] = (mosaicFactor * dst[1]) % 1;\n  }\n\n  if ((effectBitmask & effectBitmasks.pixelate) !== 0) {\n    // vec2 pixSize = u_skinSize / (abs(u_pixelate) * 0.1);\n    const skin = drawable.getCurrentSkin();\n    const pixSizeX = skin.width / (Math.abs(effects.pixelate) * 0.1);\n    const pixSizeY = skin.height / (Math.abs(effects.pixelate) * 0.1);\n    // coord = (floor(coord * pixSize) + CENTER) / pixSize;\n    dst[0] = (Math.floor(dst[0] * pixSizeX) + CENTER) / pixSizeX;\n    dst[1] = (Math.floor(dst[1] * pixSizeY) + CENTER) / pixSizeY;\n  }\n\n  if ((effectBitmask & effectBitmasks.whirl) !== 0) {\n    // const float PI_OVER_180 = 0.017453292519943295;\n    const PI_OVER_180 = 0.017453292519943295;\n    // vec2 offset = coord - CENTER;\n    const offsetX = dst[0] - CENTER;\n    const offsetY = dst[1] - CENTER;\n    // float whirlFactor = max(1.0 - (length(offset) * 2.0), 0.0);\n    const offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n    const whirlFactor = Math.max(1 - offsetLength * 2, 0);\n    // float whirl = (-u_whirl * PI_OVER_180) * whirlFactor * whirlFactor;\n    const whirl = -effects.whirl * PI_OVER_180 * whirlFactor * whirlFactor;\n    // float s = sin(whirl);\n    // float c = cos(whirl);\n    const s = Math.sin(whirl);\n    const c = Math.cos(whirl);\n    // mat2 rotationMatrix = mat2(c, -s, s, c);\n    // coord = rotationMatrix * offset + CENTER;\n    dst[0] = c * offsetX + s * offsetY + CENTER;\n    dst[1] = -s * offsetX + c * offsetY + CENTER;\n  }\n\n  if ((effectBitmask & effectBitmasks.fisheye) !== 0) {\n    // vec2 vec = (coord - CENTER) / CENTER;\n    const vecX = (dst[0] - CENTER) / CENTER;\n    const vecY = (dst[1] - CENTER) / CENTER;\n    // float len = length(vec) + epsilon;\n    const len = Math.sqrt(vecX * vecX + vecY * vecY) + EPSILON;\n    // float factor = max(0.0, (u_fisheye + 100.0) / 100.0);\n    const factor = Math.max(0, (effects.fisheye + 100) / 100);\n    // float r = pow(min(len, 1.0), factor) * max(1.0, len);\n    const r = Math.pow(Math.min(len, 1), factor) * Math.max(1, len);\n    // vec2 unit = vec / len;\n    const unitX = vecX / len;\n    const unitY = vecY / len;\n    // coord = CENTER + (r * unit * CENTER);\n    dst[0] = CENTER + r * unitX * CENTER;\n    dst[1] = CENTER + r * unitY * CENTER;\n  }\n\n  return dst;\n};\n\nexport default effectTransformPoint;\n","const clamp = (n, min, max) => Math.max(min, Math.min(max, n));\n\n// https://www.rapidtables.com/convert/color/rgb-to-hsv.html\nfunction rgbToHSV(r, g, b) {\n  r /= 255;\n  g /= 255;\n  b /= 255;\n\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const delta = max - min;\n\n  let h = 0;\n  if (delta === 0) {\n    // Grey. Leave at 0.\n  } else if (max === r) {\n    h = (((g - b) / delta + 6) % 6) / 6;\n  } else if (max === g) {\n    h = (((b - r) / delta + 2) % 6) / 6;\n  } else if (max === b) {\n    h = (((r - g) / delta + 4) % 6) / 6;\n  }\n\n  let s = 0;\n  if (max !== 0) {\n    s = delta / max;\n  }\n\n  let v = max;\n\n  return {\n    h: h * 100,\n    s: s * 100,\n    v: v * 100\n  };\n}\n\n// https://www.rapidtables.com/convert/color/hsv-to-rgb.html\nfunction hsvToRGB(h, s, v) {\n  h = (h / 100) * 360;\n  s /= 100;\n  v /= 100;\n\n  const c = v * s;\n  const x = c * (1 - Math.abs(((h / 60) % 2) - 1));\n\n  const min = v - c;\n\n  let r = min;\n  let g = min;\n  let b = min;\n\n  if (h < 60) {\n    r += c;\n    g += x;\n  } else if (h < 120) {\n    g += c;\n    r += x;\n  } else if (h < 180) {\n    g += c;\n    b += x;\n  } else if (h < 240) {\n    b += c;\n    g += x;\n  } else if (h < 300) {\n    b += c;\n    r += x;\n  } else if (h < 360) {\n    r += c;\n    b += x;\n  }\n\n  return {\n    r: r * 255,\n    g: g * 255,\n    b: b * 255\n  };\n}\n\nexport default class Color {\n  constructor(h = 0, s = 0, v = 0, a = 1) {\n    this.h = h;\n    this.s = s;\n    this.v = v;\n    this.a = a;\n  }\n\n  static rgb(r, g, b, a = 1) {\n    const { h, s, v } = rgbToHSV(r, g, b);\n    return new Color(h, s, v, a);\n  }\n\n  static hsv(h, s, v, a = 1) {\n    return new Color(h, s, v, a);\n  }\n\n  static num(n) {\n    n = Number(n);\n\n    // Match Scratch rgba system\n    // https://github.com/LLK/scratch-vm/blob/0dffc65ce99307d048f6b9a10b1c31b01ab0133d/src/util/color.ts#L45\n    const a = (n >> 24) & 0xff;\n    const r = (n >> 16) & 0xff;\n    const g = (n >> 8) & 0xff;\n    const b = n & 0xff;\n    return Color.rgb(r, g, b, a > 0 ? a / 255 : 1);\n  }\n\n  // Red\n  get r() {\n    return hsvToRGB(this.h, this.s, this.v).r;\n  }\n  set r(r) {\n    this._setRGB(r, this.g, this.b);\n  }\n\n  // Green\n  get g() {\n    return hsvToRGB(this.h, this.s, this.v).g;\n  }\n  set g(g) {\n    this._setRGB(this.r, g, this.b);\n  }\n\n  // Blue\n  get b() {\n    return hsvToRGB(this.h, this.s, this.v).b;\n  }\n  set b(b) {\n    this._setRGB(this.r, this.g, b);\n  }\n\n  // Alpha\n  get a() {\n    return this._a;\n  }\n  set a(a) {\n    this._a = clamp(a, 0, 1);\n  }\n\n  // Hue\n  get h() {\n    return this._h;\n  }\n  set h(h) {\n    this._h = ((h % 100) + 100) % 100;\n  }\n\n  // Shade\n  get s() {\n    return this._s;\n  }\n  set s(s) {\n    this._s = clamp(s, 0, 100);\n  }\n\n  // Value\n  get v() {\n    return this._v;\n  }\n  set v(v) {\n    this._v = clamp(v, 0, 100);\n  }\n\n  _setRGB(r, g, b) {\n    r = clamp(r, 0, 255);\n    g = clamp(g, 0, 255);\n    b = clamp(b, 0, 255);\n\n    const { h, s, v } = rgbToHSV(r, g, b);\n\n    this.h = h;\n    this.s = s;\n    this.v = v;\n  }\n\n  toHexString(forceIncludeAlpha = false) {\n    const toHexDigits = n => {\n      n = clamp(Math.round(n), 0, 255);\n\n      let str = n.toString(16);\n      if (str.length === 1) {\n        str = \"0\" + str;\n      }\n\n      return str;\n    };\n\n    let hex = \"#\" + [this.r, this.g, this.b].map(toHexDigits).join(\"\");\n    if (forceIncludeAlpha || this.a !== 1) {\n      hex += toHexDigits(this.a * 255);\n    }\n\n    return hex;\n  }\n\n  toRGBString(forceIncludeAlpha = false) {\n    const rgb = [this.r, this.g, this.b].map(Math.round);\n\n    if (forceIncludeAlpha || this.a !== 1) {\n      return `rgba(${rgb.join(\", \")}, ${this.a})`;\n    }\n    return `rgb(${rgb.join(\", \")})`;\n  }\n\n  toRGBA() {\n    const rgb = hsvToRGB(this._h, this._s, this._v);\n    return [rgb.r, rgb.g, rgb.b, this._a * 255];\n  }\n\n  toRGBANormalized() {\n    const rgb = hsvToRGB(this._h, this._s, this._v);\n    return [rgb.r / 255, rgb.g / 255, rgb.b / 255, this._a];\n  }\n\n  toString() {\n    return this.toRGBString();\n  }\n}\n","/**\n * The MIT License (MIT)\n *\n * Copyright (c) 2013-2019 Truman Kilen, Nathan Dinsmore, and Adroitwhiz\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n// prettier-ignore\nconst ADPCM_STEPS = [\n  7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45, 50, 55, 60, 66, 73, 80, 88, 97, 107,\n  118, 130, 143, 157, 173, 190, 209, 230, 253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963,\n  1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358, 5894,\n  6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794,\n  32767\n];\n\nconst ADPCM_INDEX = [-1, -1, -1, -1, 2, 4, 6, 8, -1, -1, -1, -1, 2, 4, 6, 8];\n\nexport default function decodeADPCMAudio(ab, audioContext) {\n  const dv = new DataView(ab);\n  // WAV magic number\n  if (dv.getUint32(0) !== 0x52494646 || dv.getUint32(8) !== 0x57415645) {\n    return Promise.reject(new Error(\"Unrecognized audio format\"));\n  }\n\n  const blocks = {};\n  const l = dv.byteLength - 8;\n  let i = 12;\n  while (i < l) {\n    blocks[\n      String.fromCharCode(\n        dv.getUint8(i),\n        dv.getUint8(i + 1),\n        dv.getUint8(i + 2),\n        dv.getUint8(i + 3)\n      )\n    ] = i;\n    i += 8 + dv.getUint32(i + 4, true);\n  }\n\n  const format = dv.getUint16(20, true);\n  const sampleRate = dv.getUint32(24, true);\n\n  if (format === 17) {\n    const samplesPerBlock = dv.getUint16(38, true);\n    const blockSize = (samplesPerBlock - 1) / 2 + 4;\n\n    const frameCount = dv.getUint32(blocks.fact + 8, true);\n\n    const buffer = audioContext.createBuffer(1, frameCount, sampleRate);\n    const channel = buffer.getChannelData(0);\n\n    let sample;\n    let index = 0;\n    let step, code, delta;\n    let lastByte = -1;\n\n    const offset = blocks.data + 8;\n    let i = offset;\n    let j = 0;\n    // eslint-disable-next-line\n    while (true) {\n      if ((i - offset) % blockSize === 0 && lastByte < 0) {\n        if (i >= dv.byteLength) break;\n        sample = dv.getInt16(i, true);\n        i += 2;\n        index = dv.getUint8(i);\n        i += 1;\n        i++;\n        if (index > 88) index = 88;\n        channel[j++] = sample / 32767;\n      } else {\n        if (lastByte < 0) {\n          if (i >= dv.byteLength) break;\n          lastByte = dv.getUint8(i);\n          i += 1;\n          code = lastByte & 0xf;\n        } else {\n          code = (lastByte >> 4) & 0xf;\n          lastByte = -1;\n        }\n        step = ADPCM_STEPS[index];\n        delta = 0;\n        if (code & 4) delta += step;\n        if (code & 2) delta += step >> 1;\n        if (code & 1) delta += step >> 2;\n        delta += step >> 3;\n        index += ADPCM_INDEX[code];\n        if (index > 88) index = 88;\n        if (index < 0) index = 0;\n        sample += code & 8 ? -delta : delta;\n        if (sample > 32767) sample = 32767;\n        if (sample < -32768) sample = -32768;\n        channel[j++] = sample / 32768;\n      }\n    }\n    return Promise.resolve(buffer);\n  }\n  return Promise.reject(new Error(`Unrecognized WAV format ${format}`));\n}\n\nexport function isWavData(arrayBuffer) {\n  const dataView = new DataView(arrayBuffer);\n  return (\n    dataView.getUint32(0) === 0x52494646 && dataView.getUint32(8) === 0x57415645\n  );\n}\n\nexport function isADPCMData(arrayBuffer) {\n  const dataView = new DataView(arrayBuffer);\n  const format = dataView.getUint16(20, true);\n  return isWavData(arrayBuffer) && format === 17;\n}\n","import decodeADPCMAudio, { isADPCMData } from \"./lib/decode-adpcm-audio.ts\";\n\nexport default class Sound {\n  constructor(name, url) {\n    this.name = name;\n    this.url = url;\n\n    this.audioBuffer = null;\n    this.source = null;\n    this.playbackRate = 1;\n\n    // TODO: Remove this line; initiate downloads from somewhere else instead.\n    this.downloadMyAudioBuffer();\n  }\n\n  get duration() {\n    return this.audioBuffer.duration;\n  }\n\n  *start() {\n    let started = false;\n    let isLatestCallToStart = true;\n\n    if (this._markDone) {\n      this._markDone();\n    }\n\n    if (this.audioBuffer) {\n      this.playMyAudioBuffer();\n      started = true;\n    } else {\n      // It's possible that start() will be called again before this start()\n      // has successfully started the sound (i.e. because it was waiting for\n      // the audio buffer to download). If that's the case, _doneDownloading\n      // will already exist. We never want to return from start() before the\n      // sound has begun playing, but in the case of playUntilDone(), only the\n      // latest call should wait for the sound to finish playing; also, we only\n      // need to run playMyAudioBuffer once. To meet all these conditions, and\n      // also to avoid implementing some kind of addEventListener-esque system,\n      // we implement a simple \"listener chain\" here. Every time we set call\n      // start(), we keep track of the previous value of doneDownloading, and\n      // replace it with a new function. When this function is called directly\n      // as a result of the download finishing, it will call, if existent, the\n      // previous value of doneDownloading with a flag indicating it is being\n      // called from a more recent call to start(). That function will in turn\n      // do the same for its saved previous value, and so on, until all the\n      // previous values of doneDownloading have been called. Thus, all\n      // previous calls of start() will then finish, returning their value of\n      // isLatestCallToStart: false, indicating that if the call came from\n      // playUntilDone(), that playUntilDone should not wait for the sound to\n      // finish playing. Of course, the latest call returns true, and so the\n      // containing playUntilDone() (if present) knows to wait.\n      const oldDoneDownloading = this._doneDownloading;\n      this._doneDownloading = fromMoreRecentCall => {\n        if (fromMoreRecentCall) {\n          isLatestCallToStart = false;\n        } else {\n          this.playMyAudioBuffer();\n          started = true;\n          delete this._doneDownloading;\n        }\n        if (oldDoneDownloading) {\n          oldDoneDownloading(true);\n        }\n      };\n    }\n\n    while (!started && isLatestCallToStart) yield;\n\n    return isLatestCallToStart;\n  }\n\n  *playUntilDone() {\n    let playing = true;\n\n    const isLatestCallToStart = yield* this.start();\n\n    // If we failed to download the audio buffer, just stop here - the sound will\n    // never play, so it doesn't make sense to wait for it.\n    if (!this.audioBuffer) {\n      return;\n    }\n\n    this.source.addEventListener(\"ended\", () => {\n      playing = false;\n      delete this._markDone;\n    });\n\n    // If there was another call to start() since ours, don't wait for the\n    // sound to finish before returning.\n    if (!isLatestCallToStart) {\n      return;\n    }\n\n    // Set _markDone after calling start(), because start() will call the existing\n    // value of _markDone if it's already set. It does this because playUntilDone()\n    // is meant to be interrupted if another start() is ran while it's playing.\n    // Of course, we don't want *this* playUntilDone() to be treated as though it\n    // were interrupted when we call start(), so setting _markDone comes after.\n    this._markDone = () => {\n      playing = false;\n      delete this._markDone;\n    };\n\n    while (playing) yield;\n  }\n\n  stop() {\n    if (this._markDone) {\n      this._markDone();\n    }\n\n    if (this.source) {\n      this.source.disconnect();\n      this.source = null;\n    }\n  }\n\n  downloadMyAudioBuffer() {\n    return fetch(this.url)\n      .then(body => body.arrayBuffer())\n      .then(arrayBuffer => {\n        if (isADPCMData(arrayBuffer)) {\n          return decodeADPCMAudio(arrayBuffer, Sound.audioContext).catch(\n            error => {\n              console.warn(\n                `Failed to load sound \"${this.name}\" - will not play:\\n` + error\n              );\n              return null;\n            }\n          );\n        } else {\n          return new Promise((resolve, reject) => {\n            Sound.audioContext.decodeAudioData(arrayBuffer, resolve, reject);\n          });\n        }\n      })\n      .then(audioBuffer => {\n        this.audioBuffer = audioBuffer;\n        if (this._doneDownloading) {\n          this._doneDownloading();\n        }\n        return audioBuffer;\n      });\n  }\n\n  playMyAudioBuffer() {\n    if (!this.audioBuffer) {\n      return;\n    }\n\n    if (this.source) {\n      this.source.disconnect();\n    }\n\n    this.source = Sound.audioContext.createBufferSource();\n    this.source.buffer = this.audioBuffer;\n    this.source.playbackRate.value = this.playbackRate;\n\n    if (this.target) {\n      this.source.connect(this.target);\n    }\n\n    this.source.start(Sound.audioContext.currentTime);\n  }\n\n  connect(target) {\n    if (target !== this.target) {\n      this.target = target;\n      if (this.source) {\n        this.source.disconnect();\n        this.source.connect(this.target);\n      }\n    }\n  }\n\n  setPlaybackRate(value) {\n    this.playbackRate = value;\n    if (this.source) {\n      this.source.playbackRate.value = value;\n    }\n  }\n\n  isConnectedTo(target) {\n    return this.target === target;\n  }\n\n  // Note: \"this\" refers to the Sound class in static functions.\n\n  static get audioContext() {\n    this._setupAudioContext();\n    return this._audioContext;\n  }\n\n  static _setupAudioContext() {\n    if (!this._audioContext) {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      this._audioContext = new AudioContext();\n    }\n  }\n\n  static decodeADPCMAudio(audioBuffer) {\n    return decodeADPCMAudio(audioBuffer, this.audioContext);\n  }\n}\n\nexport class EffectChain {\n  // The code in this class is functionally comparable to the class of the same\n  // name in the scratch-audio library, but is completely rewritten and follows\n  // somewhat different logic. Still, the class exists on the same principle:\n  // a portable way to store the effect chain, independent of the audio sources\n  // it affects.\n\n  constructor(config) {\n    const { getNonPatchSoundList } = config;\n    this.config = config;\n\n    this.inputNode = Sound.audioContext.createGain();\n\n    // This is a mapping of an effect's name to an object containing all the\n    // nodes which are of use to that effect: always an {input, output} pair,\n    // as well as any other nodes of use to that effect. The values here are\n    // filled in by an effect descriptor's makeNodes() function, and may\n    // contain duplicate copies of the same node within a particular effect's\n    // object, when that's of use to make the logic clearer (e.g. when there's\n    // no distinction between the input and output node, or referring to the\n    // output node by a more specific name).\n    this.effectNodes = {};\n\n    this.resetToInitial();\n\n    this.getNonPatchSoundList = getNonPatchSoundList;\n  }\n\n  resetToInitial() {\n    // Note: some effects won't be reset by this function, except for when they\n    // are set for the first time (i.e. when the EffectChain is instantiated).\n    // Look for the \"reset: false\" flag in the effect descriptor list.\n\n    const initials = EffectChain.getInitialEffectValues();\n    if (this.effectValues) {\n      for (const [name, initialValue] of Object.entries(\n        EffectChain.getInitialEffectValues()\n      )) {\n        if (EffectChain.getEffectDescriptor(name).reset !== false) {\n          this.setEffectValue(name, initialValue);\n        }\n      }\n    } else {\n      this.effectValues = initials;\n    }\n  }\n\n  updateAudioEffect(name) {\n    const descriptor = EffectChain.getEffectDescriptor(name);\n\n    if (!descriptor) {\n      return;\n    }\n\n    // updateAudioEffect doesn't take a value - it only reflects the existing\n    // value in the actual effects applied to nodes and sounds!\n    const value = this.effectValues[name];\n\n    if (descriptor.isPatch) {\n      // Here, we search for the next and previous effects in the chain\n      // who have existent nodes. This means we'll skip non-patch effects as\n      // well as effects are set to their initial value.\n\n      let next = descriptor;\n      do {\n        next = EffectChain.getNextEffectDescriptor(next.name);\n      } while (next && !this.effectNodes[next.name]);\n\n      let previous = descriptor;\n      do {\n        previous = EffectChain.getPreviousEffectDescriptor(previous.name);\n      } while (previous && !this.effectNodes[previous.name]);\n\n      // If we have previous and next values available, they'll currently be\n      // the corresponding descriptors. But we only ever need to access the\n      // nodes which correspond to those descriptor's names, so we replace them\n      // with the actual objects containing the effect's nodes here to simplify\n      // later code.\n\n      if (next) {\n        next = this.effectNodes[next.name];\n      }\n\n      if (previous) {\n        next = this.effectNodes[previous.name];\n      }\n\n      // If there is no preceding or following effect which has existent nodes,\n      // we'll make the variables reference the target input and target nodes\n      // of the EffectChain - i.e, the two ends of the chain, as far as this\n      // class is concerned. (Note that while the input node will always be\n      // present, because it's defined right on the EffectChain, it's possible\n      // that there won't be any target node, leaving the value for \"next\"\n      // still null.)\n      //\n      // We do need to keep to the structure that effectNodes contains, though.\n      // When we access the previous node (or the EffectChain's input node, in\n      // this case), we'll be making a connection with its output; likewise,\n      // when we're accessing the next node (or the EffectChain's target),\n      // we'll be connecting something to its input. That's reflected in the\n      // values here.\n\n      if (!previous) {\n        previous = { output: this.inputNode };\n      }\n\n      if (!next && this.target) {\n        next = { input: this.target };\n      }\n\n      // \"Patch\" effects are applied by sending audio data through an ordered\n      // series - i.e, a chain - of WebAudio nodes. All effects have an input\n      // node and an output node; for simple effects, these may actually be the\n      // same node. (Take a look at the volume effect, which uses a single Gain\n      // node as both its input and output.) Other effects are more complex.\n      // The code in this block controls the actual chaining behavior of\n      // EffectChain, assuring that all effects form a clean chain.\n      let nodes = this.effectNodes[descriptor.name];\n      if (!nodes && value !== descriptor.initial) {\n        nodes = descriptor.makeNodes();\n        this.effectNodes[descriptor.name] = nodes;\n\n        // Connect the previous effect, or, if there is none, the EffectChain\n        // input, to this effect. Also disconnect it from whatever it was\n        // previously connected to, so we aren't sending data more than one\n        // place at a time - that would mess with the chain.\n        previous.output.disconnect();\n        previous.output.connect(nodes.input);\n\n        // Connect this effect to the next effect, or, if there is none,\n        // the EffectChain target.\n        if (next) {\n          nodes.output.connect(next.input);\n        }\n      }\n\n      if (value === descriptor.initial) {\n        // If we're setting to the initial value, disconnect and discard the\n        // effect's nodes. It's not necessary to keep nodes that don't cause\n        // an effect in the chain. (We don't need to run the set() behavior\n        // specified on the effect descriptor, since we're disconnecting and\n        // discarding the nodes - the only values that function has access to.)\n        if (nodes) {\n          // There's no need to define custom disposal behavior per effect,\n          // since it's always a matter of simply disconnecting every node.\n          // The disconnect() method of a WebAudio node won't error if it's\n          // already had all its connections removed, but we avoid redundant\n          // calls here anyway.\n          for (const node of new Set(Object.values(nodes))) {\n            node.disconnect();\n          }\n\n          // We also need to establish a connection between the adjacent nodes\n          // (which may be the EffectChain's input node and target node, if\n          // there aren't any adjacent effect nodes).\n          if (next) {\n            previous.output.connect(next.input);\n          }\n\n          // Finally, we discard the object which holds the effect's nodes.\n          // We aren't going to be using it anymore, and we need it gone so\n          // that we recreate the nodes and correctly position them back in\n          // the chain, if we use this effect again later.\n          delete this.effectNodes[name];\n        }\n      } else {\n        descriptor.set(value, nodes);\n      }\n    } else {\n      // Non-\"patch\" effects operate directly on Sound objects, accessing\n      // APIs provided by that class. The actual sound list is provided by the\n      // caller of EffectChain.\n      for (const sound of this.getNonPatchSoundList()) {\n        descriptor.set(value, sound);\n      }\n    }\n  }\n\n  connect(target) {\n    this.target = target;\n\n    // All the code here is basically the same as what's written in\n    // updateAudioEffect above; specific to this function, we want to\n    // disconnect the final output in the chain - which may be the input\n    // node - and then connect it to the newly specified target.\n\n    let last = EffectChain.getLastEffectDescriptor();\n    do {\n      last = EffectChain.getPreviousEffectDescriptor(last.name);\n    } while (last && !this.effectNodes[last.name]);\n\n    if (last) {\n      last = this.effectNodes[last.name];\n    } else {\n      last = { output: this.inputNode };\n    }\n\n    last.output.disconnect();\n    last.output.connect(target);\n  }\n\n  setEffectValue(name, value) {\n    value = Number(value);\n    if (\n      name in this.effectValues &&\n      !isNaN(value) &&\n      value !== this.effectValues[name]\n    ) {\n      this.effectValues[name] = value;\n      this.clampEffectValue(name);\n      this.updateAudioEffect(name);\n    }\n  }\n\n  changeEffectValue(name, value) {\n    value = Number(value);\n    if (name in this.effectValues && !isNaN(value) && value !== 0) {\n      this.effectValues[name] += value;\n      this.clampEffectValue(name);\n      this.updateAudioEffect(name);\n    }\n  }\n\n  clampEffectValue(name) {\n    // Not all effects are clamped (pitch, for example); it's also possible to\n    // specify only a minimum or maximum bound, instead of both.\n    const descriptor = EffectChain.getEffectDescriptor(name);\n    let value = this.effectValues[name];\n    if (\"minimum\" in descriptor && value < descriptor.minimum) {\n      value = descriptor.minimum;\n    } else if (\"maximum\" in descriptor && value > descriptor.maximum) {\n      value = descriptor.maximum;\n    }\n    this.effectValues[name] = value;\n  }\n\n  getEffectValue(name) {\n    return this.effectValues[name] || 0;\n  }\n\n  clone(newConfig) {\n    const newEffectChain = new EffectChain(\n      Object.assign({}, this.config, newConfig)\n    );\n\n    for (const [name, value] of Object.entries(this.effectValues)) {\n      const descriptor = EffectChain.getEffectDescriptor(name);\n      if (!descriptor.resetOnClone) {\n        newEffectChain.setEffectValue(name, value);\n      }\n    }\n\n    newEffectChain.connect(this.target);\n\n    return newEffectChain;\n  }\n\n  applyToSound(sound) {\n    sound.connect(this.inputNode);\n\n    for (const [name, value] of Object.entries(this.effectValues)) {\n      const descriptor = EffectChain.getEffectDescriptor(name);\n      if (!descriptor.isPatch) {\n        descriptor.set(value, sound);\n      }\n    }\n  }\n\n  isTargetOf(sound) {\n    return sound.isConnectedTo(this.inputNode);\n  }\n\n  static getInitialEffectValues() {\n    // This would be an excellent place to use Object.fromEntries, but that\n    // function has been implemented in only the latest of a few modern\n    // browsers. :P\n    const initials = {};\n    for (const { name, initial } of this.effectDescriptors) {\n      initials[name] = initial;\n    }\n    return initials;\n  }\n\n  static getEffectDescriptor(name) {\n    return this.effectDescriptors.find(descriptor => descriptor.name === name);\n  }\n\n  static getFirstEffectDescriptor() {\n    return this.effectDescriptors[0];\n  }\n\n  static getLastEffectDescriptor() {\n    return this.effectDescriptors[this.effectDescriptors.length - 1];\n  }\n\n  static getNextEffectDescriptor(name) {\n    // .find() provides three values to its passed function: the value of the\n    // current item, that item's index, and the array on which .find() is\n    // operating. In this case, we're only concerned with the index.\n    // For each item in the list, besides the first, we check if the item\n    // before it matches the name we were given. By initially shifting all the\n    // descriptors using slice(1), the index of any item in the shifted list\n    // corresponds to the previous item in the original list. Thus, if that\n    // previous item matches the provided name, by definition, we'll have found\n    // the item which comes after it.\n    return this.effectDescriptors\n      .slice(1)\n      .find((_, i) => this.effectDescriptors[i].name === name);\n  }\n\n  static getPreviousEffectDescriptor(name) {\n    // This function's a little simpler, since it doesn't involve shifting the\n    // list. We still use slice(), but this time simply to cut off the last\n    // item; that item will never come before any other, after all. We search\n    // the list for the item whose following item matches the provided name,\n    // using the more typical [i + 1] way of accessing an adjacent item.\n    // (In getNextEffectDescriptor(), we don't need to offset the index like\n    // that, because the shift already lines up the index as we need it.)\n    return this.effectDescriptors\n      .slice(0, -1)\n      .find((_, i) => this.effectDescriptors[i + 1].name === name);\n  }\n}\n\n// These are constant values which can be affected to tweak the way effects\n// are applied. They match the values used in Scratch 3.0.\nEffectChain.decayDuration = 0.025;\nEffectChain.decayWait = 0.05;\n\n// Instead of creating a basic Effect class and then implementing a subclass\n// for each effect type, we use a simplified object-descriptor style.\n// The makeNodes() function returns an object which is passed on to set(), so\n// that effects are able to access a variety of nodes (or other values, if\n// necessary) required to execute the desired effect.\n//\n// The code in makeNodes as well as the general definition for each effect is\n// all graciously based on LLK's scratch-audio library.\n//\n// The initial value of an effect should always be the value at which the\n// sound is not affected at all - i.e, it would be the same if the effect\n// nodes were completely disconnected from the chain or otherwise had never\n// been applied. This allows for clean discarding of effect nodes when returned\n// to the initial value.\n//\n// The order of this array matches AudioEngine's effects list in scratch-audio.\n// Earlier in the list is closer to the EffectChain input node; later is closer\n// to its target (output). Note that a non-\"patch\" effect's position in the\n// array has no bearing on effect behavior, since it isn't part of the chain\n// system.\n//\n// Note that this descriptor list is fairly easy to build on, if we'd like to\n// add more audio effects in the future. (Scratch used to have more, but they\n// were removed - see commit ff6cd4a - because they depended on an external\n// library and were too processor-intensive to support on some devices.)\nEffectChain.effectDescriptors = [\n  {\n    name: \"pan\",\n    initial: 0,\n    minimum: -100,\n    maximum: 100,\n    isPatch: true,\n    makeNodes() {\n      const aCtx = Sound.audioContext;\n      const input = aCtx.createGain();\n      const leftGain = aCtx.createGain();\n      const rightGain = aCtx.createGain();\n      const channelMerger = aCtx.createChannelMerger(2);\n      const output = channelMerger;\n      input.connect(leftGain);\n      input.connect(rightGain);\n      leftGain.connect(channelMerger, 0, 0);\n      rightGain.connect(channelMerger, 0, 1);\n      return { input, output, leftGain, rightGain, channelMerger };\n    },\n    set(value, { input, output, leftGain, rightGain }) {\n      const p = (value + 100) / 200;\n      const leftVal = Math.cos((p * Math.PI) / 2);\n      const rightVal = Math.sin((p * Math.PI) / 2);\n      const { currentTime } = Sound.audioContext;\n      const { decayWait, decayDuration } = EffectChain;\n      leftGain.gain.setTargetAtTime(\n        leftVal,\n        currentTime + decayWait,\n        decayDuration\n      );\n      rightGain.gain.setTargetAtTime(\n        rightVal,\n        currentTime + decayWait,\n        decayDuration\n      );\n    }\n  },\n  {\n    name: \"pitch\",\n    initial: 0,\n    isPatch: false,\n    set(value, sound) {\n      const interval = value / 10;\n      const ratio = Math.pow(2, interval / 12);\n      sound.setPlaybackRate(ratio);\n    }\n  },\n  {\n    name: \"volume\",\n    initial: 100,\n    minimum: 0,\n    maximum: 100,\n    resetOnStart: false,\n    resetOnClone: true,\n    isPatch: true,\n    makeNodes() {\n      const node = Sound.audioContext.createGain();\n      return {\n        input: node,\n        output: node,\n        node\n      };\n    },\n    set(value, { node }) {\n      node.gain.linearRampToValueAtTime(\n        value / 100,\n        Sound.audioContext.currentTime + EffectChain.decayDuration\n      );\n    }\n  }\n];\n\nexport class AudioEffectMap {\n  // This class provides a simple interface for setting and getting audio\n  // effects stored on an EffectChain, similar to EffectMap (that class being\n  // for graphic effects). It takes an EffectChain and automatically generates\n  // properties according to the names of the effect descriptors, acting with\n  // the EffectChain's API when accessed.\n\n  constructor(effectChain) {\n    this.effectChain = effectChain;\n\n    for (const { name } of EffectChain.effectDescriptors) {\n      Object.defineProperty(this, name, {\n        get: () => effectChain.getEffectValue(name),\n        set: value => effectChain.setEffectValue(name, value)\n      });\n    }\n  }\n\n  clear() {\n    this.effectChain.resetToInitial();\n  }\n}\n","import Color from \"./Color.ts\";\nimport Trigger from \"./Trigger.ts\";\nimport Sound, { EffectChain, AudioEffectMap } from \"./Sound.ts\";\n\nimport { effectNames } from \"./renderer/effectInfo.ts\";\n// This is a wrapper to allow the enabled effects in a sprite to be used as a Map key.\n// By setting an effect, the bitmask is updated as well.\n// This allows the bitmask to be used to uniquely identify a set of enabled effects.\nclass _EffectMap {\n  constructor() {\n    this._bitmask = 0;\n    this._effectValues = {};\n\n    for (let i = 0; i < effectNames.length; i++) {\n      const effectName = effectNames[i];\n      this._effectValues[effectName] = 0;\n\n      Object.defineProperty(this, effectName, {\n        get: () => {\n          return this._effectValues[effectName];\n        },\n\n        set: val => {\n          this._effectValues[effectName] = val;\n\n          if (val === 0) {\n            // If the effect value is 0, meaning it's disabled, set its bit in the bitmask to 0.\n            this._bitmask = this._bitmask & ~(1 << i);\n          } else {\n            // Otherwise, set its bit to 1.\n            this._bitmask = this._bitmask | (1 << i);\n          }\n        }\n      });\n    }\n  }\n\n  _clone() {\n    const m = new _EffectMap();\n    for (const effectName of Object.keys(this._effectValues)) {\n      m[effectName] = this[effectName];\n    }\n    return m;\n  }\n\n  clear() {\n    for (const effectName of Object.keys(this._effectValues)) {\n      this._effectValues[effectName] = 0;\n    }\n    this._bitmask = 0;\n  }\n}\n\nclass SpriteBase {\n  constructor(initialConditions, vars = {}) {\n    this._project = null;\n\n    const { costumeNumber, layerOrder = 0 } = initialConditions;\n    this._costumeNumber = costumeNumber;\n    this._layerOrder = layerOrder;\n\n    this.triggers = [];\n    this.watchers = {};\n    this.costumes = [];\n    this.sounds = [];\n\n    this.effectChain = new EffectChain({\n      getNonPatchSoundList: this.getSoundsPlayedByMe.bind(this)\n    });\n    this.effectChain.connect(Sound.audioContext.destination);\n\n    this.effects = new _EffectMap();\n    this.audioEffects = new AudioEffectMap(this.effectChain);\n\n    this._vars = vars;\n  }\n\n  getSoundsPlayedByMe() {\n    return this.sounds.filter(sound => this.effectChain.isTargetOf(sound));\n  }\n\n  get stage() {\n    return this._project.stage;\n  }\n\n  get sprites() {\n    return this._project.sprites;\n  }\n\n  get vars() {\n    return this._vars;\n  }\n\n  get costumeNumber() {\n    return this._costumeNumber;\n  }\n\n  set costumeNumber(number) {\n    this._costumeNumber = this.wrapClamp(number, 1, this.costumes.length);\n    if (this.fireBackdropChanged) this.fireBackdropChanged();\n  }\n\n  set costume(costume) {\n    if (typeof costume === \"number\") {\n      this.costumeNumber = costume;\n    }\n    if (typeof costume === \"string\") {\n      const index = this.costumes.findIndex(c => c.name === costume);\n      if (index > -1) {\n        this.costumeNumber = index + 1;\n      } else {\n        switch (costume) {\n          case \"next costume\":\n          case \"next backdrop\": {\n            this.costumeNumber = this.costumeNumber + 1;\n            break;\n          }\n\n          case \"previous costume\":\n          case \"previous backdrop\": {\n            this.costumeNumber = this.costumeNumber - 1;\n            break;\n          }\n\n          case \"random costume\":\n          case \"random backdrop\": {\n            // Based on joker314's inclusiveRandIntWithout: https://github.com/LLK/scratch-vm/pull/2011\n            // Note: We use 1 -> length instead of 0 -> length-1, since we want a 1-indexed result.\n            const lower = 1;\n            const upper = this.costumes.length;\n            const excluded = this.costumeNumber;\n\n            const possibleOptions = upper - lower;\n            let randInt = lower + Math.floor(Math.random() * possibleOptions);\n            if (randInt >= excluded) {\n              randInt++;\n            }\n\n            this.costumeNumber = randInt;\n            break;\n          }\n\n          default: {\n            if (!(isNaN(costume) || costume.trim().length === 0)) {\n              this.costumeNumber = Number(costume);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  get costume() {\n    return this.costumes[this.costumeNumber - 1];\n  }\n\n  moveAhead(value = Infinity) {\n    if (typeof value === \"number\") {\n      this._project.changeSpriteLayer(this, value);\n    } else {\n      this._project.changeSpriteLayer(this, 1, value);\n    }\n  }\n\n  moveBehind(value = Infinity) {\n    if (typeof value === \"number\") {\n      this._project.changeSpriteLayer(this, -value);\n    } else {\n      this._project.changeSpriteLayer(this, -1, value);\n    }\n  }\n\n  degToRad(deg) {\n    return (deg * Math.PI) / 180;\n  }\n\n  radToDeg(rad) {\n    return (rad * 180) / Math.PI;\n  }\n\n  degToScratch(deg) {\n    return -deg + 90;\n  }\n\n  scratchToDeg(scratchDir) {\n    return -scratchDir + 90;\n  }\n\n  radToScratch(rad) {\n    return this.degToScratch(this.radToDeg(rad));\n  }\n\n  scratchToRad(scratchDir) {\n    return this.degToRad(this.scratchToDeg(scratchDir));\n  }\n\n  // From scratch-vm's math-util.\n  scratchTan(angle) {\n    angle = angle % 360;\n    switch (angle) {\n      case -270:\n      case 90:\n        return Infinity;\n      case -90:\n      case 270:\n        return -Infinity;\n      default:\n        return parseFloat(Math.tan((Math.PI * angle) / 180).toFixed(10));\n    }\n  }\n\n  // Wrap rotation from -180 to 180.\n  normalizeDeg(deg) {\n    // This is a pretty big math expression, but it's necessary because in JavaScript,\n    // the % operator means \"remainder\", not \"modulo\", and so negative numbers won't \"wrap around\".\n    // See https://web.archive.org/web/20090717035140if_/javascript.about.com/od/problemsolving/a/modulobug.htm\n    return ((((deg + 180) % 360) + 360) % 360) - 180;\n  }\n\n  // Keep a number between two limits, wrapping \"extra\" into the range.\n  // wrapClamp(7, 1, 5) == 2\n  // wrapClamp(0, 1, 5) == 5\n  // wrapClamp(-11, -10, 6) == 6\n  // Borrowed from scratch-vm (src/util/math-util.ts)\n  wrapClamp(n, min, max) {\n    const range = (max - min) + 1;\n    return n - (Math.floor((n - min) / range) * range);\n  }\n\n  // Given a generator function, return a version of it that runs in \"warp mode\" (no yields).\n  warp(procedure) {\n    const bound = procedure.bind(this);\n    return (...args) => {\n      const inst = bound(...args);\n      while (!inst.next().done);\n    };\n  }\n\n  random(a, b) {\n    const min = Math.min(a, b);\n    const max = Math.max(a, b);\n    if (min % 1 === 0 && max % 1 === 0) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    return Math.random() * (max - min) + min;\n  }\n\n  *wait(secs) {\n    let endTime = new Date();\n    endTime.setMilliseconds(endTime.getMilliseconds() + secs * 1000);\n    while (new Date() < endTime) {\n      yield;\n    }\n  }\n\n  get mouse() {\n    return this._project.input.mouse;\n  }\n\n  keyPressed(name) {\n    return this._project.input.keyPressed(name);\n  }\n\n  get timer() {\n    return this._project.timer;\n  }\n\n  restartTimer() {\n    this._project.restartTimer();\n  }\n\n  *startSound(soundName) {\n    const sound = this.getSound(soundName);\n    if (sound) {\n      this.effectChain.applyToSound(sound);\n      yield* sound.start();\n    }\n  }\n\n  *playSoundUntilDone(soundName) {\n    const sound = this.getSound(soundName);\n    if (sound) {\n      sound.connect(this.effectChain.inputNode);\n      this.effectChain.applyToSound(sound);\n      yield* sound.playUntilDone();\n    }\n  }\n\n  getSound(soundName) {\n    if (typeof soundName === \"number\") {\n      return this.sounds[(soundName - 1) % this.sounds.length];\n    } else {\n      return this.sounds.find(s => s.name === soundName);\n    }\n  }\n\n  stopAllSounds() {\n    this._project.stopAllSounds();\n  }\n\n  stopAllOfMySounds() {\n    for (const sound of this.sounds) {\n      sound.stop();\n    }\n  }\n\n  broadcast(name) {\n    return this._project.fireTrigger(Trigger.BROADCAST, { name });\n  }\n\n  *broadcastAndWait(name) {\n    let running = true;\n    this.broadcast(name).then(() => {\n      running = false;\n    });\n\n    while (running) {\n      yield;\n    }\n  }\n\n  clearPen() {\n    this._project.renderer.clearPen();\n  }\n\n  *askAndWait(question) {\n    if (this._speechBubble) {\n      this.say(\"\");\n    }\n\n    let done = false;\n    this._project.askAndWait(question).then(() => {\n      done = true;\n    });\n\n    while (!done) yield;\n  }\n\n  get answer() {\n    return this._project.answer;\n  }\n\n  get loudness() {\n    return this._project.loudness;\n  }\n\n  toNumber(value) {\n    if (typeof value === 'number') {\n      if (isNaN(value)) {\n        return 0;\n      }\n      return value;\n    }\n\n    const n = Number(value);\n    if (Number.isNaN(n)) {\n      return 0;\n    }\n    return n;\n  }\n\n  toBoolean(value) {\n    if (typeof value === 'boolean') {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      if (value === '' || value === '0' || value.toLowerCase() === 'false') {\n        return false;\n      }\n      return true;\n    }\n\n    return Boolean(value);\n  }\n\n  toString(value) {\n    return String(value);\n  }\n\n  stringIncludes(string, substring) {\n    return string.toLowerCase().includes(substring.toLowerCase());\n  }\n\n  arrayIncludes(array, value) {\n    return array.some(item => this.compare(item, value) === 0);\n  }\n\n  letterOf(string, index) {\n    if (index < 0 || index >= string.length) {\n      return \"\";\n    }\n    return string[index];\n  }\n\n  itemOf(array, index) {\n    if (index < 0 || index >= array.length) {\n      return \"\";\n    }\n    return array[index];\n  }\n\n  indexInArray(array, value) {\n    return array.findIndex(item => this.compare(item, value) === 0);\n  }\n\n  compare(v1, v2) {\n    if (v1 === v2) {\n      return 0;\n    }\n\n    let n1 = Number(v1);\n    let n2 = Number(v2);\n    if (\n      (n1 === Infinity && n2 === Infinity) ||\n      (n1 === -Infinity && n2 === -Infinity)\n    ) {\n      return 0;\n    }\n\n    if (n1 === 0 && (v1 === null || typeof v1 === 'string' && v1.trim().length === 0)) {\n      n1 = NaN;\n    } else if (n2 === 0 && (v2 === null || typeof v2 === 'string' && v2.trim().length === 0)) {\n      n2 = NaN;\n    }\n\n    if (!isNaN(n1) && !isNaN(n2)) {\n      return n1 - n2;\n    }\n\n    const s1 = String(v1).toLowerCase();\n    const s2 = String(v2).toLowerCase();\n\n    if (s1 === s2) {\n      return 0;\n    } else if (s1 < s2) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n}\n\nexport class Sprite extends SpriteBase {\n  constructor(initialConditions, ...args) {\n    super(initialConditions, ...args);\n\n    const {\n      x,\n      y,\n      direction,\n      rotationStyle,\n      costumeNumber,\n      size,\n      visible,\n      penDown,\n      penSize,\n      penColor\n    } = initialConditions;\n\n    this._x = x;\n    this._y = y;\n    this._direction = direction;\n    this.rotationStyle = rotationStyle || Sprite.RotationStyle.ALL_AROUND;\n    this._costumeNumber = costumeNumber;\n    this.size = size;\n    this.visible = visible;\n\n    this.parent = null;\n    this.clones = [];\n\n    this._penDown = penDown || false;\n    this.penSize = penSize || 1;\n    this._penColor = penColor || Color.rgb(0, 0, 255);\n\n    this._speechBubble = {\n      text: \"\",\n      style: \"say\",\n      timeout: null\n    };\n  }\n\n  createClone() {\n    const clone = Object.assign(\n      Object.create(Object.getPrototypeOf(this)),\n      this\n    );\n\n    clone._project = this._project;\n    clone.triggers = this.triggers.map(\n      trigger => new Trigger(trigger.trigger, trigger.options, trigger._script)\n    );\n    clone.costumes = this.costumes;\n    clone.sounds = this.sounds;\n    clone._vars = Object.assign({}, this._vars);\n\n    clone._speechBubble = {\n      text: \"\",\n      style: \"say\",\n      timeout: null\n    };\n\n    clone.effects = this.effects._clone();\n\n    // Clones inherit audio effects from the original sprite, for some reason.\n    // Couldn't explain it, but that's the behavior in Scratch 3.0.\n    let original = this;\n    while (original.parent) {\n      original = original.parent;\n    }\n    clone.effectChain = original.effectChain.clone({\n      getNonPatchSoundList: clone.getSoundsPlayedByMe.bind(clone)\n    });\n\n    // Make a new audioEffects interface which acts on the cloned effect chain.\n    clone.audioEffects = new AudioEffectMap(clone.effectChain);\n\n    clone.clones = [];\n    clone.parent = this;\n    this.clones.push(clone);\n\n    // Trigger CLONE_START:\n    const triggers = clone.triggers.filter(tr =>\n      tr.matches(Trigger.CLONE_START, {}, clone)\n    );\n    this._project._startTriggers(\n      triggers.map(trigger => ({ trigger, target: clone }))\n    );\n  }\n\n  deleteThisClone() {\n    if (this.parent === null) return;\n\n    this.parent.clones = this.parent.clones.filter(clone => clone !== this);\n\n    this._project.runningTriggers = this._project.runningTriggers.filter(\n      ({ target }) => target !== this\n    );\n  }\n\n  andClones() {\n    return [this, ...this.clones.flatMap(clone => clone.andClones())];\n  }\n\n  get direction() {\n    return this._direction;\n  }\n\n  set direction(dir) {\n    this._direction = this.normalizeDeg(dir);\n  }\n\n  goto(x, y) {\n    if (x === this.x && y === this.y) return;\n\n    if (this.penDown) {\n      this._project.renderer.penLine(\n        { x: this._x, y: this._y },\n        { x, y },\n        this._penColor,\n        this.penSize\n      );\n    }\n\n    this._x = x;\n    this._y = y;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  set x(x) {\n    this.goto(x, this._y);\n  }\n\n  get y() {\n    return this._y;\n  }\n\n  set y(y) {\n    this.goto(this._x, y);\n  }\n\n  move(dist) {\n    const moveDir = this.scratchToRad(this.direction);\n\n    this.goto(\n      this._x + dist * Math.cos(moveDir),\n      this._y + dist * Math.sin(moveDir)\n    );\n  }\n\n  *glide(seconds, x, y) {\n    const interpolate = (a, b, t) => a + (b - a) * t;\n\n    const startTime = new Date();\n    const startX = this._x;\n    const startY = this._y;\n\n    let t;\n    do {\n      t = (new Date() - startTime) / (seconds * 1000);\n      this.goto(interpolate(startX, x, t), interpolate(startY, y, t));\n      yield;\n    } while (t < 1);\n  }\n\n  get penDown() {\n    return this._penDown;\n  }\n\n  set penDown(penDown) {\n    if (penDown) {\n      this._project.renderer.penLine(\n        { x: this.x, y: this.y },\n        { x: this.x, y: this.y },\n        this._penColor,\n        this.penSize\n      );\n    }\n    this._penDown = penDown;\n  }\n\n  get penColor() {\n    return this._penColor;\n  }\n\n  set penColor(color) {\n    if (color instanceof Color) {\n      this._penColor = color;\n    } else {\n      console.error(\n        `${color} is not a valid penColor. Try using the Color class!`\n      );\n    }\n  }\n\n  stamp() {\n    this._project.renderer.stamp(this);\n  }\n\n  touching(target, fast = false) {\n    if (typeof target === \"string\") {\n      switch (target) {\n        case \"mouse\":\n          return this._project.renderer.checkPointCollision(\n            this,\n            {\n              x: this.mouse.x,\n              y: this.mouse.y\n            },\n            fast\n          );\n        case \"edge\": {\n          const bounds = this._project.renderer.getTightBoundingBox(this);\n          const stageWidth = this.stage.width;\n          const stageHeight = this.stage.height;\n          return (\n            bounds.left < -stageWidth / 2 ||\n            bounds.right > stageWidth / 2 ||\n            bounds.top > stageHeight / 2 ||\n            bounds.bottom < -stageHeight / 2\n          );\n        }\n        default:\n          console.error(\n            `Cannot find target \"${target}\" in \"touching\". Did you mean to pass a sprite class instead?`\n          );\n          return false;\n      }\n    } else if (target instanceof Color) {\n      return this._project.renderer.checkColorCollision(this, target);\n    }\n\n    return this._project.renderer.checkSpriteCollision(this, target, fast);\n  }\n\n  colorTouching(color, target) {\n    if (typeof target === \"string\") {\n      console.error(\n        `Cannot find target \"${target}\" in \"touchingColor\". Did you mean to pass a sprite class instead?`\n      );\n      return false;\n    }\n\n    if (typeof color === \"string\") {\n      console.error(\n        `Cannot find color \"${color}\" in \"touchingColor\". Did you mean to pass a Color instance instead?`\n      );\n      return false;\n    }\n\n    if (target instanceof Color) {\n      // \"Color is touching color\"\n      return this._project.renderer.checkColorCollision(this, target, color);\n    } else {\n      // \"Color is touching sprite\" (not implemented in Scratch!)\n      return this._project.renderer.checkSpriteCollision(\n        this,\n        target,\n        false,\n        color\n      );\n    }\n  }\n\n  say(text) {\n    clearTimeout(this._speechBubble.timeout);\n    this._speechBubble = { text: String(text), style: \"say\", timeout: null };\n  }\n\n  think(text) {\n    clearTimeout(this._speechBubble.timeout);\n    this._speechBubble = { text: String(text), style: \"think\", timeout: null };\n  }\n\n  *sayAndWait(text, seconds) {\n    clearTimeout(this._speechBubble.timeout);\n\n    let done = false;\n    const timeout = setTimeout(() => {\n      this._speechBubble.text = \"\";\n      this.timeout = null;\n      done = true;\n    }, seconds * 1000);\n\n    this._speechBubble = { text, style: \"say\", timeout };\n    while (!done) yield;\n  }\n\n  *thinkAndWait(text, seconds) {\n    clearTimeout(this._speechBubble.timeout);\n\n    let done = false;\n    const timeout = setTimeout(() => {\n      this._speechBubble.text = \"\";\n      this.timeout = null;\n      done = true;\n    }, seconds * 1000);\n\n    this._speechBubble = { text, style: \"think\", timeout };\n    while (!done) yield;\n  }\n}\n\nSprite.RotationStyle = Object.freeze({\n  ALL_AROUND: Symbol(\"ALL_AROUND\"),\n  LEFT_RIGHT: Symbol(\"LEFT_RIGHT\"),\n  DONT_ROTATE: Symbol(\"DONT_ROTATE\")\n});\n\nexport class Stage extends SpriteBase {\n  constructor(initialConditions, ...args) {\n    super(initialConditions, ...args);\n\n    // Use defineProperties to make these non-writable.\n    // Changing the width and height of the stage after initialization isn't supported.\n    Object.defineProperties(this, {\n      width: {\n        value: initialConditions.width || 1280,\n        enumerable: true\n      },\n      height: {\n        value: initialConditions.height || 720,\n        enumerable: true\n      }\n    });\n\n    this.name = \"Stage\";\n\n    // For obsolete counter blocks.\n    this.__counter = 0;\n  }\n\n  fireBackdropChanged() {\n    return this._project.fireTrigger(Trigger.BACKDROP_CHANGED, {\n      backdrop: this.costume.name\n    });\n  }\n}\n","import Matrix from \"./Matrix.ts\";\n\nimport Rectangle from \"./Rectangle.ts\";\nimport effectTransformPoint from \"./effectTransformPoint.ts\";\nimport { effectBitmasks } from \"./effectInfo.ts\";\n\nimport { Sprite, Stage } from \"../Sprite.ts\";\n\n// Returns the determinant of two vectors, the vector from A to B and the vector\n// from A to C. If positive, it means AC is counterclockwise from AB.\n// If negative, AC is clockwise from AB.\nconst determinant = (a, b, c) => {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n};\n\n// Used to track whether a sprite's transform has changed since we last looked\n// at it.\n// TODO: store renderer-specific data on the sprite and have *it* set a\n// \"transform changed\" flag.\nclass SpriteTransformDiff {\n  constructor(sprite) {\n    this._sprite = sprite;\n    this._unset = true;\n    this.update();\n  }\n\n  update() {\n    this._lastX = this._sprite.x;\n    this._lastY = this._sprite.y;\n    this._lastRotation = this._sprite.direction;\n    this._lastRotationStyle = this._sprite.rotationStyle;\n    this._lastSize = this._sprite.size;\n    this._lastCostume = this._sprite.costume;\n    this._lastCostumeLoaded = this._sprite.costume.img.complete;\n    this._unset = false;\n  }\n\n  get changed() {\n    return (\n      this._lastX !== this._sprite.x ||\n      this._lastY !== this._sprite.y ||\n      this._lastRotation !== this._sprite.direction ||\n      this._lastRotationStyle !== this._sprite.rotationStyle ||\n      this._lastSize !== this._sprite.size ||\n      this._lastCostume !== this._sprite.costume ||\n      this._lastCostumeLoaded !== this._sprite.costume.img.complete ||\n      this._unset\n    );\n  }\n}\n\n// Renderer-specific data for an instance (the original or a clone) of a Sprite\nexport default class Drawable {\n  constructor(renderer, sprite) {\n    this._renderer = renderer;\n    this._sprite = sprite;\n\n    // Transformation matrix for the sprite.\n    this._matrix = Matrix.create();\n    // Track when the sprite's transform changes so we can recalculate the\n    // transform matrix.\n    this._matrixDiff = new SpriteTransformDiff(sprite);\n    this._calculateSpriteMatrix();\n\n    // Track when the image data used to calculate the convex hull,\n    // or distortion effects that affect how it's drawn, change.\n    // We also need the image data to know how big the pixels are.\n    this._convexHullImageData = null;\n    this._convexHullMosaic = 0;\n    this._convexHullPixelate = 0;\n    this._convexHullWhirl = 0;\n    this._convexHullFisheye = 0;\n    this._convexHullPoints = null;\n\n    this._aabb = new Rectangle();\n    this._tightBoundingBox = new Rectangle();\n    // Track when the sprite's transform changes so we can recalculate the\n    // tight bounding box.\n    this._convexHullMatrixDiff = new SpriteTransformDiff(sprite);\n  }\n\n  getCurrentSkin() {\n    return this._renderer._getSkin(this._sprite.costume);\n  }\n\n  // Get the rough axis-aligned bounding box for this sprite. Not as tight as\n  // getTightBoundingBox, especially when rotated.\n  getAABB() {\n    return Rectangle.fromMatrix(this.getMatrix(), this._aabb);\n  }\n\n  // Get the Scratch-space tight bounding box for this sprite.\n  getTightBoundingBox() {\n    if (!this._convexHullMatrixDiff.changed) return this._tightBoundingBox;\n\n    const matrix = this.getMatrix();\n    const convexHullPoints = this._calculateConvexHull();\n    // Maybe the costume isn't loaded yet. Return a 0x0 bounding box around the\n    // center of the sprite.\n    if (convexHullPoints === null) {\n      return Rectangle.fromBounds(\n        this._sprite.x,\n        this._sprite.y,\n        this._sprite.x,\n        this._sprite.y,\n        this._tightBoundingBox\n      );\n    }\n\n    let left = Infinity;\n    let right = -Infinity;\n    let top = -Infinity;\n    let bottom = Infinity;\n    const transformedPoint = [0, 0];\n\n    // Each convex hull point is the center of a pixel. However, said pixels\n    // each have area. We must take into account the size of the pixels when\n    // calculating the bounds. The pixel dimensions depend on the scale and\n    // rotation (as we're treating pixels as squares, which change dimensions\n    // when rotated).\n    const xa = matrix[0] / 2;\n    const xb = matrix[3] / 2;\n    const halfPixelX =\n      (Math.abs(xa) + Math.abs(xb)) / this._convexHullImageData.width;\n    const ya = matrix[1] / 2;\n    const yb = matrix[4] / 2;\n    const halfPixelY =\n      (Math.abs(ya) + Math.abs(yb)) / this._convexHullImageData.height;\n\n    // Transform every point in the convex hull using our transform matrix,\n    // and expand the bounds to include that point.\n    for (let i = 0; i < convexHullPoints.length; i++) {\n      const point = convexHullPoints[i];\n      transformedPoint[0] = point[0];\n      transformedPoint[1] = 1 - point[1];\n      Matrix.transformPoint(matrix, transformedPoint, transformedPoint);\n\n      left = Math.min(left, transformedPoint[0] - halfPixelX);\n      right = Math.max(right, transformedPoint[0] + halfPixelX);\n      top = Math.max(top, transformedPoint[1] + halfPixelY);\n      bottom = Math.min(bottom, transformedPoint[1] - halfPixelY);\n    }\n\n    Rectangle.fromBounds(left, right, bottom, top, this._tightBoundingBox);\n    this._convexHullMatrixDiff.update();\n    return this._tightBoundingBox;\n  }\n\n  _calculateConvexHull() {\n    const sprite = this._sprite;\n    const skin = this.getCurrentSkin();\n    const imageData = skin.getImageData(\n      \"size\" in sprite ? sprite.size / 100 : 1\n    );\n    if (!imageData) return null;\n\n    // We only need to recalculate the convex hull points if the image data's\n    // changed since we last calculated the convex hull, or if the sprite's\n    // effects which distort its shape have changed.\n    const { mosaic, pixelate, whirl, fisheye } = sprite.effects;\n    if (\n      this._convexHullImageData === imageData &&\n      this._convexHullMosaic === mosaic &&\n      this._convexHullPixelate === pixelate &&\n      this._convexHullWhirl === whirl &&\n      this._convexHullFisheye === fisheye\n    ) {\n      return this._convexHullPoints;\n    }\n\n    const effectBitmask =\n      sprite.effects._bitmask &\n      (effectBitmasks.mosaic |\n        effectBitmasks.pixelate |\n        effectBitmasks.whirl |\n        effectBitmasks.fisheye);\n\n    const leftHull = [];\n    const rightHull = [];\n\n    const { width, height, data } = imageData;\n\n    const pixelPos = [0, 0];\n    const effectPos = [0, 0];\n    let currentPoint;\n    // Not Scratch-space: y increases as we go downwards\n    // Loop over all rows of pixels in the costume, starting at the top\n    for (let y = 0; y < height; y++) {\n      pixelPos[1] = (y + 0.5) / height;\n\n      // We start at the leftmost point, then go rightwards until we hit an\n      // opaque pixel\n      let x = 0;\n      for (; x < width; x++) {\n        pixelPos[0] = (x + 0.5) / width;\n        let pixelX = x;\n        let pixelY = y;\n        if (effectBitmask !== 0) {\n          effectTransformPoint(this, pixelPos, effectPos);\n          pixelX = Math.floor(effectPos[0] * width);\n          pixelY = Math.floor(effectPos[1] * height);\n        }\n        // We hit an opaque pixel\n        if (data[(pixelY * width + pixelX) * 4 + 3] > 0) {\n          currentPoint = [pixelPos[0], pixelPos[1]];\n          break;\n        }\n      }\n\n      // There are no opaque pixels on this row. Go to the next one.\n      if (x >= width) continue;\n\n      // If appending the current point to the left hull makes a\n      // counterclockwise turn, we want to append the current point to it.\n      // Otherwise, we remove hull points until the current point makes a\n      // counterclockwise turn with the last two points.\n      while (leftHull.length >= 2) {\n        if (\n          determinant(\n            leftHull[leftHull.length - 1],\n            leftHull[leftHull.length - 2],\n            currentPoint\n          ) > 0\n        ) {\n          break;\n        }\n\n        leftHull.pop();\n      }\n\n      leftHull.push(currentPoint);\n\n      // Now we repeat the process for the right side, looking leftwards for an\n      // opaque pixel.\n      for (x = width - 1; x >= 0; x--) {\n        pixelPos[0] = (x + 0.5) / width;\n        effectTransformPoint(this, pixelPos, effectPos);\n        let pixelX = x;\n        let pixelY = y;\n        if (effectBitmask !== 0) {\n          effectTransformPoint(this, pixelPos, effectPos);\n          pixelX = Math.floor(effectPos[0] * width);\n          pixelY = Math.floor(effectPos[1] * height);\n        }\n        // We hit an opaque pixel\n        if (data[(pixelY * width + pixelX) * 4 + 3] > 0) {\n          currentPoint = [pixelPos[0], pixelPos[1]];\n          break;\n        }\n      }\n\n      // Because we're coming at this from the right, it goes clockwise.\n      while (rightHull.length >= 2) {\n        if (\n          determinant(\n            rightHull[rightHull.length - 1],\n            rightHull[rightHull.length - 2],\n            currentPoint\n          ) < 0\n        ) {\n          break;\n        }\n\n        rightHull.pop();\n      }\n\n      rightHull.push(currentPoint);\n    }\n\n    // Add points from the right side in reverse order so all the points are\n    // clockwise.\n    for (let i = rightHull.length - 1; i >= 0; i--) {\n      leftHull.push(rightHull[i]);\n    }\n\n    this._convexHullPoints = leftHull;\n    this._convexHullMosaic = mosaic;\n    this._convexHullPixelate = pixelate;\n    this._convexHullWhirl = whirl;\n    this._convexHullFisheye = fisheye;\n    this._convexHullImageData = imageData;\n\n    return this._convexHullPoints;\n  }\n\n  _calculateSpriteMatrix() {\n    const m = this._matrix;\n    Matrix.identity(m);\n    const spr = this._sprite;\n    if (!(spr instanceof Stage)) {\n      Matrix.translate(m, m, spr.x, spr.y);\n      switch (spr.rotationStyle) {\n        case Sprite.RotationStyle.ALL_AROUND: {\n          Matrix.rotate(m, m, spr.scratchToRad(spr.direction));\n          break;\n        }\n        case Sprite.RotationStyle.LEFT_RIGHT: {\n          if (spr.direction < 0) Matrix.scale(m, m, -1, 1);\n          break;\n        }\n      }\n\n      const spriteScale = spr.size / 100;\n      Matrix.scale(m, m, spriteScale, spriteScale);\n    }\n\n    const scalingFactor = 1 / spr.costume.resolution;\n    // Rotation centers are in non-Scratch space (positive y-values = down),\n    // but these transforms are in Scratch space (negative y-values = down).\n    Matrix.translate(\n      m,\n      m,\n      -spr.costume.center.x * scalingFactor,\n      (spr.costume.center.y - spr.costume.height) * scalingFactor\n    );\n    Matrix.scale(\n      m,\n      m,\n      spr.costume.width * scalingFactor,\n      spr.costume.height * scalingFactor\n    );\n\n    // Store the values we used to compute the matrix so we only recalculate\n    // the matrix when we really need to.\n    this._matrixDiff.update();\n  }\n\n  getMatrix() {\n    // If all the values we used to calculate the matrix haven't changed since\n    // we last calculated the matrix, we can just return the matrix as-is.\n    if (this._matrixDiff.changed) {\n      this._calculateSpriteMatrix();\n    }\n\n    return this._matrix;\n  }\n}\n","export default class Skin {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.gl = renderer.gl;\n  }\n\n  // Get the skin's texture for a given (screen-space) scale.\n  /* eslint-disable-next-line no-unused-vars */\n  getTexture(scale) {\n    return null;\n  }\n\n  // Get the skin image's ImageData at a given (screen-space) scale.\n  // eslint-disable-next-line no-unused-vars\n  getImageData(scale) {\n    throw new Error(\"getImageData not implemented for this skin type\");\n  }\n\n  // Helper function to create a texture from an image and handle all the boilerplate.\n  _makeTexture(image, filtering) {\n    const gl = this.gl;\n    const glTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, glTexture);\n    // These need to be set because most sprite textures don't have power-of-two dimensions.\n    // Non-power-of-two textures only work with gl.CLAMP_TO_EDGE wrapping behavior,\n    // and because they don't support automatic mipmaps, can only use non-mipmap texture filtering.\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filtering);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filtering);\n    if (image)\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl.RGBA,\n        gl.RGBA,\n        gl.UNSIGNED_BYTE,\n        image\n      );\n\n    return glTexture;\n  }\n\n  // Helper function to set this skin's size based on an image that may or may not be loaded.\n  _setSizeFromImage(image) {\n    if (image.complete) {\n      this.width = image.naturalWidth;\n      this.height = image.naturalHeight;\n    } else {\n      image.addEventListener(\"load\", () => {\n        this.width = image.naturalWidth;\n        this.height = image.naturalHeight;\n      });\n    }\n  }\n\n  // Clean up any textures or other objets created by this skin.\n  destroy() {}\n}\n","import Skin from \"./Skin.ts\";\n\nexport default class BitmapSkin extends Skin {\n  constructor(renderer, image) {\n    super(renderer);\n\n    this._image = image;\n    this._imageData = null;\n    this._texture = null;\n\n    this._setSizeFromImage(image);\n  }\n\n  getImageData() {\n    // Make sure to handle potentially non-loaded textures\n    if (!this._image.complete) return null;\n\n    if (!this._imageData) {\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = this._image.naturalWidth || this._image.width;\n      canvas.height = this._image.naturalHeight || this._image.height;\n      const ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(this._image, 0, 0);\n      // Cache image data so we can reuse it\n      this._imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    }\n\n    return this._imageData;\n  }\n\n  getTexture() {\n    // Make sure to handle potentially non-loaded textures\n    const image = this._image;\n    if (!image.complete) return null;\n\n    if (this._texture === null) {\n      // Use nearest-neighbor (i.e. blocky) texture filtering for bitmaps\n      this._texture = super._makeTexture(image, this.gl.NEAREST);\n    }\n    return this._texture;\n  }\n\n  destroy() {\n    if (this._texture !== null) this.gl.deleteTexture(this._texture);\n  }\n}\n","const SpriteShader = {};\n\nSpriteShader.vertex = `\nprecision mediump float;\n\nattribute vec2 a_position;\nuniform mat3 u_transform;\nuniform vec2 u_stageSize;\n\nvarying vec2 v_texCoord;\n\nvoid main() {\n  v_texCoord = vec2(a_position.x, 1.0 - a_position.y);\n  gl_Position = vec4((u_transform * vec3(a_position, 1.0)) / vec3(u_stageSize * 0.5, 1.0), 1.0);\n}\n`;\n\nSpriteShader.fragment = `\nprecision mediump float;\n\nconst float epsilon = 1e-3;\n\nuniform sampler2D u_texture;\nvarying vec2 v_texCoord;\n\n#ifdef EFFECT_color\nuniform float u_color;\n#endif\n\n#ifdef EFFECT_fisheye\nuniform float u_fisheye;\n#endif\n\n#ifdef EFFECT_whirl\nuniform float u_whirl;\n#endif\n\n#ifdef EFFECT_pixelate\nuniform float u_pixelate;\nuniform vec2 u_skinSize;\n#endif\n\n#ifdef EFFECT_mosaic\nuniform float u_mosaic;\n#endif\n\n#ifdef EFFECT_brightness\nuniform float u_brightness;\n#endif\n\n#ifdef EFFECT_ghost\nuniform float u_ghost;\n#endif\n\n#if defined(EFFECT_whirl) || defined(EFFECT_fisheye) || defined(EFFECT_pixelate)\nconst vec2 CENTER = vec2(0.5, 0.5);\n#endif\n\n#ifdef DRAW_MODE_COLOR_MASK\nuniform vec4 u_colorMask;\n\n// TODO: Scratch 2.0 and Scratch 3.0's CPU path check if the top 6 bits match,\n// which a tolerance of 3/255 should be equivalent to,\n// but Scratch's GPU path has a tolerance of 2/255.\nconst vec3 COLOR_MASK_TOLERANCE = vec3(3.0 / 255.0);\n#endif\n\n#ifdef DRAW_MODE_SPRITE_ID\nuniform vec3 u_spriteId;\n#endif\n\n#ifdef EFFECT_color\n// Taken from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n  vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n  vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n  float d = q.x - min(q.w, q.y);\n  float e = 1.0e-10;\n  return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n#endif\n\nvoid main() {\n  vec2 coord = v_texCoord;\n\n  #ifdef EFFECT_mosaic\n  {\n    float mosaicFactor = clamp(floor(abs(u_mosaic + 10.0) / 10.0 + 0.5), 1.0, 512.0);\n    coord = fract(coord * mosaicFactor);\n  }\n  #endif\n\n  #ifdef EFFECT_pixelate\n    vec2 pixSize = u_skinSize / (abs(u_pixelate) * 0.1);\n    coord = (floor(coord * pixSize) + CENTER) / pixSize;\n  #endif\n\n  #ifdef EFFECT_whirl\n  {\n    const float PI_OVER_180 = 0.017453292519943295;\n    vec2 offset = coord - CENTER;\n    float whirlFactor = max(1.0 - (length(offset) * 2.0), 0.0);\n    float whirl = (-u_whirl * PI_OVER_180) * whirlFactor * whirlFactor;\n    float s = sin(whirl);\n    float c = cos(whirl);\n    mat2 rotationMatrix = mat2(c, -s, s, c);\n    coord = rotationMatrix * offset + CENTER;\n  }\n  #endif\n\n  #ifdef EFFECT_fisheye\n  {\n    vec2 vec = (coord - CENTER) / CENTER;\n    float len = length(vec) + epsilon;\n    float factor = max(0.0, (u_fisheye + 100.0) / 100.0);\n    float r = pow(min(len, 1.0), factor) * max(1.0, len);\n    vec2 unit = vec / len;\n    coord = CENTER + (r * unit * CENTER);\n  }\n  #endif\n\n  vec4 color = texture2D(u_texture, coord);\n\n  #if defined(EFFECT_color) || defined(EFFECT_brightness)\n  // Un-premultiply color values by alpha channel\n  vec3 unmul = color.rgb / color.a;\n\n  #ifdef EFFECT_color\n  {\n    vec3 hsv = rgb2hsv(unmul);\n    const float minLightness = 0.11 / 2.0;\n    const float minSaturation = 0.09;\n\n    hsv.z = max(minLightness, hsv.z);\n    hsv.y = max(minSaturation, hsv.y);\n\n    hsv.x = mod(hsv.x + (u_color / 200.0), 1.0);\n\n    unmul = hsv2rgb(hsv);\n  }\n  #endif\n\n  #ifdef EFFECT_brightness\n  {\n    unmul = clamp(unmul + clamp(u_brightness * 0.01, -1.0, 1.0), 0.0, 1.0);\n  }\n  #endif\n\n  color = vec4(unmul * color.a, color.a);\n\n  #endif // defined(defined(EFFECT_color) || defined(EFFECT_brightness))\n\n  #ifdef DRAW_MODE_COLOR_MASK\n  vec3 diff = abs(u_colorMask.rgb - color.rgb);\n  if (any(greaterThan(diff, COLOR_MASK_TOLERANCE))) {\n    discard;\n  }\n  #endif\n\n  #ifdef EFFECT_ghost\n  color *= (1.0 - clamp(u_ghost * 0.01, 0.0, 1.0));\n  #endif\n\n  #ifdef DRAW_MODE_SILHOUETTE\n  if (color.a == 0.0) {\n    discard;\n  }\n  #endif\n\n  #ifdef DRAW_MODE_SPRITE_ID\n  color = color.a > 0.0 ? vec4(u_spriteId, 1.0) : vec4(0.0, 0.0, 0.0, 0.0);\n  #endif\n\n  gl_FragColor = color;\n}\n`;\n\nconst PenLineShader = {};\n\nPenLineShader.vertex = `\nprecision mediump float;\n\nattribute vec2 a_position;\n// The X and Y components of u_penPoints hold the first pen point. The Z and W components hold the difference between\n// the second pen point and the first. This is done because calculating the difference in the shader leads to floating-\n// point error when both points have large-ish coordinates.\nuniform vec4 u_penPoints;\nuniform vec2 u_penSkinSize;\nuniform float u_penSize;\nuniform float u_lineLength;\n\nvarying vec2 v_texCoord;\n\n// Add this to divisors to prevent division by 0, which results in NaNs propagating through calculations.\n// Smaller values can cause problems on some mobile devices.\nconst float epsilon = 1e-3;\n\nvoid main() {\n  // Calculate a rotated (\"tight\") bounding box around the two pen points.\n  // Yes, we're doing this 6 times (once per vertex), but on actual GPU hardware,\n  // it's still faster than doing it in JS combined with the cost of uniformMatrix4fv.\n\n  // Expand line bounds by sqrt(2) / 2 each side-- this ensures that all antialiased pixels\n  // fall within the quad, even at a 45-degree diagonal\n  vec2 position = a_position;\n  float expandedRadius = (u_penSize * 0.5) + 1.4142135623730951;\n\n  // The X coordinate increases along the length of the line. It's 0 at the center of the origin point\n  // and is in pixel-space (so at n pixels along the line, its value is n).\n  v_texCoord.x = mix(0.0, u_lineLength + (expandedRadius * 2.0), a_position.x) - expandedRadius;\n  // The Y coordinate is perpendicular to the line. It's also in pixel-space.\n  v_texCoord.y = ((a_position.y - 0.5) * expandedRadius) + 0.5;\n\n  position.x *= u_lineLength + (2.0 * expandedRadius);\n  position.y *= 2.0 * expandedRadius;\n\n  // 1. Center around first pen point\n  position -= expandedRadius;\n\n  // 2. Rotate quad to line angle\n  vec2 pointDiff = u_penPoints.zw;\n  // Ensure line has a nonzero length so it's rendered properly\n  // As long as either component is nonzero, the line length will be nonzero\n  // If the line is zero-length, give it a bit of horizontal length\n  pointDiff.x = (abs(pointDiff.x) < epsilon && abs(pointDiff.y) < epsilon) ? epsilon : pointDiff.x;\n  // The 'normalized' vector holds rotational values equivalent to sine/cosine\n  // We're applying the standard rotation matrix formula to the position to rotate the quad to the line angle\n  // pointDiff can hold large values so we must divide by u_lineLength instead of calling GLSL's normalize function:\n  // https://asawicki.info/news_1596_watch_out_for_reduced_precision_normalizelength_in_opengl_es\n  vec2 normalized = pointDiff / max(u_lineLength, epsilon);\n  position = mat2(normalized.x, normalized.y, -normalized.y, normalized.x) * position;\n\n  // 3. Translate quad\n  position += u_penPoints.xy;\n\n  // 4. Apply view transform\n  position *= 2.0 / u_penSkinSize;\n  gl_Position = vec4(position, 0, 1);\n}\n`;\n\nPenLineShader.fragment = `\nprecision mediump float;\n\nuniform sampler2D u_texture;\nuniform vec4 u_penPoints;\nuniform vec4 u_penColor;\nuniform float u_penSize;\nuniform float u_lineLength;\nvarying vec2 v_texCoord;\n\nvoid main() {\n  // Maaaaagic antialiased-line-with-round-caps shader.\n\n\t// \"along-the-lineness\". This increases parallel to the line.\n\t// It goes from negative before the start point, to 0.5 through the start to the end, then ramps up again\n\t// past the end point.\n\tfloat d = ((v_texCoord.x - clamp(v_texCoord.x, 0.0, u_lineLength)) * 0.5) + 0.5;\n\n\t// Distance from (0.5, 0.5) to (d, the perpendicular coordinate). When we're in the middle of the line,\n\t// d will be 0.5, so the distance will be 0 at points close to the line and will grow at points further from it.\n\t// For the \"caps\", d will ramp down/up, giving us rounding.\n\t// See https://www.youtube.com/watch?v=PMltMdi1Wzg for a rough outline of the technique used to round the lines.\n\tfloat line = distance(vec2(0.5), vec2(d, v_texCoord.y)) * 2.0;\n\t// Expand out the line by its thickness.\n\tline -= ((u_penSize - 1.0) * 0.5);\n\t// Because \"distance to the center of the line\" decreases the closer we get to the line, but we want more opacity\n\t// the closer we are to the line, invert it.\n\tgl_FragColor = u_penColor * clamp(1.0 - line, 0.0, 1.0);\n}\n`;\n\nexport { SpriteShader, PenLineShader };\n","import { SpriteShader, PenLineShader } from \"./Shaders.ts\";\nimport { effectNames, effectBitmasks } from \"./effectInfo.ts\";\n\n// Everything contained in a shader. It contains both the program, and the locations of the shader inputs.\nclass Shader {\n  constructor(gl, program) {\n    this.gl = gl;\n    this.program = program;\n    this.uniforms = {};\n    this.attribs = {};\n\n    // In order to pass a value into a shader as an attribute or uniform, you need to know its location.\n    // This maps the names of attributes and uniforms to their locations, accessible via the `uniforms` and `attribs`\n    // properties.\n    const numActiveUniforms = gl.getProgramParameter(\n      program,\n      gl.ACTIVE_UNIFORMS\n    );\n    for (let i = 0; i < numActiveUniforms; i++) {\n      const { name } = gl.getActiveUniform(program, i);\n      this.uniforms[name] = gl.getUniformLocation(program, name);\n    }\n\n    const numActiveAttributes = gl.getProgramParameter(\n      program,\n      gl.ACTIVE_ATTRIBUTES\n    );\n    for (let i = 0; i < numActiveAttributes; i++) {\n      const { name } = gl.getActiveAttrib(program, i);\n      this.attribs[name] = gl.getAttribLocation(program, name);\n    }\n  }\n}\n\nclass ShaderManager {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.gl = renderer.gl;\n\n    // We compile shaders on-demand. Create one shader cache per draw mode.\n    this._shaderCache = {};\n    for (const drawMode of Object.keys(ShaderManager.DrawModes)) {\n      this._shaderCache[drawMode] = new Map();\n    }\n  }\n\n  // Creates and compiles a vertex or fragment shader from the given source code.\n  _createShader(source, type) {\n    const gl = this.gl;\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      const info = gl.getShaderInfoLog(shader);\n      throw \"Could not compile WebGL program. \\n\" + info;\n    }\n\n    return shader;\n  }\n\n  getShader(drawMode, effectBitmask = 0) {\n    const gl = this.gl;\n    // Each combination of enabled effects is compiled to a different shader, with only the needed effect code.\n    // Check if we've already compiled the shader with this set of enabled effects.\n    const shaderMap = this._shaderCache[drawMode];\n    if (shaderMap.has(effectBitmask)) {\n      return shaderMap.get(effectBitmask);\n    } else {\n      let shaderCode;\n      switch (drawMode) {\n        case ShaderManager.DrawModes.PEN_LINE: {\n          shaderCode = PenLineShader;\n          break;\n        }\n        default: {\n          shaderCode = SpriteShader;\n          break;\n        }\n      }\n\n      // Use #define statements for conditional compilation in shader code.\n      let define = `#define DRAW_MODE_${drawMode}\\n`;\n\n      // Add #defines for each enabled effect.\n      for (let i = 0; i < effectNames.length; i++) {\n        const effectName = effectNames[i];\n        if ((effectBitmask & effectBitmasks[effectName]) !== 0) {\n          define += `#define EFFECT_${effectName}\\n`;\n        }\n      }\n\n      const vertShader = this._createShader(\n        define + shaderCode.vertex,\n        gl.VERTEX_SHADER\n      );\n      const fragShader = this._createShader(\n        define + shaderCode.fragment,\n        gl.FRAGMENT_SHADER\n      );\n\n      // Combine the vertex and fragment shaders into a single GL program.\n      const program = gl.createProgram();\n      gl.attachShader(program, vertShader);\n      gl.attachShader(program, fragShader);\n      gl.linkProgram(program);\n\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        const info = gl.getProgramInfoLog(program);\n        throw new Error(\"Could not compile WebGL program. \\n\" + info);\n      }\n\n      const shader = new Shader(gl, program);\n      shaderMap.set(effectBitmask, shader);\n      return shader;\n    }\n  }\n}\n\nShaderManager.DrawModes = {\n  // Used for drawing sprites normally\n  DEFAULT: \"DEFAULT\",\n  // Used for \"touching\" tests. Discards transparent pixels.\n  SILHOUETTE: \"SILHOUETTE\",\n  // Used for \"color is touching color\" tests. Only renders sprite colors which are close to the color passed in, and\n  // discards all pixels of a different color.\n  COLOR_MASK: \"COLOR_MASK\",\n  // Used for picking the topmost sprite and identifying which one it is.\n  // Assigns a color to each sprite.\n  SPRITE_ID: \"SPRITE_ID\",\n  // Used for drawing pen lines.\n  PEN_LINE: \"PEN_LINE\"\n};\n\nexport default ShaderManager;\n","import Skin from \"./Skin.ts\";\nimport ShaderManager from \"./ShaderManager.ts\";\n\nexport default class PenSkin extends Skin {\n  constructor(renderer, width, height) {\n    super(renderer);\n    this.width = width;\n    this.height = height;\n\n    const framebufferInfo = renderer._createFramebufferInfo(\n      width,\n      height,\n      this.gl.NEAREST\n    );\n    this._framebufferInfo = framebufferInfo;\n\n    this._lastPenState = {\n      size: 0,\n      color: [0, 0, 0, 0]\n    };\n\n    this.clear();\n  }\n\n  destroy() {\n    const gl = this.gl;\n    gl.deleteTexture(this._framebufferInfo.texture);\n    gl.deleteFramebuffer(this._framebufferInfo.framebuffer);\n  }\n\n  getTexture() {\n    return this._framebufferInfo.texture;\n  }\n\n  penLine(pt1, pt2, color, size) {\n    const renderer = this.renderer;\n    renderer._setFramebuffer(this._framebufferInfo);\n\n    const shader = renderer._shaderManager.getShader(\n      ShaderManager.DrawModes.PEN_LINE\n    );\n\n    const gl = this.gl;\n\n    // Set the shader, and check if it actually changed.\n    const shaderChanged = renderer._setShader(shader);\n\n    // These uniforms only need to be set if the shader actually changed.\n    if (shaderChanged) {\n      gl.uniform2f(shader.uniforms.u_penSkinSize, this.width, this.height);\n    }\n\n    // Only set the pen color if it changed or the shader changed.\n    const penColor = color.toRGBANormalized();\n    const oldColor = this._lastPenState.color;\n    if (\n      shaderChanged ||\n      penColor[0] !== oldColor[0] ||\n      penColor[1] !== oldColor[1] ||\n      penColor[2] !== oldColor[2] ||\n      penColor[3] !== oldColor[3]\n    ) {\n      this._lastPenState.color = penColor;\n      gl.uniform4f(\n        shader.uniforms.u_penColor,\n        penColor[0] * penColor[3],\n        penColor[1] * penColor[3],\n        penColor[2] * penColor[3],\n        penColor[3]\n      );\n    }\n\n    // Only set the pen size if it changed or the shader changed.\n    if (shaderChanged || this._lastPenState.size !== size) {\n      this._lastPenState.size = size;\n      gl.uniform1f(shader.uniforms.u_penSize, size);\n    }\n\n    const lineDiffX = pt2.x - pt1.x;\n    const lineDiffY = pt2.y - pt1.y;\n\n    // Offset pen lines of size 1 and 3 so they lie on integer coords.\n    // https://github.com/LLK/scratch-render/blob/791b2750cef140e714b002fd275b5f8434e6df9b/src/PenSkin.ts#L167-L170\n    const offset = size === 1 || size === 3 ? 0.5 : 0;\n\n    gl.uniform4f(\n      shader.uniforms.u_penPoints,\n      pt1.x + offset,\n      pt1.y + offset,\n      lineDiffX,\n      lineDiffY\n    );\n\n    // Fun fact: Doing this calculation in the shader has the potential to overflow the floating-point range.\n    // 'mediump' precision is only required to have a range up to 2^14 (16384), so any lines longer than 2^7 (128)\n    // can overflow that, because you're squaring the operands, and they could end up as \"infinity\".\n    // Even GLSL's `length` function won't save us here:\n    // https://asawicki.info/news_1596_watch_out_for_reduced_precision_normalizelength_in_opengl_es\n    const lineLength = Math.sqrt(lineDiffX * lineDiffX + lineDiffY * lineDiffY);\n    gl.uniform1f(shader.uniforms.u_lineLength, lineLength);\n\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n  }\n\n  clear() {\n    this.renderer._setFramebuffer(this._framebufferInfo);\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n  }\n}\n","import Skin from \"./Skin.ts\";\n\nconst bubbleStyle = {\n  maxLineWidth: 170,\n  minWidth: 50,\n  strokeWidth: 4,\n  padding: 12,\n  tailHeight: 12\n};\n\n// TODO: multiline speech bubbles\nexport default class SpeechBubbleSkin extends Skin {\n  constructor(renderer, bubble) {\n    super(renderer);\n\n    this._canvas = document.createElement(\"canvas\");\n    this._texture = this._makeTexture(null, this.gl.LINEAR);\n    this._bubble = bubble;\n    this._flipped = false;\n    this._rendered = false;\n    this._renderedScale = 0;\n\n    this.width = 0;\n    this.height = 0;\n    this.offsetX = -bubbleStyle.strokeWidth / 2;\n    this.offsetY = this.offsetX + bubbleStyle.tailHeight;\n\n    this._renderBubble(this._bubble);\n  }\n\n  // To ensure proper text measurement and drawing, it's necessary to restyle the canvas after resizing it.\n  _restyleCanvas() {\n    const ctx = this._canvas.getContext(\"2d\");\n    ctx.font = \"16px sans-serif\";\n    ctx.textBaseline = \"hanging\";\n  }\n\n  set flipped(flipped) {\n    this._flipped = flipped;\n    this._rendered = false;\n  }\n\n  _renderBubble(bubble, scale) {\n    const canvas = this._canvas;\n    const ctx = canvas.getContext(\"2d\");\n\n    const renderBubbleBackground = (x, y, w, h, r, style) => {\n      if (r > w / 2) r = w / 2;\n      if (r > h / 2) r = h / 2;\n      if (r < 0) return;\n\n      ctx.beginPath();\n      ctx.moveTo(x + r, y);\n      ctx.arcTo(x + w, y, x + w, y + h, r);\n      ctx.arcTo(x + w, y + h, x + r, y + h, r);\n      if (style === \"say\") {\n        ctx.lineTo(Math.min(x + 3 * r, x + w - r), y + h);\n        ctx.lineTo(x + r / 2, y + h + r);\n        ctx.lineTo(x + r, y + h);\n      } else if (style === \"think\") {\n        ctx.ellipse(x + r * 2.25, y + h, (r * 3) / 4, r / 2, 0, 0, Math.PI);\n      }\n      ctx.arcTo(x, y + h, x, y, r);\n      ctx.arcTo(x, y, x + w, y, r);\n      ctx.closePath();\n      ctx.stroke();\n      ctx.fill();\n\n      if (style === \"think\") {\n        ctx.beginPath();\n        ctx.ellipse(\n          x + r,\n          y + h + (r * 3) / 4,\n          r / 3,\n          r / 3,\n          0,\n          0,\n          2 * Math.PI\n        );\n        ctx.stroke();\n        ctx.fill();\n      }\n    };\n\n    this._restyleCanvas();\n\n    const { text, style } = bubble;\n    const textWidth = ctx.measureText(text).width;\n\n    const maxWidth = bubbleStyle.maxLineWidth;\n    const padding = bubbleStyle.padding;\n\n    const width = Math.ceil(Math.min(textWidth, maxWidth) + 2 * padding);\n    const height = 10 + 2 * padding;\n\n    this.width = width + bubbleStyle.strokeWidth;\n    this.height = height + bubbleStyle.tailHeight + bubbleStyle.strokeWidth;\n\n    canvas.width = this.width * scale;\n    canvas.height = this.height * scale;\n\n    this._restyleCanvas();\n\n    const x = bubbleStyle.strokeWidth / 2;\n    const y = x;\n\n    ctx.setTransform(scale, 0, 0, scale, 0, 0);\n\n    ctx.fillStyle = \"#fff\";\n    ctx.strokeStyle = \"#ccc\";\n    ctx.lineWidth = bubbleStyle.strokeWidth;\n    ctx.save();\n    if (this._flipped) {\n      ctx.scale(-1, 1);\n      ctx.translate(-this.width, 0);\n    }\n    renderBubbleBackground(x, y, width, height, bubbleStyle.tailHeight, style);\n    ctx.restore();\n\n    ctx.fillStyle = \"#444\";\n    ctx.fillText(text, x + padding, y + padding, maxWidth);\n\n    this._rendered = true;\n    this._renderedScale = scale;\n  }\n\n  getTexture(scale) {\n    if (!this._rendered || this._renderedScale !== scale) {\n      this._renderBubble(this._bubble, scale);\n      const gl = this.gl;\n      gl.bindTexture(gl.TEXTURE_2D, this._texture);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl.RGBA,\n        gl.RGBA,\n        gl.UNSIGNED_BYTE,\n        this._canvas\n      );\n    }\n\n    return this._texture;\n  }\n\n  destroy() {\n    this.gl.deleteTexture(this._texture);\n  }\n}\n","import Skin from \"./Skin.ts\";\n\n// This means that the smallest mipmap will be 1/(2**4)th the size of the sprite's \"100%\" size.\nconst MIPMAP_OFFSET = 4;\n\nexport default class VectorSkin extends Skin {\n  constructor(renderer, image) {\n    super(renderer);\n\n    this._image = image;\n    this._canvas = document.createElement(\"canvas\");\n\n    this._imageDataMipLevel = 0;\n    this._imageData = null;\n\n    this._maxTextureSize = renderer.gl.getParameter(\n      renderer.gl.MAX_TEXTURE_SIZE\n    );\n\n    this._setSizeFromImage(image);\n\n    this._mipmaps = new Map();\n  }\n\n  static mipLevelForScale(scale) {\n    return Math.max(Math.ceil(Math.log2(scale)) + MIPMAP_OFFSET, 0);\n  }\n\n  getImageData(scale) {\n    if (!this._image.complete) return null;\n\n    // Round off the scale of the image data drawn to a given power-of-two mip level.\n    const mipLevel = VectorSkin.mipLevelForScale(scale);\n    if (!this._imageData || this._imageDataMipLevel !== mipLevel) {\n      const canvas = this._drawSvgToCanvas(mipLevel);\n      if (canvas === null) return null;\n\n      // Cache image data so we can reuse it\n      this._imageData = canvas\n        .getContext(\"2d\")\n        .getImageData(0, 0, canvas.width, canvas.height);\n      this._imageDataMipLevel = mipLevel;\n    }\n\n    return this._imageData;\n  }\n\n  _drawSvgToCanvas(mipLevel) {\n    const scale = 2 ** (mipLevel - MIPMAP_OFFSET);\n\n    const image = this._image;\n    let width = image.naturalWidth * scale;\n    let height = image.naturalHeight * scale;\n\n    width = Math.round(Math.min(width, this._maxTextureSize));\n    height = Math.round(Math.min(height, this._maxTextureSize));\n\n    // Prevent IndexSizeErrors if the image is too small to render\n    if (width === 0 || height === 0) {\n      return null;\n    }\n\n    // Instead of uploading the image to WebGL as a texture, render the image to a canvas and upload the canvas.\n    const canvas = this._canvas;\n    const ctx = canvas.getContext(\"2d\");\n\n    canvas.width = width;\n    canvas.height = height;\n\n    ctx.drawImage(image, 0, 0, width, height);\n    return this._canvas;\n  }\n\n  // TODO: handle proper subpixel positioning when SVG viewbox has non-integer coordinates\n  // This will require rethinking costume + project loading probably\n  _createMipmap(mipLevel) {\n    // Instead of uploading the image to WebGL as a texture, render the image to a canvas and upload the canvas.\n    const canvas = this._drawSvgToCanvas(mipLevel);\n    this._mipmaps.set(\n      mipLevel,\n      // Use linear (i.e. smooth) texture filtering for vectors\n      // If the image is 0x0, we return null. Check for that.\n      canvas === null ? null : this._makeTexture(canvas, this.gl.LINEAR)\n    );\n  }\n\n  getTexture(scale) {\n    if (!this._image.complete) return null;\n\n    // Because WebGL doesn't support vector graphics, substitute a bunch of bitmaps.\n    // This skin contains several renderings of its image at different scales.\n    // We render the SVG at 0.5x scale, 1x scale, 2x scale, 4x scale, etc. and store those as textures,\n    // so we can use the properly-sized texture for whatever scale we're currently rendering at.\n    // Math.ceil(Math.log2(scale)) means we use the \"2x\" texture at 1x-2x scale, the \"4x\" texture at 2x-4x scale, etc.\n    // This means that one texture pixel will always be between 0.5x and 1x the size of one rendered pixel,\n    // but never bigger than one rendered pixel--this prevents blurriness from blowing up the texture too much.\n    const mipLevel = VectorSkin.mipLevelForScale(scale);\n    if (!this._mipmaps.has(mipLevel)) this._createMipmap(mipLevel);\n\n    return this._mipmaps.get(mipLevel);\n  }\n\n  destroy() {\n    for (const mip of this._mipmaps.values()) {\n      this.gl.deleteTexture(mip);\n    }\n  }\n}\n","export default class Costume {\n  constructor(name, url, center = { x: 0, y: 0 }) {\n    this.name = name;\n    this.url = url;\n\n    this.img = new Image();\n    this.img.crossOrigin = \"Anonymous\";\n    this.img.src = this.url;\n\n    // TODO: this is super janky, but fixing this fully requires restructuring costume loading\n    this.isBitmap = !this.url.match(/\\.svg/);\n    this.resolution = this.isBitmap ? 2 : 1;\n\n    this.center = center;\n  }\n\n  get width() {\n    return this.img.naturalWidth;\n  }\n\n  get height() {\n    return this.img.naturalHeight;\n  }\n}\n","import Matrix from \"./renderer/Matrix.ts\";\nimport Drawable from \"./renderer/Drawable.ts\";\nimport BitmapSkin from \"./renderer/BitmapSkin.ts\";\nimport PenSkin from \"./renderer/PenSkin.ts\";\nimport SpeechBubbleSkin from \"./renderer/SpeechBubbleSkin.ts\";\nimport VectorSkin from \"./renderer/VectorSkin.ts\";\nimport Rectangle from \"./renderer/Rectangle.ts\";\nimport ShaderManager from \"./renderer/ShaderManager.ts\";\nimport { effectNames, effectBitmasks } from \"./renderer/effectInfo.ts\";\n\nimport Costume from \"./Costume.ts\";\n\n// Rectangle used for checking collision bounds.\n// Rather than create a new one each time, we can just reuse this one.\nconst __collisionBox = new Rectangle();\n\n// Convert a sprite ID/index number to a 24-bit color. The lowest 8 bits are\n// stored in the blue channel, then green, then red.\n// RGB [0, 0, 0] is reserved for \"no sprite here\".\n// This allows for up to 2^24 - 2 different sprites to be rendered at once.\nconst idToColor = id => [\n  (((id + 1) >> 16) & 0xff) / 255,\n  (((id + 1) >> 8) & 0xff) / 255,\n  ((id + 1) & 0xff) / 255\n];\n\n// Convert a 24-bit color back into a sprite ID/index number.\n// -1 means \"no sprite here\".\nconst colorToId = ([r, g, b]) => ((r << 16) | (g << 8) | b) - 1;\n\nexport default class Renderer {\n  constructor(project, renderTarget) {\n    const w = project.stage.width;\n    const h = project.stage.height;\n    this.project = project;\n    this.stage = this.createStage(w, h);\n    this.gl = this.stage.getContext(\"webgl\", { antialias: false });\n\n    if (renderTarget) {\n      this.setRenderTarget(renderTarget);\n    } else {\n      this.renderTarget = null;\n    }\n\n    this._shaderManager = new ShaderManager(this);\n    this._drawables = new WeakMap();\n    this._skins = new WeakMap();\n\n    this._currentShader = null;\n    this._currentFramebuffer = null;\n    this._screenSpaceScale = 1;\n\n    // Initialize a bunch of WebGL state\n    const gl = this.gl;\n\n    // Use premultiplied alpha for proper color blending.\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\n    // Initialize vertex buffer. This will draw one 2D quadrilateral.\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n    // These are 6 points which make up 2 triangles which make up 1 quad/rectangle.\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      // Prettier mangles the formatting here but every 2 array values make one (x, y) pair\n      // and every 6 values make one triangle\n      new Float32Array([0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]),\n      gl.STATIC_DRAW\n    );\n\n    // Set the active texture unit to 0.\n    gl.activeTexture(gl.TEXTURE0);\n\n    this._penSkin = new PenSkin(this, w, h);\n\n    // This framebuffer is where sprites are drawn for e.g. \"touching\" checks.\n    this._collisionBuffer = this._createFramebufferInfo(\n      w,\n      h,\n      gl.NEAREST,\n      true // stencil\n    );\n  }\n\n  // Retrieve a given object (e.g. costume or speech bubble)'s skin. If it doesn't exist, make one.\n  _getSkin(obj) {\n    if (this._skins.has(obj)) {\n      return this._skins.get(obj);\n    }\n\n    let skin;\n\n    if (obj instanceof Costume) {\n      if (obj.isBitmap) {\n        skin = new BitmapSkin(this, obj.img);\n      } else {\n        skin = new VectorSkin(this, obj.img);\n      }\n    } else {\n      // If it's not a costume, assume it's a speech bubble.\n      skin = new SpeechBubbleSkin(this, obj);\n    }\n    this._skins.set(obj, skin);\n    return skin;\n  }\n\n  // Retrieve the renderer-specific data object for a given sprite or clone. If it doesn't exist, make one.\n  _getDrawable(sprite) {\n    if (this._drawables.has(sprite)) {\n      return this._drawables.get(sprite);\n    }\n    const drawable = new Drawable(this, sprite);\n    this._drawables.set(sprite, drawable);\n    return drawable;\n  }\n\n  // Create a framebuffer info object, which contains the following:\n  // * The framebuffer itself.\n  // * The texture backing the framebuffer.\n  // * The resolution (width and height) of the framebuffer.\n  _createFramebufferInfo(width, height, filtering, stencil = false) {\n    // Create an empty texture with this skin's dimensions.\n    const gl = this.gl;\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filtering);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filtering);\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      width,\n      height,\n      0,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      null\n    );\n\n    // Create a framebuffer backed by said texture. This means we can draw onto the framebuffer,\n    // and the results appear in the texture.\n    const framebufferInfo = {\n      texture,\n      width,\n      height,\n      framebuffer: gl.createFramebuffer()\n    };\n    this._setFramebuffer(framebufferInfo);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n\n    // The depth buffer is unnecessary, but WebGL only guarantees\n    // that certain combinations of framebuffer attachments will work, and \"stencil but no depth\" is not among them.\n    if (stencil) {\n      const renderbuffer = gl.createRenderbuffer();\n      gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\n      gl.framebufferRenderbuffer(\n        gl.FRAMEBUFFER,\n        gl.DEPTH_STENCIL_ATTACHMENT,\n        gl.RENDERBUFFER,\n        renderbuffer\n      );\n    }\n\n    return framebufferInfo;\n  }\n\n  _setShader(shader) {\n    if (shader !== this._currentShader) {\n      const gl = this.gl;\n      gl.useProgram(shader.program);\n\n      // These attributes and uniforms don't ever change, but must be set whenever a new shader program is used.\n\n      const attribLocation = shader.attribs.a_position;\n      gl.enableVertexAttribArray(attribLocation);\n      // Bind the 'a_position' vertex attribute to the current contents of `gl.ARRAY_BUFFER`, which in this case\n      // is a quadrilateral (as buffered earlier).\n      gl.vertexAttribPointer(\n        attribLocation,\n        2, // every 2 array elements make one vertex.\n        gl.FLOAT, // data type\n        false, // normalized\n        0, // stride (space between attributes)\n        0 // offset (index of the first attribute to start from)\n      );\n\n      this._currentShader = shader;\n      this._updateStageSize();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  _setFramebuffer(framebufferInfo) {\n    if (framebufferInfo !== this._currentFramebuffer) {\n      this._currentFramebuffer = framebufferInfo;\n      if (framebufferInfo === null) {\n        // The \"null\" framebuffer means the drawing buffer which we're displaying to the screen.\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n        this._updateStageSize();\n      } else {\n        this.gl.bindFramebuffer(\n          this.gl.FRAMEBUFFER,\n          framebufferInfo.framebuffer\n        );\n        // Make sure to update the drawing viewport to the current framebuffer size.\n        this.gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);\n      }\n    }\n  }\n\n  setRenderTarget(renderTarget) {\n    if (typeof renderTarget === \"string\") {\n      renderTarget = document.querySelector(renderTarget);\n    }\n    this.renderTarget = renderTarget;\n    this.renderTarget.classList.add(\"leopard__project\");\n    this.renderTarget.style.width = `${this.project.stage.width}px`;\n    this.renderTarget.style.height = `${this.project.stage.height}px`;\n\n    this.renderTarget.append(this.stage);\n  }\n\n  // Handles rendering of all layers (including stage, pen layer, sprites, and all clones) in proper order.\n  _renderLayers(layers, options = {}) {\n    options = Object.assign(\n      {\n        drawMode: ShaderManager.DrawModes.DEFAULT,\n        renderSpeechBubbles: true\n      },\n      options\n    );\n\n    // If we're given a list of layers, filter by that.\n    // If we're given a filter function in the options, filter by that too.\n    // If we're given both, then only include layers which match both.\n    const shouldRestrictLayers = layers instanceof Set;\n    const shouldFilterLayers = typeof options.filter === \"function\";\n    const shouldIncludeLayer = layer =>\n      !(\n        (shouldRestrictLayers && !layers.has(layer)) ||\n        (shouldFilterLayers && !options.filter(layer))\n      );\n\n    // Stage\n    if (shouldIncludeLayer(this.project.stage)) {\n      this.renderSprite(this.project.stage, options);\n    }\n\n    // Pen layer\n    if (shouldIncludeLayer(this._penSkin)) {\n      const penMatrix = Matrix.create();\n      Matrix.scale(\n        penMatrix,\n        penMatrix,\n        this._penSkin.width,\n        -this._penSkin.height\n      );\n      Matrix.translate(penMatrix, penMatrix, -0.5, -0.5);\n\n      this._renderSkin(\n        this._penSkin,\n        options.drawMode,\n        penMatrix,\n        1 /* scale */\n      );\n    }\n\n    // Sprites + clones\n    for (const sprite of this.project.spritesAndClones) {\n      // Stage doesn't have \"visible\" defined, so check if it's strictly false\n      if (shouldIncludeLayer(sprite) && sprite.visible !== false) {\n        this.renderSprite(sprite, options);\n      }\n    }\n  }\n\n  _updateStageSize() {\n    if (this._currentShader) {\n      // The shader is passed things in \"Scratch-space\" (-240, 240) and (-180, 180).\n      // This tells it those dimensions so it can convert them to OpenGL \"clip-space\" (-1, 1).\n      this.gl.uniform2f(\n        this._currentShader.uniforms.u_stageSize,\n        this.project.stage.width,\n        this.project.stage.height\n      );\n    }\n\n    if (this._currentFramebuffer === null) {\n      this.gl.viewport(\n        0,\n        0,\n        this.gl.drawingBufferWidth,\n        this.gl.drawingBufferHeight\n      );\n    }\n  }\n\n  // Keep the canvas size in sync with the CSS size.\n  _resize() {\n    const stageSize = this.stage.getBoundingClientRect();\n    const ratio = window.devicePixelRatio;\n    const adjustedWidth = Math.round(stageSize.width * ratio);\n    const adjustedHeight = Math.round(stageSize.height * ratio);\n    if (\n      this.stage.width !== adjustedWidth ||\n      this.stage.height !== adjustedHeight\n    ) {\n      this.stage.width = adjustedWidth;\n      this.stage.height = adjustedHeight;\n      this._screenSpaceScale = Math.max(\n        adjustedWidth / this.project.stage.width,\n        adjustedHeight / this.project.stage.height\n      );\n\n      this._updateStageSize();\n    }\n  }\n\n  update() {\n    this._resize();\n\n    // Draw to the screen, not to a framebuffer.\n    this._setFramebuffer(null);\n\n    // Clear to opaque white.\n    const gl = this.gl;\n    gl.clearColor(1, 1, 1, 1);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    this._renderLayers();\n  }\n\n  createStage(w, h) {\n    const stage = document.createElement(\"canvas\");\n    stage.width = w;\n    stage.height = h;\n\n    // Size canvas to parent container\n    stage.style.width = stage.style.height = \"100%\";\n\n    // If the container width is a non-integer size, don't blur the canvas.\n    // Chrome:\n    stage.style.imageRendering = \"pixelated\";\n    // Firefox:\n    stage.style.imageRendering = \"crisp-edges\";\n    // Safari + Opera:\n    stage.style.imageRendering = \"-webkit-optimize-contrast\";\n\n    return stage;\n  }\n\n  // Calculate the transform matrix for a speech bubble attached to a sprite.\n  _calculateSpeechBubbleMatrix(spr, speechBubbleSkin) {\n    const sprBounds = this.getBoundingBox(spr);\n    let x;\n    if (\n      speechBubbleSkin.width + sprBounds.right >\n      this.project.stage.width / 2\n    ) {\n      x = sprBounds.left - speechBubbleSkin.width;\n      speechBubbleSkin.flipped = true;\n    } else {\n      x = sprBounds.right;\n      speechBubbleSkin.flipped = false;\n    }\n    x = Math.round(x - speechBubbleSkin.offsetX);\n    const y = Math.round(sprBounds.top - speechBubbleSkin.offsetY);\n\n    const m = Matrix.create();\n    Matrix.translate(m, m, x, y);\n    Matrix.scale(m, m, speechBubbleSkin.width, speechBubbleSkin.height);\n\n    return m;\n  }\n\n  _renderSkin(\n    skin,\n    drawMode,\n    matrix,\n    scale,\n    effects,\n    effectMask,\n    colorMask,\n    spriteColorId\n  ) {\n    const gl = this.gl;\n\n    const skinTexture = skin.getTexture(scale * this._screenSpaceScale);\n    // Skip rendering the skin if it has no texture.\n    if (!skinTexture) return;\n\n    let effectBitmask = effects ? effects._bitmask : 0;\n    if (typeof effectMask === \"number\") effectBitmask &= effectMask;\n    const shader = this._shaderManager.getShader(drawMode, effectBitmask);\n    this._setShader(shader);\n    gl.uniformMatrix3fv(shader.uniforms.u_transform, false, matrix);\n\n    if (effectBitmask !== 0) {\n      for (const effect of effectNames) {\n        const effectVal = effects._effectValues[effect];\n        if (effectVal !== 0)\n          gl.uniform1f(shader.uniforms[`u_${effect}`], effectVal);\n      }\n\n      // Pixelate effect needs the skin size\n      if (effects._effectValues.pixelate !== 0)\n        gl.uniform2f(shader.uniforms.u_skinSize, skin.width, skin.height);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, skinTexture);\n    // All textures are bound to texture unit 0, so that's where the texture sampler should point\n    gl.uniform1i(shader.uniforms.u_texture, 0);\n\n    // Enable color masking mode if set\n    if (Array.isArray(colorMask))\n      this.gl.uniform4fv(this._currentShader.uniforms.u_colorMask, colorMask);\n\n    // Used for mapping drawn sprites back to their indices in a list.\n    // By looking at the color of a given pixel, we can tell which sprite is\n    // the topmost one drawn on that pixel.\n    if (drawMode === ShaderManager.DrawModes.SPRITE_ID && typeof spriteColorId === \"number\") {\n      this.gl.uniform3fv(\n        this._currentShader.uniforms.u_spriteId,\n        idToColor(spriteColorId)\n      );\n    }\n\n    // Actually draw the skin\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n  }\n\n  renderSprite(sprite, options) {\n    const spriteScale = Object.prototype.hasOwnProperty.call(sprite, \"size\")\n      ? sprite.size / 100\n      : 1;\n\n    this._renderSkin(\n      this._getSkin(sprite.costume),\n      options.drawMode,\n      this._getDrawable(sprite).getMatrix(),\n      spriteScale,\n      sprite.effects,\n      options.effectMask,\n      options.colorMask,\n      options.spriteColorId ? options.spriteColorId(sprite) : undefined\n    );\n\n    if (\n      options.renderSpeechBubbles &&\n      sprite._speechBubble &&\n      sprite._speechBubble.text !== \"\"\n    ) {\n      const speechBubbleSkin = this._getSkin(sprite._speechBubble);\n\n      this._renderSkin(\n        speechBubbleSkin,\n        options.drawMode,\n        this._calculateSpeechBubbleMatrix(sprite, speechBubbleSkin),\n        1 /* spriteScale */\n      );\n    }\n  }\n\n  getTightBoundingBox(sprite) {\n    return this._getDrawable(sprite).getTightBoundingBox();\n  }\n\n  getBoundingBox(sprite) {\n    return Rectangle.fromMatrix(this._getDrawable(sprite).getMatrix());\n  }\n\n  // Mask drawing in to only areas where this sprite is opaque.\n  _stencilSprite(spr, colorMask) {\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n\n    // Enable stenciling. This means that:\n    // 1. Only pixels which pass the \"stencil test\" will be drawn.\n    // 2. Anything rendered will also draw to the stencil buffer.\n    gl.enable(gl.STENCIL_TEST);\n    // Pass the stencil test regardless of what's in the stencil buffer.\n    // Note that pixels which the shader has discarded will still fail the stencil test.\n    // 1 is the reference value which we use in the next line.\n    gl.stencilFunc(gl.ALWAYS, 1, 1);\n    // If the stencil test passes (in this case, if the shader hasn't discarded the pixel),\n    // draw a 1 to that pixel in the stencil buffer, replacing whatever's already there.\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n    // Don't draw to the color buffer. Only to the stencil buffer.\n    gl.colorMask(false, false, false, false);\n    // Draw the sprite in the \"silhouette\" mode, which discards transparent pixels.\n    // This, along with the above line, has the effect of not drawing anything to the color buffer, but\n    // creating a \"mask\" in the stencil buffer that masks out all pixels where this sprite is transparent.\n\n    const opts = {\n      drawMode: ShaderManager.DrawModes.SILHOUETTE,\n      renderSpeechBubbles: false,\n      // Ignore ghost effect\n      effectMask: ~effectBitmasks.ghost\n    };\n\n    // If we mask in the color (for e.g. \"color is touching color\"),\n    // we need to pass that in as a uniform as well.\n    if (colorMask) {\n      opts.colorMask = colorMask.toRGBANormalized();\n      opts.drawMode = ShaderManager.DrawModes.COLOR_MASK;\n    }\n    this._renderLayers(new Set([spr]), opts);\n\n    // Pass the stencil test if the stencil buffer value equals 1 (e.g. the pixel got masked in above).\n    gl.stencilFunc(gl.EQUAL, 1, 1);\n    // Keep the current stencil buffer values no matter what.\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n    // We can draw to the color buffer again. Note that only pixels which pass the stencil test are drawn.\n    gl.colorMask(true, true, true, true);\n  }\n\n  checkSpriteCollision(spr, targets, fast, sprColor) {\n    if (!spr.visible) return false;\n    if (!(targets instanceof Set)) {\n      if (targets instanceof Array) {\n        targets = new Set(targets);\n      } else {\n        targets = new Set([targets]);\n      }\n    }\n\n    const sprBox = Rectangle.copy(\n      this.getBoundingBox(spr),\n      __collisionBox\n    ).snapToInt();\n\n    // This is an \"impossible rectangle\"-- its left bound is infinitely far to the right,\n    // its right bound is infinitely to the left, and so on. Its size is effectively -Infinity.\n    // Its only purpose is to be the \"identity rectangle\" that starts the rectangle union process.\n    const targetBox = Rectangle.fromBounds(\n      Infinity,\n      -Infinity,\n      Infinity,\n      -Infinity\n    );\n    for (const target of targets) {\n      Rectangle.union(targetBox, this.getBoundingBox(target), targetBox);\n    }\n    targetBox.snapToInt();\n\n    if (!sprBox.intersects(targetBox)) return false;\n    if (fast) return true;\n\n    const cx = this._collisionBuffer.width / 2;\n    const cy = this._collisionBuffer.height / 2;\n    const collisionBox = Rectangle.intersection(sprBox, targetBox).clamp(\n      -cx,\n      cx,\n      -cy,\n      cy\n    );\n\n    if (collisionBox.width === 0 || collisionBox.height === 0) return false;\n\n    this._setFramebuffer(this._collisionBuffer);\n    // Enable stencil testing then stencil in this sprite, which masks all further drawing to this sprite's area.\n    this._stencilSprite(spr, sprColor);\n\n    // Render the sprites to check that we're touching, which will now be masked in to the area of the first sprite.\n    this._renderLayers(targets, {\n      drawMode: ShaderManager.DrawModes.SILHOUETTE,\n      // Ignore ghost effect\n      effectMask: ~effectBitmasks.ghost\n    });\n\n    const gl = this.gl;\n    // Make sure to disable the stencil test so as not to affect other rendering!\n    gl.disable(gl.STENCIL_TEST);\n\n    const pixelData = new Uint8Array(\n      collisionBox.width * collisionBox.height * 4\n    );\n    gl.readPixels(\n      collisionBox.left + cx,\n      collisionBox.bottom + cy,\n      collisionBox.width,\n      collisionBox.height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixelData\n    );\n\n    // Any opaque pixel = an overlap between the two sprites.\n    for (let i = 0; i < pixelData.length; i += 4) {\n      if (pixelData[i + 3] !== 0) return true;\n    }\n\n    return false;\n  }\n\n  checkColorCollision(spr, targetsColor, sprColor) {\n    const sprBox = Rectangle.copy(\n      this.getBoundingBox(spr),\n      __collisionBox\n    ).snapToInt();\n\n    const cx = this._collisionBuffer.width / 2;\n    const cy = this._collisionBuffer.height / 2;\n    sprBox.clamp(-cx, cx, -cy, cy);\n\n    if (sprBox.width === 0 || sprBox.height === 0) return false;\n\n    this._setFramebuffer(this._collisionBuffer);\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n\n    this._setFramebuffer(this._collisionBuffer);\n    // Enable stencil testing then stencil in this sprite, which masks all further drawing to this sprite's area.\n    this._stencilSprite(spr, sprColor);\n\n    // Render the sprites to check that we're touching, which will now be masked in to the area of the first sprite.\n    this._renderLayers(null, {\n      filter: layer => layer !== spr\n    });\n\n    // Make sure to disable the stencil test so as not to affect other rendering!\n    gl.disable(gl.STENCIL_TEST);\n\n    const pixelData = new Uint8Array(sprBox.width * sprBox.height * 4);\n    gl.readPixels(\n      sprBox.left + cx,\n      sprBox.bottom + cy,\n      sprBox.width,\n      sprBox.height,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      pixelData\n    );\n\n    const color = targetsColor.toRGBA();\n    for (let i = 0; i < pixelData.length; i += 4) {\n      if (\n        // Ensure we're not testing transparent pixels\n        pixelData[i + 3] !== 0 &&\n        // Scratch tests the top 5 bits of the red and green channels,\n        // and the top 4 bits of the blue channel.\n        ((pixelData[i] ^ color[0]) & 0b11111000) === 0 &&\n        ((pixelData[i + 1] ^ color[1]) & 0b11111000) === 0 &&\n        ((pixelData[i + 2] ^ color[2]) & 0b11110000) === 0\n      )\n        return true;\n    }\n\n    return false;\n  }\n\n  // Pick the topmost sprite at the given point (if one exists).\n  pick(sprites, point) {\n    this._setFramebuffer(this._collisionBuffer);\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    const spriteIndices = new Map();\n    for (let i = 0; i < sprites.length; i++) {\n      spriteIndices.set(sprites[i], i);\n    }\n\n    this._renderLayers(new Set(sprites), {\n      effectMask: ~effectBitmasks.ghost,\n      drawMode: ShaderManager.DrawModes.SPRITE_ID,\n      // let's not use indexOf here--that would be O(n^2)\n      spriteColorId: (target) => spriteIndices.get(target)\n    });\n\n    const hoveredPixel = new Uint8Array(4);\n    const cx = this._collisionBuffer.width / 2;\n    const cy = this._collisionBuffer.height / 2;\n    gl.readPixels(\n      point.x + cx,\n      point.y + cy,\n      1,\n      1,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      hoveredPixel\n    );\n\n    const index = colorToId(hoveredPixel);\n    if (index === -1) return null;\n    return sprites[index];\n  }\n\n  checkPointCollision(spr, point, fast) {\n    if (!spr.visible) return false;\n\n    const box = this.getBoundingBox(spr);\n    if (!box.containsPoint(point.x, point.y)) return false;\n    if (fast) return true;\n\n    // TODO: would it be faster to enable a scissor rectangle?\n    this._setFramebuffer(this._collisionBuffer);\n    const gl = this.gl;\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    this._renderLayers(new Set([spr]), { effectMask: ~effectBitmasks.ghost });\n\n    const hoveredPixel = new Uint8Array(4);\n    const cx = this._collisionBuffer.width / 2;\n    const cy = this._collisionBuffer.height / 2;\n    gl.readPixels(\n      point.x + cx,\n      point.y + cy,\n      1,\n      1,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      hoveredPixel\n    );\n    return hoveredPixel[3] !== 0;\n  }\n\n  penLine(pt1, pt2, color, size) {\n    this._penSkin.penLine(pt1, pt2, color, size);\n  }\n\n  clearPen() {\n    this._penSkin.clear();\n  }\n\n  stamp(spr) {\n    this._setFramebuffer(this._penSkin._framebufferInfo);\n    this._renderLayers(new Set([spr]), { renderSpeechBubbles: false });\n  }\n\n  displayAskBox(question) {\n    const askBox = document.createElement(\"form\");\n    askBox.classList.add(\"leopard__askBox\");\n\n    const askText = document.createElement(\"span\");\n    askText.classList.add(\"leopard__askText\");\n    askText.innerText = question;\n    askBox.append(askText);\n\n    const askInput = document.createElement(\"input\");\n    askInput.type = \"text\";\n    askInput.classList.add(\"leopard__askInput\");\n    askBox.append(askInput);\n\n    const askButton = document.createElement(\"button\");\n    askButton.classList.add(\"leopard__askButton\");\n    askButton.innerText = \"Answer\";\n    askBox.append(askButton);\n\n    this.renderTarget.append(askBox);\n    askInput.focus();\n\n    return new Promise(resolve => {\n      askBox.addEventListener(\"submit\", e => {\n        e.preventDefault();\n        askBox.remove();\n        resolve(askInput.value);\n      });\n    });\n  }\n}\n","export default class Input {\n  constructor(stage, canvas, onKeyDown) {\n    this._stage = stage;\n    this._canvas = canvas;\n\n    // Allow setting focus to canvas\n    if (this._canvas.tabIndex < 0) {\n      this._canvas.tabIndex = 0;\n    }\n\n    this.mouse = { x: 0, y: 0, down: false };\n    this._canvas.addEventListener(\"mousemove\", this._mouseMove.bind(this));\n    this._canvas.addEventListener(\"mousedown\", this._mouseDown.bind(this));\n    this._canvas.addEventListener(\"mouseup\", this._mouseUp.bind(this));\n\n    this._canvas.addEventListener(\"keyup\", this._keyup.bind(this));\n    this._canvas.addEventListener(\"keydown\", this._keydown.bind(this));\n\n    this.keys = [];\n    this._onKeyDown = onKeyDown;\n  }\n\n  _mouseMove(e) {\n    const rect = this._canvas.getBoundingClientRect();\n    const scaleX = this._stage.width / rect.width;\n    const scaleY = this._stage.height / rect.height;\n    const realCoords = {\n      x: (e.clientX - rect.left) * scaleX,\n      y: (e.clientY - rect.top) * scaleY\n    };\n\n    this.mouse = {\n      ...this.mouse,\n      x: realCoords.x - this._stage.width / 2,\n      y: -realCoords.y + this._stage.height / 2\n    };\n  }\n\n  _mouseDown() {\n    this.mouse = {\n      ...this.mouse,\n      down: true\n    };\n  }\n\n  _mouseUp() {\n    this.mouse = {\n      ...this.mouse,\n      down: false\n    };\n  }\n\n  _keyup(e) {\n    const key = this._getKeyName(e);\n    this.keys = this.keys.filter(k => k !== key);\n  }\n\n  _keydown(e) {\n    e.preventDefault();\n\n    const key = this._getKeyName(e);\n    if (this.keys.indexOf(key) === -1) {\n      this.keys.push(key);\n    }\n\n    this._onKeyDown(key);\n  }\n\n  _getKeyName(e) {\n    if (e.key === \"ArrowUp\") return \"up arrow\";\n    if (e.key === \"ArrowDown\") return \"down arrow\";\n    if (e.key === \"ArrowLeft\") return \"left arrow\";\n    if (e.key === \"ArrowRight\") return \"right arrow\";\n    if (e.key === \" \") return \"space\";\n    if (e.code.substring(0, 5) === \"Digit\") return e.code[5];\n\n    return e.key.toLowerCase();\n  }\n\n  keyPressed(name) {\n    if (name === \"any\") return this.keys.length > 0;\n    return this.keys.indexOf(name) > -1;\n  }\n\n  focus() {\n    this._canvas.focus();\n  }\n}\n","import Sound from \"./Sound.ts\";\n\nconst IGNORABLE_ERROR = [\"NotAllowedError\", \"NotFoundError\"];\n\n// https://github.com/LLK/scratch-audio/blob/develop/src/Loudness.ts\nexport default class LoudnessHandler {\n  constructor() {\n    // TODO: use a TypeScript enum\n    this.connectionState = \"NOT_CONNECTED\";\n  }\n\n  get audioContext() {\n    return Sound.audioContext;\n  }\n\n  async connect() {\n    // If we're in the middle of connecting, or failed to connect,\n    // don't attempt to connect again\n    if (this.connectionState !== \"NOT_CONNECTED\") return;\n    this.connectionState = \"CONNECTING\";\n\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      // Chrome blocks usage of audio until the user interacts with the page.\n      // By calling `resume` here, we will wait until that happens.\n      await Sound.audioContext.resume();\n      this.hasConnected = true;\n      this.audioStream = stream;\n      const mic = this.audioContext.createMediaStreamSource(stream);\n      this.analyser = this.audioContext.createAnalyser();\n      mic.connect(this.analyser);\n      this.micDataArray = new Float32Array(this.analyser.fftSize);\n      this.connectionState = \"CONNECTED\";\n    } catch (e) {\n      this.connectionState = \"ERROR\";\n      if (IGNORABLE_ERROR.includes(e.name)) {\n        console.warn(\"Mic is not available.\");\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  get loudness() {\n    if (this.connectionState !== \"CONNECTED\" || !this.audioStream.active) {\n      return -1;\n    }\n\n    this.analyser.getFloatTimeDomainData(this.micDataArray);\n    let sum = 0;\n    // compute the RMS of the sound\n    for (let i = 0; i < this.micDataArray.length; i++) {\n      sum += Math.pow(this.micDataArray[i], 2);\n    }\n    let rms = Math.sqrt(sum / this.micDataArray.length);\n    // smoothe the value with the last one, if it is descending\n    if (this._lastValue) {\n      rms = Math.max(rms, this._lastValue * 0.6);\n    }\n    this._lastValue = rms;\n\n    // scale the measurement so it's more sensitive to quieter sounds\n    rms *= 1.63;\n    rms = Math.sqrt(rms);\n    rms = Math.round(rms * 100);\n    rms = Math.min(rms, 100);\n    return rms;\n  }\n\n  getLoudness() {\n    this.connect();\n    return this.loudness;\n  }\n}\n","import Trigger from \"./Trigger.ts\";\nimport Renderer from \"./Renderer.ts\";\nimport Input from \"./Input.ts\";\nimport LoudnessHandler from \"./Loudness.ts\";\nimport Sound from \"./Sound.ts\";\n\nexport default class Project {\n  constructor(stage, sprites = {}, { frameRate = 30 } = {}) {\n    this.stage = stage;\n    this.sprites = sprites;\n\n    Object.freeze(sprites); // Prevent adding/removing sprites while project is running\n\n    for (const sprite of this.spritesAndClones) {\n      sprite._project = this;\n    }\n    this.stage._project = this;\n\n    this.renderer = new Renderer(this);\n    this.input = new Input(this.stage, this.renderer.stage, key => {\n      this.fireTrigger(Trigger.KEY_PRESSED, { key });\n    });\n\n    this.loudnessHandler = new LoudnessHandler();\n    // Only update loudness once per step.\n    this._cachedLoudness = null;\n\n    this.runningTriggers = [];\n    // Used to keep track of what edge-activated trigger predicates evaluted to\n    // on the previous step.\n    this._prevStepTriggerPredicates = new WeakMap();\n\n    this.restartTimer();\n\n    this.answer = null;\n\n    // Run project code at specified framerate\n    setInterval(() => {\n      this.step();\n    }, 1000 / frameRate);\n\n    // Render project as fast as possible\n    this._renderLoop();\n  }\n\n  attach(renderTarget) {\n    this.renderer.setRenderTarget(renderTarget);\n    this.renderer.stage.addEventListener(\"click\", () => {\n      // Chrome requires a user gesture on the page before we can start the\n      // audio context.\n      // When we click the stage, that counts as a user gesture, so try\n      // resuming the audio context.\n      if (Sound.audioContext.state === \"suspended\") {\n        Sound.audioContext.resume();\n      }\n\n      let clickedSprite = this.renderer.pick(this.spritesAndClones, {\n        x: this.input.mouse.x,\n        y: this.input.mouse.y\n      });\n      if (!clickedSprite) {\n        clickedSprite = this.stage;\n      }\n\n      const matchingTriggers = [];\n      for (const trigger of clickedSprite.triggers) {\n        if (trigger.matches(Trigger.CLICKED, {}, clickedSprite)) {\n          matchingTriggers.push({ trigger, target: clickedSprite });\n        }\n      }\n\n      this._startTriggers(matchingTriggers);\n    });\n  }\n\n  greenFlag() {\n    // Chrome requires a user gesture on the page before we can start the\n    // audio context.\n    // When greenFlag is triggered, it's likely that the cause of it was some\n    // kind of button click, so try resuming the audio context.\n    if (Sound.audioContext.state === \"suspended\") {\n      Sound.audioContext.resume();\n    }\n    this.fireTrigger(Trigger.GREEN_FLAG);\n    this.input.focus();\n  }\n\n  // Find triggers which match the given condition\n  _matchingTriggers(triggerMatches) {\n    let matchingTriggers = [];\n    const targets = this.spritesAndStage;\n    for (const target of targets) {\n      const matchingTargetTriggers = target.triggers.filter(tr =>\n        triggerMatches(tr, target)\n      );\n      for (const match of matchingTargetTriggers) {\n        matchingTriggers.push({ trigger: match, target });\n      }\n    }\n    return matchingTriggers;\n  }\n\n  _stepEdgeActivatedTriggers() {\n    const edgeActivated = this._matchingTriggers(tr => tr.isEdgeActivated);\n    const triggersToStart = [];\n    for (const triggerWithTarget of edgeActivated) {\n      const { trigger, target } = triggerWithTarget;\n      let predicate;\n      switch (trigger.trigger) {\n        case Trigger.TIMER_GREATER_THAN:\n          predicate = this.timer > trigger.option(\"VALUE\", target);\n          break;\n        case Trigger.LOUDNESS_GREATER_THAN:\n          predicate = this.loudness > trigger.option(\"VALUE\", target);\n          break;\n        default:\n          throw new Error(`Unimplemented trigger ${trigger.trigger}`);\n      }\n\n      // Default to false\n      const prevPredicate = !!this._prevStepTriggerPredicates.get(trigger);\n      this._prevStepTriggerPredicates.set(trigger, predicate);\n\n      // The predicate evaluated to false last time and true this time\n      // Activate the trigger\n      if (!prevPredicate && predicate) {\n        triggersToStart.push(triggerWithTarget);\n      }\n    }\n    this._startTriggers(triggersToStart);\n  }\n\n  step() {\n    this._cachedLoudness = null;\n    this._stepEdgeActivatedTriggers();\n\n    // Step all triggers\n    const alreadyRunningTriggers = this.runningTriggers;\n    for (let i = 0; i < alreadyRunningTriggers.length; i++) {\n      alreadyRunningTriggers[i].trigger.step();\n    }\n\n    // Remove finished triggers\n    this.runningTriggers = this.runningTriggers.filter(\n      ({ trigger }) => !trigger.done\n    );\n  }\n\n  render() {\n    // Render to canvas\n    this.renderer.update(this.stage, this.spritesAndClones);\n\n    // Update watchers\n    for (const sprite of [...Object.values(this.sprites), this.stage]) {\n      for (const watcher of Object.values(sprite.watchers)) {\n        watcher.updateDOM(this.renderer.renderTarget);\n      }\n    }\n  }\n\n  _renderLoop() {\n    requestAnimationFrame(this._renderLoop.bind(this));\n    this.render();\n  }\n\n  fireTrigger(trigger, options) {\n    // Special trigger behaviors\n    if (trigger === Trigger.GREEN_FLAG) {\n      this.restartTimer();\n      this.stopAllSounds();\n      this.runningTriggers = [];\n\n      for (const spriteName in this.sprites) {\n        const sprite = this.sprites[spriteName];\n        sprite.clones = [];\n      }\n\n      for (const sprite of this.spritesAndStage) {\n        sprite.effects.clear();\n        sprite.audioEffects.clear();\n      }\n    }\n\n    const matchingTriggers = this._matchingTriggers((tr, target) =>\n      tr.matches(trigger, options, target)\n    );\n\n    return this._startTriggers(matchingTriggers);\n  }\n\n  _startTriggers(triggers) {\n    // Only add these triggers to this.runningTriggers if they're not already there.\n    // TODO: if the triggers are already running, they'll be restarted but their execution order is unchanged.\n    // Does that match Scratch's behavior?\n    for (const trigger of triggers) {\n      if (\n        !this.runningTriggers.find(\n          runningTrigger =>\n            trigger.trigger === runningTrigger.trigger &&\n            trigger.target === runningTrigger.target\n        )\n      ) {\n        this.runningTriggers.push(trigger);\n      }\n    }\n    return Promise.all(\n      triggers.map(({ trigger, target }) => {\n        return trigger.start(target);\n      })\n    );\n  }\n\n  get spritesAndClones() {\n    return Object.values(this.sprites)\n      .flatMap(sprite => sprite.andClones())\n      .sort((a, b) => a._layerOrder - b._layerOrder);\n  }\n\n  get spritesAndStage() {\n    return [...this.spritesAndClones, this.stage];\n  }\n\n  changeSpriteLayer(sprite, layerDelta, relativeToSprite = sprite) {\n    let spritesArray = this.spritesAndClones;\n\n    const originalIndex = spritesArray.indexOf(sprite);\n    const relativeToIndex = spritesArray.indexOf(relativeToSprite);\n\n    let newIndex = relativeToIndex + layerDelta;\n    if (newIndex < 0) newIndex = 0;\n    if (newIndex > spritesArray.length - 1) newIndex = spritesArray.length - 1;\n\n    // Remove sprite from originalIndex and insert at newIndex\n    spritesArray.splice(originalIndex, 1);\n    spritesArray.splice(newIndex, 0, sprite);\n\n    // spritesArray is sorted correctly, but to influence\n    // the actual order of the sprites we need to update\n    // each one's _layerOrder property.\n    spritesArray.forEach((sprite, index) => {\n      sprite._layerOrder = index + 1;\n    });\n  }\n\n  stopAllSounds() {\n    for (const target of this.spritesAndStage) {\n      target.stopAllOfMySounds();\n    }\n  }\n\n  get timer() {\n    const ms = new Date() - this.timerStart;\n    return ms / 1000;\n  }\n\n  restartTimer() {\n    this.timerStart = new Date();\n  }\n\n  async askAndWait(question) {\n    this.answer = await this.renderer.displayAskBox(question);\n  }\n\n  get loudness() {\n    if (this._cachedLoudness === null) {\n      this._cachedLoudness = this.loudnessHandler.getLoudness();\n    }\n    return this._cachedLoudness;\n  }\n}\n","import Color from \"./Color\";\n\nexport default class Watcher {\n  constructor({\n    value = () => \"\",\n    setValue = () => {},\n    label,\n    style = \"normal\",\n    visible = true,\n    color = Color.rgb(255, 140, 26),\n    step = 1,\n    min = 0,\n    max = 100,\n    x = -240,\n    y = 180,\n    width,\n    height\n  }) {\n    this.initializeDOM();\n\n    this.value = value;\n    this.setValue = setValue;\n    this._previousValue = Symbol(\"NO_PREVIOUS_VALUE\");\n\n    this.label = label;\n    this.style = style;\n    this.visible = visible;\n    this.color = color;\n    this.step = step;\n    this.min = min;\n    this.max = max;\n\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  initializeDOM() {\n    const node = document.createElement(\"div\");\n    node.classList.add(\"leopard__watcher\");\n\n    const label = document.createElement(\"div\");\n    label.classList.add(\"leopard__watcherLabel\");\n    node.append(label);\n\n    const value = document.createElement(\"div\");\n    value.classList.add(\"leopard__watcherValue\");\n    node.append(value);\n\n    const slider = document.createElement(\"input\");\n    slider.type = \"range\";\n    slider.classList.add(\"leopard__watcherSlider\");\n\n    slider.addEventListener(\"input\", event => {\n      this.setValue(Number(event.target.value));\n    });\n\n    node.append(slider);\n\n    this._dom = { node, label, value, slider };\n  }\n\n  updateDOM(renderTarget) {\n    if (renderTarget && !renderTarget.contains(this._dom.node)) {\n      renderTarget.append(this._dom.node);\n    }\n\n    if (!this.visible) return;\n\n    const value = this.value();\n\n    const isList = Array.isArray(value);\n    this._dom.node.classList.toggle(\"leopard__watcher--list\", isList);\n    if (isList) {\n      // Render like a list\n      if (\n        !Array.isArray(this._previousValue) ||\n        JSON.stringify(value.map(String)) !==\n          JSON.stringify(this._previousValue.map(String))\n      ) {\n        this._dom.value.innerHTML = \"\";\n        for (const [index, item] of value.entries()) {\n          const itemElem = document.createElement(\"div\");\n          itemElem.classList.add(\"leopard__watcherListItem\");\n\n          const indexElem = document.createElement(\"div\");\n          indexElem.classList.add(\"leopard__watcherListItemIndex\");\n          indexElem.innerText = index;\n\n          const contentElem = document.createElement(\"div\");\n          contentElem.classList.add(\"leopard__watcherListItemContent\");\n          contentElem.innerText = item.toString();\n\n          itemElem.append(indexElem);\n          itemElem.append(contentElem);\n          this._dom.value.append(itemElem);\n        }\n      }\n    } else {\n      // Render like a normal variable\n      if (value !== this._previousValue) {\n        this._dom.value.innerText = value.toString();\n      }\n    }\n\n    if (isList) {\n      this._previousValue = [...value];\n    } else {\n      this._previousValue = value;\n    }\n\n    // Set slider value\n    if (this._style === \"slider\") {\n      this._dom.slider.value = value;\n    }\n\n    // Update color\n    // (Needs to happen here rather than a setter because\n    // mutation of color object is possible.)\n    const textColor =\n      this.color.r * 0.299 + this.color.g * 0.587 + this.color.b * 0.114 > 162\n        ? \"#000\"\n        : \"#fff\";\n    this._dom.value.style.setProperty(\"--watcher-color\", this.color.toString());\n    this._dom.value.style.setProperty(\"--watcher-text-color\", textColor);\n  }\n\n  get visible() {\n    return this._visible;\n  }\n  set visible(visible) {\n    this._visible = visible;\n    this._dom.node.style.visibility = visible ? \"visible\" : \"hidden\";\n  }\n\n  get x() {\n    return this._x;\n  }\n  set x(x) {\n    this._x = x;\n    this._dom.node.style.left = `${x - 240}px`;\n  }\n\n  get y() {\n    return this._y;\n  }\n  set y(y) {\n    this._y = y;\n    this._dom.node.style.top = `${180 - y}px`;\n  }\n\n  get width() {\n    return this._width;\n  }\n  set width(width) {\n    this._width = width;\n    if (width) {\n      this._dom.node.style.width = `${width}px`;\n    } else {\n      this._dom.node.style.width = undefined;\n    }\n  }\n\n  get height() {\n    return this._height;\n  }\n  set height(height) {\n    this._height = height;\n    if (height) {\n      this._dom.node.style.height = `${height}px`;\n    } else {\n      this._dom.node.style.height = undefined;\n    }\n  }\n\n  get style() {\n    return this._style;\n  }\n  set style(style) {\n    this._style = style;\n    this._dom.node.classList.toggle(\n      \"leopard__watcher--normal\",\n      style === \"normal\"\n    );\n    this._dom.node.classList.toggle(\n      \"leopard__watcher--large\",\n      style === \"large\"\n    );\n    this._dom.node.classList.toggle(\n      \"leopard__watcher--slider\",\n      style === \"slider\"\n    );\n  }\n\n  get min() {\n    return this._min;\n  }\n  set min(min) {\n    this._min = min;\n    this._dom.slider.min = min;\n  }\n\n  get max() {\n    return this._max;\n  }\n  set max(max) {\n    this._max = max;\n    this._dom.slider.max = max;\n  }\n\n  get step() {\n    return this._step;\n  }\n  set step(step) {\n    this._step = step;\n    this._dom.slider.step = step;\n  }\n\n  get label() {\n    return this._label;\n  }\n  set label(label) {\n    this._label = label;\n    this._dom.label.innerText = label;\n  }\n}\n"],"names":["GREEN_FLAG","Symbol","KEY_PRESSED","BROADCAST","CLICKED","CLONE_START","LOUDNESS_GREATER_THAN","TIMER_GREATER_THAN","BACKDROP_CHANGED","Trigger","constructor","trigger","options","script","this","_script","done","stop","isEdgeActivated","option","target","triggerOption","matches","start","boundScript","bind","_runningScript","Promise","resolve","step","next","Matrix","static","matrix","Float32Array","identity","dst","src","x","y","a00","a01","a02","a10","a11","a12","a20","a21","a22","rad","s","Math","sin","c","cos","m","Rectangle","left","Infinity","right","bottom","top","result","xa","xb","absx","abs","sumx","ya","yb","absy","sumy","snapToInt","floor","ceil","intersects","rect","containsPoint","clamp","min","max","rect1","rect2","width","height","effectNames","effectBitmasks","i","length","effectTransformPoint","drawable","effects","_sprite","effectBitmask","_bitmask","mosaic","mosaicFactor","pixelate","skin","getCurrentSkin","pixSizeX","pixSizeY","whirl","PI_OVER_180","offsetX","offsetY","offsetLength","sqrt","whirlFactor","fisheye","vecX","vecY","len","factor","r","pow","unitX","unitY","n","rgbToHSV","g","b","delta","h","v","hsvToRGB","Color","a","Number","rgb","_setRGB","_a","_h","_s","_v","toHexString","forceIncludeAlpha","toHexDigits","str","round","toString","hex","map","join","toRGBString","toRGBA","toRGBANormalized","ADPCM_STEPS","ADPCM_INDEX","decodeADPCMAudio","ab","audioContext","dv","DataView","getUint32","reject","Error","blocks","l","byteLength","String","fromCharCode","getUint8","format","getUint16","sampleRate","blockSize","frameCount","fact","buffer","createBuffer","channel","getChannelData","sample","code","index","lastByte","offset","data","j","getInt16","isADPCMData","arrayBuffer","dataView","isWavData","Sound","name","url","audioBuffer","source","playbackRate","downloadMyAudioBuffer","duration","started","isLatestCallToStart","_markDone","playMyAudioBuffer","oldDoneDownloading","_doneDownloading","fromMoreRecentCall","playUntilDone","playing","addEventListener","disconnect","fetch","then","body","catch","error","console","warn","decodeAudioData","createBufferSource","value","connect","currentTime","setPlaybackRate","isConnectedTo","_setupAudioContext","_audioContext","AudioContext","window","webkitAudioContext","EffectChain","config","getNonPatchSoundList","inputNode","createGain","effectNodes","resetToInitial","initials","getInitialEffectValues","effectValues","initialValue","Object","entries","getEffectDescriptor","reset","setEffectValue","updateAudioEffect","descriptor","isPatch","getNextEffectDescriptor","previous","getPreviousEffectDescriptor","output","input","nodes","initial","makeNodes","node","Set","values","set","sound","last","getLastEffectDescriptor","isNaN","clampEffectValue","changeEffectValue","minimum","maximum","getEffectValue","clone","newConfig","newEffectChain","assign","resetOnClone","applyToSound","isTargetOf","effectDescriptors","find","slice","_","decayDuration","decayWait","aCtx","leftGain","rightGain","channelMerger","createChannelMerger","p","leftVal","PI","rightVal","gain","setTargetAtTime","interval","ratio","resetOnStart","linearRampToValueAtTime","AudioEffectMap","effectChain","defineProperty","get","clear","_EffectMap","_effectValues","effectName","val","_clone","keys","SpriteBase","initialConditions","vars","_project","costumeNumber","layerOrder","_costumeNumber","_layerOrder","triggers","watchers","costumes","sounds","getSoundsPlayedByMe","destination","audioEffects","_vars","filter","stage","sprites","number","wrapClamp","fireBackdropChanged","costume","findIndex","lower","upper","excluded","possibleOptions","randInt","random","trim","moveAhead","changeSpriteLayer","moveBehind","degToRad","deg","radToDeg","degToScratch","scratchToDeg","scratchDir","radToScratch","scratchToRad","scratchTan","angle","parseFloat","tan","toFixed","normalizeDeg","range","warp","procedure","bound","args","inst","wait","secs","endTime","Date","setMilliseconds","getMilliseconds","mouse","keyPressed","timer","restartTimer","startSound","soundName","getSound","playSoundUntilDone","stopAllSounds","stopAllOfMySounds","broadcast","fireTrigger","broadcastAndWait","running","clearPen","renderer","askAndWait","question","_speechBubble","say","answer","loudness","toNumber","toBoolean","toLowerCase","Boolean","stringIncludes","string","substring","includes","arrayIncludes","array","some","item","compare","letterOf","itemOf","indexInArray","v1","v2","n1","n2","NaN","s1","s2","Sprite","super","direction","rotationStyle","size","visible","penDown","penSize","penColor","_x","_y","_direction","RotationStyle","ALL_AROUND","parent","clones","_penDown","_penColor","text","style","timeout","createClone","create","getPrototypeOf","original","push","tr","_startTriggers","deleteThisClone","runningTriggers","andClones","flatMap","dir","goto","penLine","move","dist","moveDir","glide","seconds","interpolate","t","startTime","startX","startY","color","stamp","touching","fast","checkPointCollision","bounds","getTightBoundingBox","stageWidth","stageHeight","checkColorCollision","checkSpriteCollision","colorTouching","clearTimeout","think","sayAndWait","setTimeout","thinkAndWait","freeze","LEFT_RIGHT","DONT_ROTATE","Stage","defineProperties","enumerable","__counter","backdrop","determinant","SpriteTransformDiff","sprite","_unset","update","_lastX","_lastY","_lastRotation","_lastRotationStyle","_lastSize","_lastCostume","_lastCostumeLoaded","img","complete","changed","Drawable","_renderer","_matrix","_matrixDiff","_calculateSpriteMatrix","_convexHullImageData","_convexHullMosaic","_convexHullPixelate","_convexHullWhirl","_convexHullFisheye","_convexHullPoints","_aabb","_tightBoundingBox","_convexHullMatrixDiff","_getSkin","getAABB","fromMatrix","getMatrix","convexHullPoints","_calculateConvexHull","fromBounds","transformedPoint","halfPixelX","halfPixelY","point","transformPoint","imageData","getImageData","leftHull","rightHull","pixelPos","effectPos","currentPoint","pixelX","pixelY","pop","spr","translate","rotate","scale","spriteScale","scalingFactor","resolution","center","Skin","gl","getTexture","_makeTexture","image","filtering","glTexture","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","texImage2D","RGBA","UNSIGNED_BYTE","_setSizeFromImage","naturalWidth","naturalHeight","destroy","BitmapSkin","_image","_imageData","_texture","canvas","document","createElement","ctx","getContext","drawImage","NEAREST","deleteTexture","SpriteShader","PenLineShader","Shader","program","uniforms","attribs","numActiveUniforms","getProgramParameter","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","numActiveAttributes","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","ShaderManager","_shaderCache","drawMode","DrawModes","Map","_createShader","type","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","getShader","shaderMap","has","shaderCode","PEN_LINE","define","vertShader","vertex","VERTEX_SHADER","fragShader","fragment","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","LINK_STATUS","info","getProgramInfoLog","DEFAULT","SILHOUETTE","COLOR_MASK","SPRITE_ID","PenSkin","framebufferInfo","_createFramebufferInfo","_framebufferInfo","_lastPenState","texture","deleteFramebuffer","framebuffer","pt1","pt2","_setFramebuffer","_shaderManager","shaderChanged","_setShader","uniform2f","u_penSkinSize","oldColor","uniform4f","u_penColor","uniform1f","u_penSize","lineDiffX","lineDiffY","u_penPoints","lineLength","u_lineLength","drawArrays","TRIANGLES","clearColor","COLOR_BUFFER_BIT","bubbleStyle","SpeechBubbleSkin","bubble","_canvas","LINEAR","_bubble","_flipped","_rendered","_renderedScale","_renderBubble","_restyleCanvas","font","textBaseline","flipped","textWidth","measureText","maxWidth","padding","setTransform","fillStyle","strokeStyle","lineWidth","save","w","beginPath","moveTo","arcTo","lineTo","ellipse","closePath","stroke","fill","renderBubbleBackground","restore","fillText","VectorSkin","_imageDataMipLevel","_maxTextureSize","getParameter","MAX_TEXTURE_SIZE","_mipmaps","log2","mipLevel","mipLevelForScale","_drawSvgToCanvas","_createMipmap","mip","Costume","Image","crossOrigin","isBitmap","match","__collisionBox","Renderer","project","renderTarget","createStage","antialias","setRenderTarget","_drawables","WeakMap","_skins","_currentShader","_currentFramebuffer","_screenSpaceScale","enable","BLEND","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","activeTexture","TEXTURE0","_penSkin","_collisionBuffer","obj","_getDrawable","stencil","createFramebuffer","framebufferTexture2D","FRAMEBUFFER","COLOR_ATTACHMENT0","renderbuffer","createRenderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","DEPTH_STENCIL","framebufferRenderbuffer","DEPTH_STENCIL_ATTACHMENT","useProgram","attribLocation","a_position","enableVertexAttribArray","vertexAttribPointer","FLOAT","_updateStageSize","bindFramebuffer","viewport","querySelector","classList","add","append","_renderLayers","layers","renderSpeechBubbles","shouldRestrictLayers","shouldFilterLayers","shouldIncludeLayer","layer","renderSprite","penMatrix","_renderSkin","spritesAndClones","u_stageSize","drawingBufferWidth","drawingBufferHeight","_resize","stageSize","getBoundingClientRect","devicePixelRatio","adjustedWidth","adjustedHeight","imageRendering","_calculateSpeechBubbleMatrix","speechBubbleSkin","sprBounds","getBoundingBox","effectMask","colorMask","spriteColorId","skinTexture","uniformMatrix3fv","u_transform","effect","effectVal","u_skinSize","id","uniform1i","u_texture","Array","isArray","uniform4fv","u_colorMask","uniform3fv","u_spriteId","prototype","hasOwnProperty","call","undefined","_stencilSprite","STENCIL_BUFFER_BIT","STENCIL_TEST","stencilFunc","ALWAYS","stencilOp","KEEP","REPLACE","opts","ghost","EQUAL","targets","sprColor","sprBox","copy","targetBox","union","cx","cy","collisionBox","intersection","disable","pixelData","Uint8Array","readPixels","targetsColor","pick","spriteIndices","hoveredPixel","colorToId","displayAskBox","askBox","askText","innerText","askInput","askButton","focus","e","preventDefault","remove","Input","onKeyDown","_stage","tabIndex","down","_mouseMove","_mouseDown","_mouseUp","_keyup","_keydown","_onKeyDown","scaleX","scaleY","realCoords","clientX","clientY","key","_getKeyName","k","indexOf","IGNORABLE_ERROR","LoudnessHandler","connectionState","async","stream","navigator","mediaDevices","getUserMedia","audio","resume","hasConnected","audioStream","mic","createMediaStreamSource","analyser","createAnalyser","micDataArray","fftSize","active","getFloatTimeDomainData","sum","rms","_lastValue","getLoudness","Project","frameRate","loudnessHandler","_cachedLoudness","_prevStepTriggerPredicates","setInterval","_renderLoop","attach","state","clickedSprite","matchingTriggers","greenFlag","_matchingTriggers","triggerMatches","spritesAndStage","matchingTargetTriggers","_stepEdgeActivatedTriggers","edgeActivated","triggersToStart","triggerWithTarget","predicate","prevPredicate","alreadyRunningTriggers","render","watcher","updateDOM","requestAnimationFrame","spriteName","runningTrigger","all","sort","layerDelta","relativeToSprite","spritesArray","originalIndex","newIndex","splice","forEach","timerStart","Watcher","setValue","label","initializeDOM","_previousValue","slider","event","_dom","contains","isList","toggle","JSON","stringify","innerHTML","itemElem","indexElem","contentElem","_style","textColor","setProperty","_visible","visibility","_width","_height","_min","_max","_step","_label"],"mappings":"AAAA,MAAMA,EAAaC,OAAO,cACpBC,EAAcD,OAAO,eACrBE,EAAYF,OAAO,aACnBG,EAAUH,OAAO,WACjBI,EAAcJ,OAAO,eACrBK,EAAwBL,OAAO,yBAC/BM,EAAqBN,OAAO,sBAC5BO,EAAmBP,OAAO,oBAEjB,MAAMQ,EACnBC,YAAYC,EAASC,EAASC,GAC5BC,KAAKH,QAAUA,OAEO,IAAXE,GACTC,KAAKF,QAAU,GACfE,KAAKC,QAAUH,IAEfE,KAAKF,QAAUA,EACfE,KAAKC,QAAUF,GAGjBC,KAAKE,MAAO,EACZF,KAAKG,KAAO,MACb,CAEGC,sBACF,OACEJ,KAAKH,UAAYJ,GACjBO,KAAKH,UAAYL,CAEpB,CAIDa,OAAOA,EAAQC,GACb,IAAIC,EAAgBP,KAAKF,QAAQO,GAGjC,MAA6B,mBAAlBE,EACFA,EAAcD,GAEhBC,CACR,CAEDC,QAAQX,EAASC,EAASQ,GACxB,GAAIN,KAAKH,UAAYA,EAAS,OAAO,EACrC,IAAK,IAAIQ,KAAUP,EACjB,GAAIE,KAAKK,OAAOA,EAAQC,KAAYR,EAAQO,GAAS,OAAO,EAG9D,OAAO,CACR,CAEDI,MAAMH,GACJN,KAAKG,OAEL,MAAMO,EAAcV,KAAKC,QAAQU,KAAKL,GAKtC,OAHAN,KAAKE,MAAO,EACZF,KAAKY,eAAiBF,IAEf,IAAIG,SAAQC,IACjBd,KAAKG,KAAO,KACVH,KAAKE,MAAO,EACZY,GAAS,CACV,GAEJ,CAEDC,OACEf,KAAKE,KAAOF,KAAKY,eAAeI,OAAOd,KACnCF,KAAKE,MAAMF,KAAKG,MACrB,CAEUjB,wBACT,OAAOA,CACR,CACUE,yBACT,OAAOA,CACR,CACUC,uBACT,OAAOA,CACR,CACUC,qBACT,OAAOA,CACR,CACUC,yBACT,OAAOA,CACR,CACUC,mCACT,OAAOA,CACR,CACUC,gCACT,OAAOA,CACR,CACUC,8BACT,OAAOA,CACR,EC5FY,MAAMuB,EAEnBC,gBACE,MAAMC,EAAS,IAAIC,aAAa,GAEhC,OADAH,EAAOI,SAASF,GACTA,CACR,CAGDD,gBAAgBI,GAUd,OATAA,EAAI,GAAK,EACTA,EAAI,GAAK,EACTA,EAAI,GAAK,EACTA,EAAI,GAAK,EACTA,EAAI,GAAK,EACTA,EAAI,GAAK,EACTA,EAAI,GAAK,EACTA,EAAI,GAAK,EACTA,EAAI,GAAK,EACFA,CACR,CAGDJ,iBAAiBI,EAAKC,EAAKC,EAAGC,GAC5B,MAAMC,EAAMH,EAAI,GACdI,EAAMJ,EAAI,GACVK,EAAML,EAAI,GACVM,EAAMN,EAAI,GACVO,EAAMP,EAAI,GACVQ,EAAMR,EAAI,GACVS,EAAMT,EAAI,GACVU,EAAMV,EAAI,GACVW,EAAMX,EAAI,GAaZ,OAXAD,EAAI,GAAKI,EACTJ,EAAI,GAAKK,EACTL,EAAI,GAAKM,EAETN,EAAI,GAAKO,EACTP,EAAI,GAAKQ,EACTR,EAAI,GAAKS,EAETT,EAAI,GAAKE,EAAIE,EAAMD,EAAII,EAAMG,EAC7BV,EAAI,GAAKE,EAAIG,EAAMF,EAAIK,EAAMG,EAC7BX,EAAI,GAAKE,EAAII,EAAMH,EAAIM,EAAMG,EACtBZ,CACR,CAGDJ,cAAcI,EAAKC,EAAKY,GACtB,MAAMT,EAAMH,EAAI,GACdI,EAAMJ,EAAI,GACVK,EAAML,EAAI,GACVM,EAAMN,EAAI,GACVO,EAAMP,EAAI,GACVQ,EAAMR,EAAI,GACVS,EAAMT,EAAI,GACVU,EAAMV,EAAI,GACVW,EAAMX,EAAI,GACVa,EAAIC,KAAKC,IAAIH,GACbI,EAAIF,KAAKG,IAAIL,GAaf,OAXAb,EAAI,GAAKiB,EAAIb,EAAMU,EAAIP,EACvBP,EAAI,GAAKiB,EAAIZ,EAAMS,EAAIN,EACvBR,EAAI,GAAKiB,EAAIX,EAAMQ,EAAIL,EAEvBT,EAAI,GAAKiB,EAAIV,EAAMO,EAAIV,EACvBJ,EAAI,GAAKiB,EAAIT,EAAMM,EAAIT,EACvBL,EAAI,GAAKiB,EAAIR,EAAMK,EAAIR,EAEvBN,EAAI,GAAKU,EACTV,EAAI,GAAKW,EACTX,EAAI,GAAKY,EACFZ,CACR,CAGDJ,aAAaI,EAAKC,EAAKC,EAAGC,GAYxB,OAXAH,EAAI,GAAKE,EAAID,EAAI,GACjBD,EAAI,GAAKE,EAAID,EAAI,GACjBD,EAAI,GAAKE,EAAID,EAAI,GAEjBD,EAAI,GAAKG,EAAIF,EAAI,GACjBD,EAAI,GAAKG,EAAIF,EAAI,GACjBD,EAAI,GAAKG,EAAIF,EAAI,GAEjBD,EAAI,GAAKC,EAAI,GACbD,EAAI,GAAKC,EAAI,GACbD,EAAI,GAAKC,EAAI,GACND,CACR,CAGDJ,sBAAsBuB,EAAGnB,EAAKC,GAC5B,MAAMC,EAAID,EAAI,GACRE,EAAIF,EAAI,GAGd,OAFAD,EAAI,GAAKmB,EAAE,GAAKjB,EAAIiB,EAAE,GAAKhB,EAAIgB,EAAE,GACjCnB,EAAI,GAAKmB,EAAE,GAAKjB,EAAIiB,EAAE,GAAKhB,EAAIgB,EAAE,GAC1BnB,CACR,ECxGY,MAAMoB,EACnB9C,cAME,OALAI,KAAK2C,MAAQC,IACb5C,KAAK6C,MAAQD,IACb5C,KAAK8C,QAAUF,IACf5C,KAAK+C,IAAMH,IAEJ5C,IACR,CAEDkB,kBAAkByB,EAAME,EAAOC,EAAQC,EAAKC,GAO1C,OANKA,IAAQA,EAAS,IAAIN,GAC1BM,EAAOL,KAAOA,EACdK,EAAOH,MAAQA,EACfG,EAAOF,OAASA,EAChBE,EAAOD,IAAMA,EAENC,CACR,CAGD9B,kBAAkBC,EAAQ6B,GACnBA,IAAQA,EAAS,IAAIN,GAG1B,MAAMO,EAAK9B,EAAO,GAAK,EACjB+B,EAAK/B,EAAO,GAAK,EACjBgC,EAAOd,KAAKe,IAAIH,GAAMZ,KAAKe,IAAIF,GAC/BG,EAAOJ,EAAKC,EAAK/B,EAAO,GAExBmC,EAAKnC,EAAO,GAAK,EACjBoC,EAAKpC,EAAO,GAAK,EACjBqC,EAAOnB,KAAKe,IAAIE,GAAMjB,KAAKe,IAAIG,GAC/BE,EAAOH,EAAKC,EAAKpC,EAAO,GAO9B,OALA6B,EAAOL,KAAOU,EAAOF,EACrBH,EAAOH,MAAQQ,EAAOF,EACtBH,EAAOF,OAASW,EAAOD,EACvBR,EAAOD,IAAMU,EAAOD,EAEbR,CACR,CAGD9B,YAAYK,EAAKD,GAKf,OAJAA,EAAIqB,KAAOpB,EAAIoB,KACfrB,EAAIuB,MAAQtB,EAAIsB,MAChBvB,EAAIwB,OAASvB,EAAIuB,OACjBxB,EAAIyB,IAAMxB,EAAIwB,IACPzB,CACR,CAIDoC,YAME,OALA1D,KAAK2C,KAAON,KAAKsB,MAAM3D,KAAK2C,MAC5B3C,KAAK6C,MAAQR,KAAKuB,KAAK5D,KAAK6C,OAC5B7C,KAAK8C,OAAST,KAAKsB,MAAM3D,KAAK8C,QAC9B9C,KAAK+C,IAAMV,KAAKuB,KAAK5D,KAAK+C,KAEnB/C,IACR,CAGD6D,WAAWC,GACT,OACE9D,KAAK2C,MAAQmB,EAAKjB,OAClBiB,EAAKnB,MAAQ3C,KAAK6C,OAClB7C,KAAK+C,KAAOe,EAAKhB,QACjBgB,EAAKf,KAAO/C,KAAK8C,MAEpB,CAGDiB,cAAcvC,EAAGC,GACf,OACED,GAAKxB,KAAK2C,MAAQnB,GAAKxB,KAAK6C,OAASpB,GAAKzB,KAAK8C,QAAUrB,GAAKzB,KAAK+C,GAEtE,CAGDiB,MAAMrB,EAAME,EAAOC,EAAQC,GAMzB,OALA/C,KAAK2C,KAAON,KAAK4B,IAAI5B,KAAK6B,IAAIlE,KAAK2C,KAAMA,GAAOE,GAChD7C,KAAK6C,MAAQR,KAAK6B,IAAI7B,KAAK4B,IAAIjE,KAAK6C,MAAOA,GAAQF,GACnD3C,KAAK8C,OAAST,KAAK4B,IAAI5B,KAAK6B,IAAIlE,KAAK8C,OAAQA,GAASC,GACtD/C,KAAK+C,IAAMV,KAAK6B,IAAI7B,KAAK4B,IAAIjE,KAAK+C,IAAKA,GAAMD,GAEtC9C,IACR,CAGDkB,aAAaiD,EAAOC,EAAOpB,EAAS,IAAIN,GAMtC,OALAM,EAAOL,KAAON,KAAK4B,IAAIE,EAAMxB,KAAMyB,EAAMzB,MACzCK,EAAOH,MAAQR,KAAK6B,IAAIC,EAAMtB,MAAOuB,EAAMvB,OAC3CG,EAAOF,OAAST,KAAK4B,IAAIE,EAAMrB,OAAQsB,EAAMtB,QAC7CE,EAAOD,IAAMV,KAAK6B,IAAIC,EAAMpB,IAAKqB,EAAMrB,KAEhCC,CACR,CAGD9B,oBAAoBiD,EAAOC,EAAOpB,EAAS,IAAIN,GAM7C,OALAM,EAAOL,KAAON,KAAK6B,IAAIC,EAAMxB,KAAMyB,EAAMzB,MACzCK,EAAOH,MAAQR,KAAK4B,IAAIE,EAAMtB,MAAOuB,EAAMvB,OAC3CG,EAAOF,OAAST,KAAK6B,IAAIC,EAAMrB,OAAQsB,EAAMtB,QAC7CE,EAAOD,IAAMV,KAAK4B,IAAIE,EAAMpB,IAAKqB,EAAMrB,KAEhCC,CACR,CAEGqB,YACF,OAAOrE,KAAK6C,MAAQ7C,KAAK2C,IAC1B,CAEG2B,aACF,OAAOtE,KAAK+C,IAAM/C,KAAK8C,MACxB,ECnHH,MAAMyB,EAAc,CAClB,QACA,UACA,QACA,WACA,SACA,aACA,SAGIC,EAAiB,CAAA,EACvB,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAYG,OAAQD,IACtCD,EAAeD,EAAYE,IAAM,GAAKA,ECXxC,MAIME,EAAuB,CAACC,EAAUrD,EAAKD,KAC3C,MAAMuD,QAAEA,GAAYD,EAASE,QACvBC,EAAgBF,EAAQG,SAK9B,GAHA1D,EAAI,GAAKC,EAAI,GACbD,EAAI,GAAKC,EAAI,GAEmC,IAA3CwD,EAAgBP,EAAeS,QAAe,CAEjD,MAAMC,EAAe7C,KAAK6B,IACxB,EACA7B,KAAK4B,IAAI5B,KAAKsB,MAAMtB,KAAKe,IAAIyB,EAAQI,OAAS,IAAM,GAAK,IAAM,MAGjE3D,EAAI,GAAM4D,EAAe5D,EAAI,GAAM,EACnCA,EAAI,GAAM4D,EAAe5D,EAAI,GAAM,CACpC,CAED,GAAkD,IAA7CyD,EAAgBP,EAAeW,UAAiB,CAEnD,MAAMC,EAAOR,EAASS,iBAChBC,EAAWF,EAAKf,OAAsC,GAA7BhC,KAAKe,IAAIyB,EAAQM,WAC1CI,EAAWH,EAAKd,QAAuC,GAA7BjC,KAAKe,IAAIyB,EAAQM,WAEjD7D,EAAI,IAAMe,KAAKsB,MAAMrC,EAAI,GAAKgE,GA5BnB,IA4ByCA,EACpDhE,EAAI,IAAMe,KAAKsB,MAAMrC,EAAI,GAAKiE,GA7BnB,IA6ByCA,CACrD,CAED,GAA+C,IAA1CR,EAAgBP,EAAegB,OAAc,CAEhD,MAAMC,EAAc,oBAEdC,EAAUpE,EAAI,GApCT,GAqCLqE,EAAUrE,EAAI,GArCT,GAuCLsE,EAAevD,KAAKwD,KAAKH,EAAUA,EAAUC,EAAUA,GACvDG,EAAczD,KAAK6B,IAAI,EAAmB,EAAf0B,EAAkB,GAE7CJ,GAASX,EAAQW,MAAQC,EAAcK,EAAcA,EAGrD1D,EAAIC,KAAKC,IAAIkD,GACbjD,EAAIF,KAAKG,IAAIgD,GAGnBlE,EAAI,GAAKiB,EAAImD,EAAUtD,EAAIuD,EAjDhB,GAkDXrE,EAAI,IAAMc,EAAIsD,EAAUnD,EAAIoD,EAlDjB,EAmDZ,CAED,GAAiD,IAA5CZ,EAAgBP,EAAeuB,SAAgB,CAElD,MAAMC,GAAQ1E,EAAI,GAvDP,OAwDL2E,GAAQ3E,EAAI,GAxDP,OA0DL4E,EAAM7D,KAAKwD,KAAKG,EAAOA,EAAOC,EAAOA,GAzD/B,KA2DNE,EAAS9D,KAAK6B,IAAI,GAAIW,EAAQkB,QAAU,KAAO,KAE/CK,EAAI/D,KAAKgE,IAAIhE,KAAK4B,IAAIiC,EAAK,GAAIC,GAAU9D,KAAK6B,IAAI,EAAGgC,GAErDI,EAAQN,EAAOE,EACfK,EAAQN,EAAOC,EAErB5E,EAAI,GAnEO,GAmEO8E,EAAIE,EAnEX,GAoEXhF,EAAI,GApEO,GAoEO8E,EAAIG,EApEX,EAqEZ,CAED,OAAOjF,CAAG,ECzEN0C,EAAQ,CAACwC,EAAGvC,EAAKC,IAAQ7B,KAAK6B,IAAID,EAAK5B,KAAK4B,IAAIC,EAAKsC,IAG3D,SAASC,EAASL,EAAGM,EAAGC,GACtBP,GAAK,IACLM,GAAK,IACLC,GAAK,IAEL,MAAMzC,EAAM7B,KAAK6B,IAAIkC,EAAGM,EAAGC,GAErBC,EAAQ1C,EADF7B,KAAK4B,IAAImC,EAAGM,EAAGC,GAG3B,IAAIE,EAAI,EACM,IAAVD,IAEO1C,IAAQkC,EACjBS,IAAOH,EAAIC,GAAKC,EAAQ,GAAK,EAAK,EACzB1C,IAAQwC,EACjBG,IAAOF,EAAIP,GAAKQ,EAAQ,GAAK,EAAK,EACzB1C,IAAQyC,IACjBE,IAAOT,EAAIM,GAAKE,EAAQ,GAAK,EAAK,IAGpC,IAAIxE,EAAI,EAOR,OANY,IAAR8B,IACF9B,EAAIwE,EAAQ1C,GAKP,CACL2C,EAAO,IAAJA,EACHzE,EAAO,IAAJA,EACH0E,EAAO,IALD5C,EAOV,CAGA,SAAS6C,EAASF,EAAGzE,EAAG0E,GACtBD,EAAKA,EAAI,IAAO,IAIhB,MAAMtE,GAFNuE,GAAK,MADL1E,GAAK,KAICZ,EAAIe,GAAK,EAAIF,KAAKe,IAAMyD,EAAI,GAAM,EAAK,IAEvC5C,EAAM6C,EAAIvE,EAEhB,IAAI6D,EAAInC,EACJyC,EAAIzC,EACJ0C,EAAI1C,EAsBR,OApBI4C,EAAI,IACNT,GAAK7D,EACLmE,GAAKlF,GACIqF,EAAI,KACbH,GAAKnE,EACL6D,GAAK5E,GACIqF,EAAI,KACbH,GAAKnE,EACLoE,GAAKnF,GACIqF,EAAI,KACbF,GAAKpE,EACLmE,GAAKlF,GACIqF,EAAI,KACbF,GAAKpE,EACL6D,GAAK5E,GACIqF,EAAI,MACbT,GAAK7D,EACLoE,GAAKnF,GAGA,CACL4E,EAAO,IAAJA,EACHM,EAAO,IAAJA,EACHC,EAAO,IAAJA,EAEP,CAEe,MAAMK,EACnBpH,YAAYiH,EAAI,EAAGzE,EAAI,EAAG0E,EAAI,EAAGG,EAAI,GACnCjH,KAAK6G,EAAIA,EACT7G,KAAKoC,EAAIA,EACTpC,KAAK8G,EAAIA,EACT9G,KAAKiH,EAAIA,CACV,CAED/F,WAAWkF,EAAGM,EAAGC,EAAGM,EAAI,GACtB,MAAMJ,EAAEA,EAACzE,EAAEA,EAAC0E,EAAEA,GAAML,EAASL,EAAGM,EAAGC,GACnC,OAAO,IAAIK,EAAMH,EAAGzE,EAAG0E,EAAGG,EAC3B,CAED/F,WAAW2F,EAAGzE,EAAG0E,EAAGG,EAAI,GACtB,OAAO,IAAID,EAAMH,EAAGzE,EAAG0E,EAAGG,EAC3B,CAED/F,WAAWsF,GAKT,MAAMS,GAJNT,EAAIU,OAAOV,KAIK,GAAM,IAChBJ,EAAKI,GAAK,GAAM,IAChBE,EAAKF,GAAK,EAAK,IACfG,EAAQ,IAAJH,EACV,OAAOQ,EAAMG,IAAIf,EAAGM,EAAGC,EAAGM,EAAI,EAAIA,EAAI,IAAM,EAC7C,CAGGb,QACF,OAAOW,EAAS/G,KAAK6G,EAAG7G,KAAKoC,EAAGpC,KAAK8G,GAAGV,CACzC,CACGA,MAAEA,GACJpG,KAAKoH,QAAQhB,EAAGpG,KAAK0G,EAAG1G,KAAK2G,EAC9B,CAGGD,QACF,OAAOK,EAAS/G,KAAK6G,EAAG7G,KAAKoC,EAAGpC,KAAK8G,GAAGJ,CACzC,CACGA,MAAEA,GACJ1G,KAAKoH,QAAQpH,KAAKoG,EAAGM,EAAG1G,KAAK2G,EAC9B,CAGGA,QACF,OAAOI,EAAS/G,KAAK6G,EAAG7G,KAAKoC,EAAGpC,KAAK8G,GAAGH,CACzC,CACGA,MAAEA,GACJ3G,KAAKoH,QAAQpH,KAAKoG,EAAGpG,KAAK0G,EAAGC,EAC9B,CAGGM,QACF,OAAOjH,KAAKqH,EACb,CACGJ,MAAEA,GACJjH,KAAKqH,GAAKrD,EAAMiD,EAAG,EAAG,EACvB,CAGGJ,QACF,OAAO7G,KAAKsH,EACb,CACGT,MAAEA,GACJ7G,KAAKsH,IAAOT,EAAI,IAAO,KAAO,GAC/B,CAGGzE,QACF,OAAOpC,KAAKuH,EACb,CACGnF,MAAEA,GACJpC,KAAKuH,GAAKvD,EAAM5B,EAAG,EAAG,IACvB,CAGG0E,QACF,OAAO9G,KAAKwH,EACb,CACGV,MAAEA,GACJ9G,KAAKwH,GAAKxD,EAAM8C,EAAG,EAAG,IACvB,CAEDM,QAAQhB,EAAGM,EAAGC,GACZP,EAAIpC,EAAMoC,EAAG,EAAG,KAChBM,EAAI1C,EAAM0C,EAAG,EAAG,KAChBC,EAAI3C,EAAM2C,EAAG,EAAG,KAEhB,MAAME,EAAEA,EAACzE,EAAEA,EAAC0E,EAAEA,GAAML,EAASL,EAAGM,EAAGC,GAEnC3G,KAAK6G,EAAIA,EACT7G,KAAKoC,EAAIA,EACTpC,KAAK8G,EAAIA,CACV,CAEDW,YAAYC,GAAoB,GAC9B,MAAMC,EAAcnB,IAGlB,IAAIoB,GAFJpB,EAAIxC,EAAM3B,KAAKwF,MAAMrB,GAAI,EAAG,MAEhBsB,SAAS,IAKrB,OAJmB,IAAfF,EAAIlD,SACNkD,EAAM,IAAMA,GAGPA,CAAG,EAGZ,IAAIG,EAAM,IAAM,CAAC/H,KAAKoG,EAAGpG,KAAK0G,EAAG1G,KAAK2G,GAAGqB,IAAIL,GAAaM,KAAK,IAK/D,OAJIP,GAAgC,IAAX1H,KAAKiH,KAC5Bc,GAAOJ,EAAqB,IAAT3H,KAAKiH,IAGnBc,CACR,CAEDG,YAAYR,GAAoB,GAC9B,MAAMP,EAAM,CAACnH,KAAKoG,EAAGpG,KAAK0G,EAAG1G,KAAK2G,GAAGqB,IAAI3F,KAAKwF,OAE9C,OAAIH,GAAgC,IAAX1H,KAAKiH,EACrB,QAAQE,EAAIc,KAAK,UAAUjI,KAAKiH,KAElC,OAAOE,EAAIc,KAAK,QACxB,CAEDE,SACE,MAAMhB,EAAMJ,EAAS/G,KAAKsH,GAAItH,KAAKuH,GAAIvH,KAAKwH,IAC5C,MAAO,CAACL,EAAIf,EAAGe,EAAIT,EAAGS,EAAIR,EAAa,IAAV3G,KAAKqH,GACnC,CAEDe,mBACE,MAAMjB,EAAMJ,EAAS/G,KAAKsH,GAAItH,KAAKuH,GAAIvH,KAAKwH,IAC5C,MAAO,CAACL,EAAIf,EAAI,IAAKe,EAAIT,EAAI,IAAKS,EAAIR,EAAI,IAAK3G,KAAKqH,GACrD,CAEDS,WACE,OAAO9H,KAAKkI,aACb;;;;;;;;;;;;;;;;;;;;;;GCjMH,MAAMG,EAAc,CAClB,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAC7G,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC9G,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC5G,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAC3G,OAGIC,EAAc,EAAE,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAE3D,SAASC,EAAiBC,EAAIC,GAC3C,MAAMC,EAAK,IAAIC,SAASH,GAExB,GAAwB,aAApBE,EAAGE,UAAU,IAAyC,aAApBF,EAAGE,UAAU,GACjD,OAAO/H,QAAQgI,OAAO,IAAIC,MAAM,8BAGlC,MAAMC,EAAS,CAAA,EACTC,EAAIN,EAAGO,WAAa,EAC1B,IAAIxE,EAAI,GACR,KAAOA,EAAIuE,GACTD,EACEG,OAAOC,aACLT,EAAGU,SAAS3E,GACZiE,EAAGU,SAAS3E,EAAI,GAChBiE,EAAGU,SAAS3E,EAAI,GAChBiE,EAAGU,SAAS3E,EAAI,KAEhBA,EACJA,GAAK,EAAIiE,EAAGE,UAAUnE,EAAI,GAAG,GAG/B,MAAM4E,EAASX,EAAGY,UAAU,IAAI,GAC1BC,EAAab,EAAGE,UAAU,IAAI,GAEpC,GAAe,KAAXS,EAAe,CACjB,MACMG,GADkBd,EAAGY,UAAU,IAAI,GACJ,GAAK,EAAI,EAExCG,EAAaf,EAAGE,UAAUG,EAAOW,KAAO,GAAG,GAE3CC,EAASlB,EAAamB,aAAa,EAAGH,EAAYF,GAClDM,EAAUF,EAAOG,eAAe,GAEtC,IAAIC,EAEAhJ,EAAMiJ,EAAMpD,EADZqD,EAAQ,EAERC,GAAY,EAEhB,MAAMC,EAASpB,EAAOqB,KAAO,EAC7B,IAAI3F,EAAI0F,EACJE,EAAI,EAER,OACE,IAAK5F,EAAI0F,GAAUX,GAAc,GAAKU,EAAW,EAAG,CAClD,GAAIzF,GAAKiE,EAAGO,WAAY,MACxBc,EAASrB,EAAG4B,SAAS7F,GAAG,GACxBA,GAAK,EACLwF,EAAQvB,EAAGU,SAAS3E,GACpBA,GAAK,EACLA,IACIwF,EAAQ,KAAIA,EAAQ,IACxBJ,EAAQQ,KAAON,EAAS,KAChC,KAAa,CACL,GAAIG,EAAW,EAAG,CAChB,GAAIzF,GAAKiE,EAAGO,WAAY,MACxBiB,EAAWxB,EAAGU,SAAS3E,GACvBA,GAAK,EACLuF,EAAkB,GAAXE,CACjB,MACUF,EAAQE,GAAY,EAAK,GACzBA,GAAY,EAEdnJ,EAAOsH,EAAY4B,GACnBrD,EAAQ,EACG,EAAPoD,IAAUpD,GAAS7F,GACZ,EAAPiJ,IAAUpD,GAAS7F,GAAQ,GACpB,EAAPiJ,IAAUpD,GAAS7F,GAAQ,GAC/B6F,GAAS7F,GAAQ,EACjBkJ,GAAS3B,EAAY0B,GACjBC,EAAQ,KAAIA,EAAQ,IACpBA,EAAQ,IAAGA,EAAQ,GACvBF,GAAiB,EAAPC,GAAYpD,EAAQA,EAC1BmD,EAAS,QAAOA,EAAS,OACzBA,GAAU,QAAOA,GAAU,OAC/BF,EAAQQ,KAAON,EAAS,KACzB,CAEH,OAAOlJ,QAAQC,QAAQ6I,EACxB,CACD,OAAO9I,QAAQgI,OAAO,IAAIC,MAAM,2BAA2BO,KAC7D,CASO,SAASkB,EAAYC,GAC1B,MACMnB,EADW,IAAIV,SAAS6B,GACNlB,UAAU,IAAI,GACtC,OAVK,SAAmBkB,GACxB,MAAMC,EAAW,IAAI9B,SAAS6B,GAC9B,OAC4B,aAA1BC,EAAS7B,UAAU,IAA+C,aAA1B6B,EAAS7B,UAAU,EAE/D,CAKS8B,CAAUF,IAA2B,KAAXnB,CACnC,CC9He,MAAMsB,EACnB/K,YAAYgL,EAAMC,GAChB7K,KAAK4K,KAAOA,EACZ5K,KAAK6K,IAAMA,EAEX7K,KAAK8K,YAAc,KACnB9K,KAAK+K,OAAS,KACd/K,KAAKgL,aAAe,EAGpBhL,KAAKiL,uBACN,CAEGC,eACF,OAAOlL,KAAK8K,YAAYI,QACzB,CAEDzK,SACE,IAAI0K,GAAU,EACVC,GAAsB,EAM1B,GAJIpL,KAAKqL,WACPrL,KAAKqL,YAGHrL,KAAK8K,YACP9K,KAAKsL,oBACLH,GAAU,MACL,CAsBL,MAAMI,EAAqBvL,KAAKwL,iBAChCxL,KAAKwL,iBAAmBC,IAClBA,EACFL,GAAsB,GAEtBpL,KAAKsL,oBACLH,GAAU,SACHnL,KAAKwL,kBAEVD,GACFA,GAAmB,EACpB,CAEJ,CAED,MAAQJ,GAAWC,SAEnB,OAAOA,CACR,CAEDM,iBACE,IAAIC,GAAU,EAEd,MAAMP,QAA6BpL,KAAKS,QAIxC,GAAKT,KAAK8K,cAIV9K,KAAK+K,OAAOa,iBAAiB,SAAS,KACpCD,GAAU,SACH3L,KAAKqL,SAAS,IAKlBD,GAcL,IALApL,KAAKqL,UAAY,KACfM,GAAU,SACH3L,KAAKqL,SAAS,EAGhBM,QACR,CAEDxL,OACMH,KAAKqL,WACPrL,KAAKqL,YAGHrL,KAAK+K,SACP/K,KAAK+K,OAAOc,aACZ7L,KAAK+K,OAAS,KAEjB,CAEDE,wBACE,OAAOa,MAAM9L,KAAK6K,KACfkB,MAAKC,GAAQA,EAAKxB,gBAClBuB,MAAKvB,GACAD,EAAYC,GACPjC,EAAiBiC,EAAaG,EAAMlC,cAAcwD,OACvDC,IACEC,QAAQC,KACN,yBAAyBpM,KAAK4K,2BAA6BsB,GAEtD,QAIJ,IAAIrL,SAAQ,CAACC,EAAS+H,KAC3B8B,EAAMlC,aAAa4D,gBAAgB7B,EAAa1J,EAAS+H,EAAO,MAIrEkD,MAAKjB,IACJ9K,KAAK8K,YAAcA,EACf9K,KAAKwL,kBACPxL,KAAKwL,mBAEAV,IAEZ,CAEDQ,oBACOtL,KAAK8K,cAIN9K,KAAK+K,QACP/K,KAAK+K,OAAOc,aAGd7L,KAAK+K,OAASJ,EAAMlC,aAAa6D,qBACjCtM,KAAK+K,OAAOpB,OAAS3J,KAAK8K,YAC1B9K,KAAK+K,OAAOC,aAAauB,MAAQvM,KAAKgL,aAElChL,KAAKM,QACPN,KAAK+K,OAAOyB,QAAQxM,KAAKM,QAG3BN,KAAK+K,OAAOtK,MAAMkK,EAAMlC,aAAagE,aACtC,CAEDD,QAAQlM,GACFA,IAAWN,KAAKM,SAClBN,KAAKM,OAASA,EACVN,KAAK+K,SACP/K,KAAK+K,OAAOc,aACZ7L,KAAK+K,OAAOyB,QAAQxM,KAAKM,SAG9B,CAEDoM,gBAAgBH,GACdvM,KAAKgL,aAAeuB,EAChBvM,KAAK+K,SACP/K,KAAK+K,OAAOC,aAAauB,MAAQA,EAEpC,CAEDI,cAAcrM,GACZ,OAAON,KAAKM,SAAWA,CACxB,CAIUmI,0BAET,OADAzI,KAAK4M,qBACE5M,KAAK6M,aACb,CAED3L,4BACE,IAAKlB,KAAK6M,cAAe,CACvB,MAAMC,EAAeC,OAAOD,cAAgBC,OAAOC,mBACnDhN,KAAK6M,cAAgB,IAAIC,CAC1B,CACF,CAED5L,wBAAwB4J,GACtB,OAAOvC,EAAiBuC,EAAa9K,KAAKyI,aAC3C,EAGI,MAAMwE,EAOXrN,YAAYsN,GACV,MAAMC,qBAAEA,GAAyBD,EACjClN,KAAKkN,OAASA,EAEdlN,KAAKoN,UAAYzC,EAAMlC,aAAa4E,aAUpCrN,KAAKsN,YAAc,GAEnBtN,KAAKuN,iBAELvN,KAAKmN,qBAAuBA,CAC7B,CAEDI,iBAKE,MAAMC,EAAWP,EAAYQ,yBAC7B,GAAIzN,KAAK0N,aACP,IAAK,MAAO9C,EAAM+C,KAAiBC,OAAOC,QACxCZ,EAAYQ,2BAEwC,IAAhDR,EAAYa,oBAAoBlD,GAAMmD,OACxC/N,KAAKgO,eAAepD,EAAM+C,QAI9B3N,KAAK0N,aAAeF,CAEvB,CAEDS,kBAAkBrD,GAChB,MAAMsD,EAAajB,EAAYa,oBAAoBlD,GAEnD,IAAKsD,EACH,OAKF,MAAM3B,EAAQvM,KAAK0N,aAAa9C,GAEhC,GAAIsD,EAAWC,QAAS,CAKtB,IAAInN,EAAOkN,EACX,GACElN,EAAOiM,EAAYmB,wBAAwBpN,EAAK4J,YACzC5J,IAAShB,KAAKsN,YAAYtM,EAAK4J,OAExC,IAAIyD,EAAWH,EACf,GACEG,EAAWpB,EAAYqB,4BAA4BD,EAASzD,YACrDyD,IAAarO,KAAKsN,YAAYe,EAASzD,OAQ5C5J,IACFA,EAAOhB,KAAKsN,YAAYtM,EAAK4J,OAG3ByD,IACFrN,EAAOhB,KAAKsN,YAAYe,EAASzD,OAkB9ByD,IACHA,EAAW,CAAEE,OAAQvO,KAAKoN,aAGvBpM,GAAQhB,KAAKM,SAChBU,EAAO,CAAEwN,MAAOxO,KAAKM,SAUvB,IAAImO,EAAQzO,KAAKsN,YAAYY,EAAWtD,MAmBxC,GAlBK6D,GAASlC,IAAU2B,EAAWQ,UACjCD,EAAQP,EAAWS,YACnB3O,KAAKsN,YAAYY,EAAWtD,MAAQ6D,EAMpCJ,EAASE,OAAO1C,aAChBwC,EAASE,OAAO/B,QAAQiC,EAAMD,OAI1BxN,GACFyN,EAAMF,OAAO/B,QAAQxL,EAAKwN,QAI1BjC,IAAU2B,EAAWQ,SAMvB,GAAID,EAAO,CAMT,IAAK,MAAMG,KAAQ,IAAIC,IAAIjB,OAAOkB,OAAOL,IACvCG,EAAK/C,aAMH7K,GACFqN,EAASE,OAAO/B,QAAQxL,EAAKwN,cAOxBxO,KAAKsN,YAAY1C,EACzB,OAEDsD,EAAWa,IAAIxC,EAAOkC,EAE9B,MAIM,IAAK,MAAMO,KAAShP,KAAKmN,uBACvBe,EAAWa,IAAIxC,EAAOyC,EAG3B,CAEDxC,QAAQlM,GACNN,KAAKM,OAASA,EAOd,IAAI2O,EAAOhC,EAAYiC,0BACvB,GACED,EAAOhC,EAAYqB,4BAA4BW,EAAKrE,YAC7CqE,IAASjP,KAAKsN,YAAY2B,EAAKrE,OAGtCqE,EADEA,EACKjP,KAAKsN,YAAY2B,EAAKrE,MAEtB,CAAE2D,OAAQvO,KAAKoN,WAGxB6B,EAAKV,OAAO1C,aACZoD,EAAKV,OAAO/B,QAAQlM,EACrB,CAED0N,eAAepD,EAAM2B,GACnBA,EAAQrF,OAAOqF,GAEb3B,KAAQ5K,KAAK0N,eACZyB,MAAM5C,IACPA,IAAUvM,KAAK0N,aAAa9C,KAE5B5K,KAAK0N,aAAa9C,GAAQ2B,EAC1BvM,KAAKoP,iBAAiBxE,GACtB5K,KAAKiO,kBAAkBrD,GAE1B,CAEDyE,kBAAkBzE,EAAM2B,GACtBA,EAAQrF,OAAOqF,GACX3B,KAAQ5K,KAAK0N,eAAiByB,MAAM5C,IAAoB,IAAVA,IAChDvM,KAAK0N,aAAa9C,IAAS2B,EAC3BvM,KAAKoP,iBAAiBxE,GACtB5K,KAAKiO,kBAAkBrD,GAE1B,CAEDwE,iBAAiBxE,GAGf,MAAMsD,EAAajB,EAAYa,oBAAoBlD,GACnD,IAAI2B,EAAQvM,KAAK0N,aAAa9C,GAC1B,YAAasD,GAAc3B,EAAQ2B,EAAWoB,QAChD/C,EAAQ2B,EAAWoB,QACV,YAAapB,GAAc3B,EAAQ2B,EAAWqB,UACvDhD,EAAQ2B,EAAWqB,SAErBvP,KAAK0N,aAAa9C,GAAQ2B,CAC3B,CAEDiD,eAAe5E,GACb,OAAO5K,KAAK0N,aAAa9C,IAAS,CACnC,CAED6E,MAAMC,GACJ,MAAMC,EAAiB,IAAI1C,EACzBW,OAAOgC,OAAO,CAAA,EAAI5P,KAAKkN,OAAQwC,IAGjC,IAAK,MAAO9E,EAAM2B,KAAUqB,OAAOC,QAAQ7N,KAAK0N,cAAe,CAC1CT,EAAYa,oBAAoBlD,GACnCiF,cACdF,EAAe3B,eAAepD,EAAM2B,EAEvC,CAID,OAFAoD,EAAenD,QAAQxM,KAAKM,QAErBqP,CACR,CAEDG,aAAad,GACXA,EAAMxC,QAAQxM,KAAKoN,WAEnB,IAAK,MAAOxC,EAAM2B,KAAUqB,OAAOC,QAAQ7N,KAAK0N,cAAe,CAC7D,MAAMQ,EAAajB,EAAYa,oBAAoBlD,GAC9CsD,EAAWC,SACdD,EAAWa,IAAIxC,EAAOyC,EAEzB,CACF,CAEDe,WAAWf,GACT,OAAOA,EAAMrC,cAAc3M,KAAKoN,UACjC,CAEDlM,gCAIE,MAAMsM,EAAW,CAAA,EACjB,IAAK,MAAM5C,KAAEA,EAAI8D,QAAEA,KAAa1O,KAAKgQ,kBACnCxC,EAAS5C,GAAQ8D,EAEnB,OAAOlB,CACR,CAEDtM,2BAA2B0J,GACzB,OAAO5K,KAAKgQ,kBAAkBC,MAAK/B,GAAcA,EAAWtD,OAASA,GACtE,CAED1J,kCACE,OAAOlB,KAAKgQ,kBAAkB,EAC/B,CAED9O,iCACE,OAAOlB,KAAKgQ,kBAAkBhQ,KAAKgQ,kBAAkBtL,OAAS,EAC/D,CAEDxD,+BAA+B0J,GAU7B,OAAO5K,KAAKgQ,kBACTE,MAAM,GACND,MAAK,CAACE,EAAG1L,IAAMzE,KAAKgQ,kBAAkBvL,GAAGmG,OAASA,GACtD,CAED1J,mCAAmC0J,GAQjC,OAAO5K,KAAKgQ,kBACTE,MAAM,GAAI,GACVD,MAAK,CAACE,EAAG1L,IAAMzE,KAAKgQ,kBAAkBvL,EAAI,GAAGmG,OAASA,GAC1D,EAKHqC,EAAYmD,cAAgB,KAC5BnD,EAAYoD,UAAY,IA2BxBpD,EAAY+C,kBAAoB,CAC9B,CACEpF,KAAM,MACN8D,QAAS,EACTY,SAAU,IACVC,QAAS,IACTpB,SAAS,EACTQ,YACE,MAAM2B,EAAO3F,EAAMlC,aACb+F,EAAQ8B,EAAKjD,aACbkD,EAAWD,EAAKjD,aAChBmD,EAAYF,EAAKjD,aACjBoD,EAAgBH,EAAKI,oBAAoB,GACzCnC,EAASkC,EAKf,OAJAjC,EAAMhC,QAAQ+D,GACd/B,EAAMhC,QAAQgE,GACdD,EAAS/D,QAAQiE,EAAe,EAAG,GACnCD,EAAUhE,QAAQiE,EAAe,EAAG,GAC7B,CAAEjC,QAAOD,SAAQgC,WAAUC,YAAWC,gBAC9C,EACD1B,IAAIxC,GAAOiC,MAAEA,EAAKD,OAAEA,EAAMgC,SAAEA,EAAQC,UAAEA,IACpC,MAAMG,GAAKpE,EAAQ,KAAO,IACpBqE,EAAUvO,KAAKG,IAAKmO,EAAItO,KAAKwO,GAAM,GACnCC,EAAWzO,KAAKC,IAAKqO,EAAItO,KAAKwO,GAAM,IACpCpE,YAAEA,GAAgB9B,EAAMlC,cACxB4H,UAAEA,EAASD,cAAEA,GAAkBnD,EACrCsD,EAASQ,KAAKC,gBACZJ,EACAnE,EAAc4D,EACdD,GAEFI,EAAUO,KAAKC,gBACbF,EACArE,EAAc4D,EACdD,EAEH,GAEH,CACExF,KAAM,QACN8D,QAAS,EACTP,SAAS,EACTY,IAAIxC,EAAOyC,GACT,MAAMiC,EAAW1E,EAAQ,GACnB2E,EAAQ7O,KAAKgE,IAAI,EAAG4K,EAAW,IACrCjC,EAAMtC,gBAAgBwE,EACvB,GAEH,CACEtG,KAAM,SACN8D,QAAS,IACTY,QAAS,EACTC,QAAS,IACT4B,cAAc,EACdtB,cAAc,EACd1B,SAAS,EACTQ,YACE,MAAMC,EAAOjE,EAAMlC,aAAa4E,aAChC,MAAO,CACLmB,MAAOI,EACPL,OAAQK,EACRA,OAEH,EACDG,IAAIxC,GAAOqC,KAAEA,IACXA,EAAKmC,KAAKK,wBACR7E,EAAQ,IACR5B,EAAMlC,aAAagE,YAAcQ,EAAYmD,cAEhD,IAIE,MAAMiB,EAOXzR,YAAY0R,GACVtR,KAAKsR,YAAcA,EAEnB,IAAK,MAAM1G,KAAEA,KAAUqC,EAAY+C,kBACjCpC,OAAO2D,eAAevR,KAAM4K,EAAM,CAChC4G,IAAK,IAAMF,EAAY9B,eAAe5E,GACtCmE,IAAKxC,GAAS+E,EAAYtD,eAAepD,EAAM2B,IAGpD,CAEDkF,QACEzR,KAAKsR,YAAY/D,gBAClB,ECroBH,MAAMmE,EACJ9R,cACEI,KAAKgF,SAAW,EAChBhF,KAAK2R,cAAgB,GAErB,IAAK,IAAIlN,EAAI,EAAGA,EAAIF,EAAYG,OAAQD,IAAK,CAC3C,MAAMmN,EAAarN,EAAYE,GAC/BzE,KAAK2R,cAAcC,GAAc,EAEjChE,OAAO2D,eAAevR,KAAM4R,EAAY,CACtCJ,IAAK,IACIxR,KAAK2R,cAAcC,GAG5B7C,IAAK8C,IACH7R,KAAK2R,cAAcC,GAAcC,EAI/B7R,KAAKgF,SAFK,IAAR6M,EAEc7R,KAAKgF,WAAa,GAAKP,GAGvBzE,KAAKgF,SAAY,GAAKP,CACvC,GAGN,CACF,CAEDqN,SACE,MAAMrP,EAAI,IAAIiP,EACd,IAAK,MAAME,KAAchE,OAAOmE,KAAK/R,KAAK2R,eACxClP,EAAEmP,GAAc5R,KAAK4R,GAEvB,OAAOnP,CACR,CAEDgP,QACE,IAAK,MAAMG,KAAchE,OAAOmE,KAAK/R,KAAK2R,eACxC3R,KAAK2R,cAAcC,GAAc,EAEnC5R,KAAKgF,SAAW,CACjB,EAGH,MAAMgN,EACJpS,YAAYqS,EAAmBC,EAAO,IACpClS,KAAKmS,SAAW,KAEhB,MAAMC,cAAEA,EAAaC,WAAEA,EAAa,GAAMJ,EAC1CjS,KAAKsS,eAAiBF,EACtBpS,KAAKuS,YAAcF,EAEnBrS,KAAKwS,SAAW,GAChBxS,KAAKyS,SAAW,GAChBzS,KAAK0S,SAAW,GAChB1S,KAAK2S,OAAS,GAEd3S,KAAKsR,YAAc,IAAIrE,EAAY,CACjCE,qBAAsBnN,KAAK4S,oBAAoBjS,KAAKX,QAEtDA,KAAKsR,YAAY9E,QAAQ7B,EAAMlC,aAAaoK,aAE5C7S,KAAK6E,QAAU,IAAI6M,EACnB1R,KAAK8S,aAAe,IAAIzB,EAAerR,KAAKsR,aAE5CtR,KAAK+S,MAAQb,CACd,CAEDU,sBACE,OAAO5S,KAAK2S,OAAOK,QAAOhE,GAAShP,KAAKsR,YAAYvB,WAAWf,IAChE,CAEGiE,YACF,OAAOjT,KAAKmS,SAASc,KACtB,CAEGC,cACF,OAAOlT,KAAKmS,SAASe,OACtB,CAEGhB,WACF,OAAOlS,KAAK+S,KACb,CAEGX,oBACF,OAAOpS,KAAKsS,cACb,CAEGF,kBAAce,GAChBnT,KAAKsS,eAAiBtS,KAAKoT,UAAUD,EAAQ,EAAGnT,KAAK0S,SAAShO,QAC1D1E,KAAKqT,qBAAqBrT,KAAKqT,qBACpC,CAEGC,YAAQA,GAIV,GAHuB,iBAAZA,IACTtT,KAAKoS,cAAgBkB,GAEA,iBAAZA,EAAsB,CAC/B,MAAMrJ,EAAQjK,KAAK0S,SAASa,WAAUhR,GAAKA,EAAEqI,OAAS0I,IACtD,GAAIrJ,GAAS,EACXjK,KAAKoS,cAAgBnI,EAAQ,OAE7B,OAAQqJ,GACN,IAAK,eACL,IAAK,gBACHtT,KAAKoS,cAAgBpS,KAAKoS,cAAgB,EAC1C,MAGF,IAAK,mBACL,IAAK,oBACHpS,KAAKoS,cAAgBpS,KAAKoS,cAAgB,EAC1C,MAGF,IAAK,iBACL,IAAK,kBAAmB,CAGtB,MAAMoB,EAAQ,EACRC,EAAQzT,KAAK0S,SAAShO,OACtBgP,EAAW1T,KAAKoS,cAEhBuB,EAAkBF,EAAQD,EAChC,IAAII,EAAUJ,EAAQnR,KAAKsB,MAAMtB,KAAKwR,SAAWF,GAC7CC,GAAWF,GACbE,IAGF5T,KAAKoS,cAAgBwB,EACrB,KACD,CAED,QACQzE,MAAMmE,IAAsC,IAA1BA,EAAQQ,OAAOpP,SACrC1E,KAAKoS,cAAgBlL,OAAOoM,IAKrC,CACF,CAEGA,cACF,OAAOtT,KAAK0S,SAAS1S,KAAKoS,cAAgB,EAC3C,CAED2B,UAAUxH,EAAQ3J,KACK,iBAAV2J,EACTvM,KAAKmS,SAAS6B,kBAAkBhU,KAAMuM,GAEtCvM,KAAKmS,SAAS6B,kBAAkBhU,KAAM,EAAGuM,EAE5C,CAED0H,WAAW1H,EAAQ3J,KACI,iBAAV2J,EACTvM,KAAKmS,SAAS6B,kBAAkBhU,MAAOuM,GAEvCvM,KAAKmS,SAAS6B,kBAAkBhU,MAAO,EAAGuM,EAE7C,CAED2H,SAASC,GACP,OAAQA,EAAM9R,KAAKwO,GAAM,GAC1B,CAEDuD,SAASjS,GACP,OAAc,IAANA,EAAaE,KAAKwO,EAC3B,CAEDwD,aAAaF,GACX,OAAc,GAANA,CACT,CAEDG,aAAaC,GACX,OAAqB,GAAbA,CACT,CAEDC,aAAarS,GACX,OAAOnC,KAAKqU,aAAarU,KAAKoU,SAASjS,GACxC,CAEDsS,aAAaF,GACX,OAAOvU,KAAKkU,SAASlU,KAAKsU,aAAaC,GACxC,CAGDG,WAAWC,GAET,OADAA,GAAgB,KAEd,KAAM,IACN,KAAK,GACH,OAAO/R,IACT,KAAM,GACN,KAAK,IACH,OAAQA,IACV,QACE,OAAOgS,WAAWvS,KAAKwS,IAAKxS,KAAKwO,GAAK8D,EAAS,KAAKG,QAAQ,KAEjE,CAGDC,aAAaZ,GAIX,QAAWA,EAAM,KAAO,IAAO,KAAO,IAAO,GAC9C,CAODf,UAAU5M,EAAGvC,EAAKC,GAChB,MAAM8Q,EAAS9Q,EAAMD,EAAO,EAC5B,OAAOuC,EAAKnE,KAAKsB,OAAO6C,EAAIvC,GAAO+Q,GAASA,CAC7C,CAGDC,KAAKC,GACH,MAAMC,EAAQD,EAAUvU,KAAKX,MAC7B,MAAO,IAAIoV,KACT,MAAMC,EAAOF,KAASC,GACtB,MAAQC,EAAKrU,OAAOd,OAAK,CAE5B,CAED2T,OAAO5M,EAAGN,GACR,MAAM1C,EAAM5B,KAAK4B,IAAIgD,EAAGN,GAClBzC,EAAM7B,KAAK6B,IAAI+C,EAAGN,GACxB,OAAI1C,EAAM,GAAM,GAAKC,EAAM,GAAM,EACxB7B,KAAKsB,MAAMtB,KAAKwR,UAAY3P,EAAMD,EAAM,IAAMA,EAEhD5B,KAAKwR,UAAY3P,EAAMD,GAAOA,CACtC,CAEDqR,MAAMC,GACJ,IAAIC,EAAU,IAAIC,KAElB,IADAD,EAAQE,gBAAgBF,EAAQG,kBAA2B,IAAPJ,GAC7C,IAAIE,KAASD,QAGrB,CAEGI,YACF,OAAO5V,KAAKmS,SAAS3D,MAAMoH,KAC5B,CAEDC,WAAWjL,GACT,OAAO5K,KAAKmS,SAAS3D,MAAMqH,WAAWjL,EACvC,CAEGkL,YACF,OAAO9V,KAAKmS,SAAS2D,KACtB,CAEDC,eACE/V,KAAKmS,SAAS4D,cACf,CAEDC,YAAYC,GACV,MAAMjH,EAAQhP,KAAKkW,SAASD,GACxBjH,IACFhP,KAAKsR,YAAYxB,aAAad,SACvBA,EAAMvO,QAEhB,CAED0V,oBAAoBF,GAClB,MAAMjH,EAAQhP,KAAKkW,SAASD,GACxBjH,IACFA,EAAMxC,QAAQxM,KAAKsR,YAAYlE,WAC/BpN,KAAKsR,YAAYxB,aAAad,SACvBA,EAAMtD,gBAEhB,CAEDwK,SAASD,GACP,MAAyB,iBAAdA,EACFjW,KAAK2S,QAAQsD,EAAY,GAAKjW,KAAK2S,OAAOjO,QAE1C1E,KAAK2S,OAAO1C,MAAK7N,GAAKA,EAAEwI,OAASqL,GAE3C,CAEDG,gBACEpW,KAAKmS,SAASiE,eACf,CAEDC,oBACE,IAAK,MAAMrH,KAAShP,KAAK2S,OACvB3D,EAAM7O,MAET,CAEDmW,UAAU1L,GACR,OAAO5K,KAAKmS,SAASoE,YAAY5W,EAAQN,UAAW,CAAEuL,QACvD,CAED4L,kBAAkB5L,GAChB,IAAI6L,GAAU,EAKd,IAJAzW,KAAKsW,UAAU1L,GAAMmB,MAAK,KACxB0K,GAAU,CAAK,IAGVA,QAGR,CAEDC,WACE1W,KAAKmS,SAASwE,SAASD,UACxB,CAEDE,YAAYC,GACN7W,KAAK8W,eACP9W,KAAK+W,IAAI,IAGX,IAAI7W,GAAO,EAKX,IAJAF,KAAKmS,SAASyE,WAAWC,GAAU9K,MAAK,KACtC7L,GAAO,CAAI,KAGLA,QACT,CAEG8W,aACF,OAAOhX,KAAKmS,SAAS6E,MACtB,CAEGC,eACF,OAAOjX,KAAKmS,SAAS8E,QACtB,CAEDC,SAAS3K,GACP,GAAqB,iBAAVA,EACT,OAAI4C,MAAM5C,GACD,EAEFA,EAGT,MAAM/F,EAAIU,OAAOqF,GACjB,OAAIrF,OAAOiI,MAAM3I,GACR,EAEFA,CACR,CAED2Q,UAAU5K,GACR,MAAqB,kBAAVA,EACFA,EAGY,iBAAVA,EACK,KAAVA,GAA0B,MAAVA,GAAyC,UAAxBA,EAAM6K,cAMtCC,QAAQ9K,EAChB,CAEDzE,SAASyE,GACP,OAAOrD,OAAOqD,EACf,CAED+K,eAAeC,EAAQC,GACrB,OAAOD,EAAOH,cAAcK,SAASD,EAAUJ,cAChD,CAEDM,cAAcC,EAAOpL,GACnB,OAAOoL,EAAMC,MAAKC,GAAsC,IAA9B7X,KAAK8X,QAAQD,EAAMtL,IAC9C,CAEDwL,SAASR,EAAQtN,GACf,OAAIA,EAAQ,GAAKA,GAASsN,EAAO7S,OACxB,GAEF6S,EAAOtN,EACf,CAED+N,OAAOL,EAAO1N,GACZ,OAAIA,EAAQ,GAAKA,GAAS0N,EAAMjT,OACvB,GAEFiT,EAAM1N,EACd,CAEDgO,aAAaN,EAAOpL,GAClB,OAAOoL,EAAMpE,WAAUsE,GAAsC,IAA9B7X,KAAK8X,QAAQD,EAAMtL,IACnD,CAEDuL,QAAQI,EAAIC,GACV,GAAID,IAAOC,EACT,OAAO,EAGT,IAAIC,EAAKlR,OAAOgR,GACZG,EAAKnR,OAAOiR,GAChB,GACGC,IAAOxV,KAAYyV,IAAOzV,KAC1BwV,KAAQxV,KAAYyV,KAAQzV,IAE7B,OAAO,EAST,GANW,IAAPwV,IAAoB,OAAPF,GAA6B,iBAAPA,GAAwC,IAArBA,EAAGpE,OAAOpP,QAClE0T,EAAKE,IACW,IAAPD,IAAoB,OAAPF,GAA6B,iBAAPA,GAAwC,IAArBA,EAAGrE,OAAOpP,UACzE2T,EAAKC,MAGFnJ,MAAMiJ,KAAQjJ,MAAMkJ,GACvB,OAAOD,EAAKC,EAGd,MAAME,EAAKrP,OAAOgP,GAAId,cAChBoB,EAAKtP,OAAOiP,GAAIf,cAEtB,OAAImB,IAAOC,EACF,EACED,EAAKC,GACN,EAED,CAEV,EAGI,MAAMC,UAAezG,EAC1BpS,YAAYqS,KAAsBmD,GAChCsD,MAAMzG,KAAsBmD,GAE5B,MAAM5T,EACJA,EAACC,EACDA,EAACkX,UACDA,EAASC,cACTA,EAAaxG,cACbA,EAAayG,KACbA,EAAIC,QACJA,EAAOC,QACPA,EAAOC,QACPA,EAAOC,SACPA,GACEhH,EAEJjS,KAAKkZ,GAAK1X,EACVxB,KAAKmZ,GAAK1X,EACVzB,KAAKoZ,WAAaT,EAClB3Y,KAAK4Y,cAAgBA,GAAiBH,EAAOY,cAAcC,WAC3DtZ,KAAKsS,eAAiBF,EACtBpS,KAAK6Y,KAAOA,EACZ7Y,KAAK8Y,QAAUA,EAEf9Y,KAAKuZ,OAAS,KACdvZ,KAAKwZ,OAAS,GAEdxZ,KAAKyZ,SAAWV,IAAW,EAC3B/Y,KAAKgZ,QAAUA,GAAW,EAC1BhZ,KAAK0Z,UAAYT,GAAYjS,EAAMG,IAAI,EAAG,EAAG,KAE7CnH,KAAK8W,cAAgB,CACnB6C,KAAM,GACNC,MAAO,MACPC,QAAS,KAEZ,CAEDC,cACE,MAAMrK,EAAQ7B,OAAOgC,OACnBhC,OAAOmM,OAAOnM,OAAOoM,eAAeha,OACpCA,MAGFyP,EAAM0C,SAAWnS,KAAKmS,SACtB1C,EAAM+C,SAAWxS,KAAKwS,SAASxK,KAC7BnI,GAAW,IAAIF,EAAQE,EAAQA,QAASA,EAAQC,QAASD,EAAQI,WAEnEwP,EAAMiD,SAAW1S,KAAK0S,SACtBjD,EAAMkD,OAAS3S,KAAK2S,OACpBlD,EAAMsD,MAAQnF,OAAOgC,OAAO,CAAA,EAAI5P,KAAK+S,OAErCtD,EAAMqH,cAAgB,CACpB6C,KAAM,GACNC,MAAO,MACPC,QAAS,MAGXpK,EAAM5K,QAAU7E,KAAK6E,QAAQiN,SAI7B,IAAImI,EAAWja,KACf,KAAOia,EAASV,QACdU,EAAWA,EAASV,OAEtB9J,EAAM6B,YAAc2I,EAAS3I,YAAY7B,MAAM,CAC7CtC,qBAAsBsC,EAAMmD,oBAAoBjS,KAAK8O,KAIvDA,EAAMqD,aAAe,IAAIzB,EAAe5B,EAAM6B,aAE9C7B,EAAM+J,OAAS,GACf/J,EAAM8J,OAASvZ,KACfA,KAAKwZ,OAAOU,KAAKzK,GAGjB,MAAM+C,EAAW/C,EAAM+C,SAASQ,QAAOmH,GACrCA,EAAG3Z,QAAQb,EAAQJ,YAAa,CAAA,EAAIkQ,KAEtCzP,KAAKmS,SAASiI,eACZ5H,EAASxK,KAAInI,IAAY,CAAEA,UAASS,OAAQmP,MAE/C,CAED4K,kBACsB,OAAhBra,KAAKuZ,SAETvZ,KAAKuZ,OAAOC,OAASxZ,KAAKuZ,OAAOC,OAAOxG,QAAOvD,GAASA,IAAUzP,OAElEA,KAAKmS,SAASmI,gBAAkBta,KAAKmS,SAASmI,gBAAgBtH,QAC5D,EAAG1S,YAAaA,IAAWN,OAE9B,CAEDua,YACE,MAAO,CAACva,QAASA,KAAKwZ,OAAOgB,SAAQ/K,GAASA,EAAM8K,cACrD,CAEG5B,gBACF,OAAO3Y,KAAKoZ,UACb,CAEGT,cAAU8B,GACZza,KAAKoZ,WAAapZ,KAAK+U,aAAa0F,EACrC,CAEDC,KAAKlZ,EAAGC,GACFD,IAAMxB,KAAKwB,GAAKC,IAAMzB,KAAKyB,IAE3BzB,KAAK+Y,SACP/Y,KAAKmS,SAASwE,SAASgE,QACrB,CAAEnZ,EAAGxB,KAAKkZ,GAAIzX,EAAGzB,KAAKmZ,IACtB,CAAE3X,IAAGC,KACLzB,KAAK0Z,UACL1Z,KAAKgZ,SAIThZ,KAAKkZ,GAAK1X,EACVxB,KAAKmZ,GAAK1X,EACX,CAEGD,QACF,OAAOxB,KAAKkZ,EACb,CAEG1X,MAAEA,GACJxB,KAAK0a,KAAKlZ,EAAGxB,KAAKmZ,GACnB,CAEG1X,QACF,OAAOzB,KAAKmZ,EACb,CAEG1X,MAAEA,GACJzB,KAAK0a,KAAK1a,KAAKkZ,GAAIzX,EACpB,CAEDmZ,KAAKC,GACH,MAAMC,EAAU9a,KAAKyU,aAAazU,KAAK2Y,WAEvC3Y,KAAK0a,KACH1a,KAAKkZ,GAAK2B,EAAOxY,KAAKG,IAAIsY,GAC1B9a,KAAKmZ,GAAK0B,EAAOxY,KAAKC,IAAIwY,GAE7B,CAEDC,OAAOC,EAASxZ,EAAGC,GACjB,MAAMwZ,EAAc,CAAChU,EAAGN,EAAGuU,IAAMjU,GAAKN,EAAIM,GAAKiU,EAEzCC,EAAY,IAAI1F,KAChB2F,EAASpb,KAAKkZ,GACdmC,EAASrb,KAAKmZ,GAEpB,IAAI+B,EACJ,GACEA,GAAK,IAAIzF,KAAS0F,IAAwB,IAAVH,GAChChb,KAAK0a,KAAKO,EAAYG,EAAQ5Z,EAAG0Z,GAAID,EAAYI,EAAQ5Z,EAAGyZ,gBAErDA,EAAI,EACd,CAEGnC,cACF,OAAO/Y,KAAKyZ,QACb,CAEGV,YAAQA,GACNA,GACF/Y,KAAKmS,SAASwE,SAASgE,QACrB,CAAEnZ,EAAGxB,KAAKwB,EAAGC,EAAGzB,KAAKyB,GACrB,CAAED,EAAGxB,KAAKwB,EAAGC,EAAGzB,KAAKyB,GACrBzB,KAAK0Z,UACL1Z,KAAKgZ,SAGThZ,KAAKyZ,SAAWV,CACjB,CAEGE,eACF,OAAOjZ,KAAK0Z,SACb,CAEGT,aAASqC,GACPA,aAAiBtU,EACnBhH,KAAK0Z,UAAY4B,EAEjBnP,QAAQD,MACN,GAAGoP,wDAGR,CAEDC,QACEvb,KAAKmS,SAASwE,SAAS4E,MAAMvb,KAC9B,CAEDwb,SAASlb,EAAQmb,GAAO,GACtB,GAAsB,iBAAXnb,EACT,OAAQA,GACN,IAAK,QACH,OAAON,KAAKmS,SAASwE,SAAS+E,oBAC5B1b,KACA,CACEwB,EAAGxB,KAAK4V,MAAMpU,EACdC,EAAGzB,KAAK4V,MAAMnU,GAEhBga,GAEJ,IAAK,OAAQ,CACX,MAAME,EAAS3b,KAAKmS,SAASwE,SAASiF,oBAAoB5b,MACpD6b,EAAa7b,KAAKiT,MAAM5O,MACxByX,EAAc9b,KAAKiT,MAAM3O,OAC/B,OACEqX,EAAOhZ,MAAQkZ,EAAa,GAC5BF,EAAO9Y,MAAQgZ,EAAa,GAC5BF,EAAO5Y,IAAM+Y,EAAc,GAC3BH,EAAO7Y,QAAUgZ,EAAc,CAElC,CACD,QAIE,OAHA3P,QAAQD,MACN,uBAAuB5L,mEAElB,OAEN,GAAIA,aAAkB0G,EAC3B,OAAOhH,KAAKmS,SAASwE,SAASoF,oBAAoB/b,KAAMM,GAG1D,OAAON,KAAKmS,SAASwE,SAASqF,qBAAqBhc,KAAMM,EAAQmb,EAClE,CAEDQ,cAAcX,EAAOhb,GACnB,MAAsB,iBAAXA,GACT6L,QAAQD,MACN,uBAAuB5L,wEAElB,GAGY,iBAAVgb,GACTnP,QAAQD,MACN,sBAAsBoP,0EAEjB,GAGLhb,aAAkB0G,EAEbhH,KAAKmS,SAASwE,SAASoF,oBAAoB/b,KAAMM,EAAQgb,GAGzDtb,KAAKmS,SAASwE,SAASqF,qBAC5Bhc,KACAM,GACA,EACAgb,EAGL,CAEDvE,IAAI4C,GACFuC,aAAalc,KAAK8W,cAAc+C,SAChC7Z,KAAK8W,cAAgB,CAAE6C,KAAMzQ,OAAOyQ,GAAOC,MAAO,MAAOC,QAAS,KACnE,CAEDsC,MAAMxC,GACJuC,aAAalc,KAAK8W,cAAc+C,SAChC7Z,KAAK8W,cAAgB,CAAE6C,KAAMzQ,OAAOyQ,GAAOC,MAAO,QAASC,QAAS,KACrE,CAEDuC,YAAYzC,EAAMqB,GAChBkB,aAAalc,KAAK8W,cAAc+C,SAEhC,IAAI3Z,GAAO,EACX,MAAM2Z,EAAUwC,YAAW,KACzBrc,KAAK8W,cAAc6C,KAAO,GAC1B3Z,KAAK6Z,QAAU,KACf3Z,GAAO,CAAI,GACA,IAAV8a,GAGH,IADAhb,KAAK8W,cAAgB,CAAE6C,OAAMC,MAAO,MAAOC,YACnC3Z,QACT,CAEDoc,cAAc3C,EAAMqB,GAClBkB,aAAalc,KAAK8W,cAAc+C,SAEhC,IAAI3Z,GAAO,EACX,MAAM2Z,EAAUwC,YAAW,KACzBrc,KAAK8W,cAAc6C,KAAO,GAC1B3Z,KAAK6Z,QAAU,KACf3Z,GAAO,CAAI,GACA,IAAV8a,GAGH,IADAhb,KAAK8W,cAAgB,CAAE6C,OAAMC,MAAO,QAASC,YACrC3Z,QACT,EAGHuY,EAAOY,cAAgBzL,OAAO2O,OAAO,CACnCjD,WAAYna,OAAO,cACnBqd,WAAYrd,OAAO,cACnBsd,YAAatd,OAAO,iBAGf,MAAMud,UAAc1K,EACzBpS,YAAYqS,KAAsBmD,GAChCsD,MAAMzG,KAAsBmD,GAI5BxH,OAAO+O,iBAAiB3c,KAAM,CAC5BqE,MAAO,CACLkI,MAAO0F,EAAkB5N,OAAS,IAClCuY,YAAY,GAEdtY,OAAQ,CACNiI,MAAO0F,EAAkB3N,QAAU,IACnCsY,YAAY,KAIhB5c,KAAK4K,KAAO,QAGZ5K,KAAK6c,UAAY,CAClB,CAEDxJ,sBACE,OAAOrT,KAAKmS,SAASoE,YAAY5W,EAAQD,iBAAkB,CACzDod,SAAU9c,KAAKsT,QAAQ1I,MAE1B,EChwBH,MAAMmS,EAAc,CAAC9V,EAAGN,EAAGpE,KACjBoE,EAAE,GAAKM,EAAE,KAAO1E,EAAE,GAAK0E,EAAE,KAAON,EAAE,GAAKM,EAAE,KAAO1E,EAAE,GAAK0E,EAAE,IAOnE,MAAM+V,EACJpd,YAAYqd,GACVjd,KAAK8E,QAAUmY,EACfjd,KAAKkd,QAAS,EACdld,KAAKmd,QACN,CAEDA,SACEnd,KAAKod,OAASpd,KAAK8E,QAAQtD,EAC3BxB,KAAKqd,OAASrd,KAAK8E,QAAQrD,EAC3BzB,KAAKsd,cAAgBtd,KAAK8E,QAAQ6T,UAClC3Y,KAAKud,mBAAqBvd,KAAK8E,QAAQ8T,cACvC5Y,KAAKwd,UAAYxd,KAAK8E,QAAQ+T,KAC9B7Y,KAAKyd,aAAezd,KAAK8E,QAAQwO,QACjCtT,KAAK0d,mBAAqB1d,KAAK8E,QAAQwO,QAAQqK,IAAIC,SACnD5d,KAAKkd,QAAS,CACf,CAEGW,cACF,OACE7d,KAAKod,SAAWpd,KAAK8E,QAAQtD,GAC7BxB,KAAKqd,SAAWrd,KAAK8E,QAAQrD,GAC7BzB,KAAKsd,gBAAkBtd,KAAK8E,QAAQ6T,WACpC3Y,KAAKud,qBAAuBvd,KAAK8E,QAAQ8T,eACzC5Y,KAAKwd,YAAcxd,KAAK8E,QAAQ+T,MAChC7Y,KAAKyd,eAAiBzd,KAAK8E,QAAQwO,SACnCtT,KAAK0d,qBAAuB1d,KAAK8E,QAAQwO,QAAQqK,IAAIC,UACrD5d,KAAKkd,MAER,EAIY,MAAMY,EACnBle,YAAY+W,EAAUsG,GACpBjd,KAAK+d,UAAYpH,EACjB3W,KAAK8E,QAAUmY,EAGfjd,KAAKge,QAAU/c,EAAO8Y,SAGtB/Z,KAAKie,YAAc,IAAIjB,EAAoBC,GAC3Cjd,KAAKke,yBAKLle,KAAKme,qBAAuB,KAC5Bne,KAAKoe,kBAAoB,EACzBpe,KAAKqe,oBAAsB,EAC3Bre,KAAKse,iBAAmB,EACxBte,KAAKue,mBAAqB,EAC1Bve,KAAKwe,kBAAoB,KAEzBxe,KAAKye,MAAQ,IAAI/b,EACjB1C,KAAK0e,kBAAoB,IAAIhc,EAG7B1C,KAAK2e,sBAAwB,IAAI3B,EAAoBC,EACtD,CAED5X,iBACE,OAAOrF,KAAK+d,UAAUa,SAAS5e,KAAK8E,QAAQwO,QAC7C,CAIDuL,UACE,OAAOnc,EAAUoc,WAAW9e,KAAK+e,YAAa/e,KAAKye,MACpD,CAGD7C,sBACE,IAAK5b,KAAK2e,sBAAsBd,QAAS,OAAO7d,KAAK0e,kBAErD,MAAMvd,EAASnB,KAAK+e,YACdC,EAAmBhf,KAAKif,uBAG9B,GAAyB,OAArBD,EACF,OAAOtc,EAAUwc,WACflf,KAAK8E,QAAQtD,EACbxB,KAAK8E,QAAQrD,EACbzB,KAAK8E,QAAQtD,EACbxB,KAAK8E,QAAQrD,EACbzB,KAAK0e,mBAIT,IAAI/b,EAAOC,IACPC,GAASD,IACTG,GAAOH,IACPE,EAASF,IACb,MAAMuc,EAAmB,CAAC,EAAG,GAOvBlc,EAAK9B,EAAO,GAAK,EACjB+B,EAAK/B,EAAO,GAAK,EACjBie,GACH/c,KAAKe,IAAIH,GAAMZ,KAAKe,IAAIF,IAAOlD,KAAKme,qBAAqB9Z,MACtDf,EAAKnC,EAAO,GAAK,EACjBoC,EAAKpC,EAAO,GAAK,EACjBke,GACHhd,KAAKe,IAAIE,GAAMjB,KAAKe,IAAIG,IAAOvD,KAAKme,qBAAqB7Z,OAI5D,IAAK,IAAIG,EAAI,EAAGA,EAAIua,EAAiBta,OAAQD,IAAK,CAChD,MAAM6a,EAAQN,EAAiBva,GAC/B0a,EAAiB,GAAKG,EAAM,GAC5BH,EAAiB,GAAK,EAAIG,EAAM,GAChCre,EAAOse,eAAepe,EAAQge,EAAkBA,GAEhDxc,EAAON,KAAK4B,IAAItB,EAAMwc,EAAiB,GAAKC,GAC5Cvc,EAAQR,KAAK6B,IAAIrB,EAAOsc,EAAiB,GAAKC,GAC9Crc,EAAMV,KAAK6B,IAAInB,EAAKoc,EAAiB,GAAKE,GAC1Cvc,EAAST,KAAK4B,IAAInB,EAAQqc,EAAiB,GAAKE,EACjD,CAID,OAFA3c,EAAUwc,WAAWvc,EAAME,EAAOC,EAAQC,EAAK/C,KAAK0e,mBACpD1e,KAAK2e,sBAAsBxB,SACpBnd,KAAK0e,iBACb,CAEDO,uBACE,MAAMhC,EAASjd,KAAK8E,QAEd0a,EADOxf,KAAKqF,iBACKoa,aACrB,SAAUxC,EAASA,EAAOpE,KAAO,IAAM,GAEzC,IAAK2G,EAAW,OAAO,KAKvB,MAAMva,OAAEA,EAAME,SAAEA,EAAQK,MAAEA,EAAKO,QAAEA,GAAYkX,EAAOpY,QACpD,GACE7E,KAAKme,uBAAyBqB,GAC9Bxf,KAAKoe,oBAAsBnZ,GAC3BjF,KAAKqe,sBAAwBlZ,GAC7BnF,KAAKse,mBAAqB9Y,GAC1BxF,KAAKue,qBAAuBxY,EAE5B,OAAO/F,KAAKwe,kBAGd,MAAMzZ,EACJkY,EAAOpY,QAAQG,UACdR,EAAeS,OACdT,EAAeW,SACfX,EAAegB,MACfhB,EAAeuB,SAEb2Z,EAAW,GACXC,EAAY,IAEZtb,MAAEA,EAAKC,OAAEA,EAAM8F,KAAEA,GAASoV,EAE1BI,EAAW,CAAC,EAAG,GACfC,EAAY,CAAC,EAAG,GACtB,IAAIC,EAGJ,IAAK,IAAIre,EAAI,EAAGA,EAAI6C,EAAQ7C,IAAK,CAC/Bme,EAAS,IAAMne,EAAI,IAAO6C,EAI1B,IAAI9C,EAAI,EACR,KAAOA,EAAI6C,EAAO7C,IAAK,CACrBoe,EAAS,IAAMpe,EAAI,IAAO6C,EAC1B,IAAI0b,EAASve,EACTwe,EAASve,EAOb,GANsB,IAAlBsD,IACFJ,EAAqB3E,KAAM4f,EAAUC,GACrCE,EAAS1d,KAAKsB,MAAMkc,EAAU,GAAKxb,GACnC2b,EAAS3d,KAAKsB,MAAMkc,EAAU,GAAKvb,IAGjC8F,EAAiC,GAA3B4V,EAAS3b,EAAQ0b,GAAc,GAAK,EAAG,CAC/CD,EAAe,CAACF,EAAS,GAAIA,EAAS,IACtC,KACD,CACF,CAGD,KAAIpe,GAAK6C,GAAT,CAMA,KAAOqb,EAAShb,QAAU,KAEtBqY,EACE2C,EAASA,EAAShb,OAAS,GAC3Bgb,EAASA,EAAShb,OAAS,GAC3Bob,GACE,IAKNJ,EAASO,MAOX,IAJAP,EAASxF,KAAK4F,GAITte,EAAI6C,EAAQ,EAAG7C,GAAK,EAAGA,IAAK,CAC/Boe,EAAS,IAAMpe,EAAI,IAAO6C,EAC1BM,EAAqB3E,KAAM4f,EAAUC,GACrC,IAAIE,EAASve,EACTwe,EAASve,EAOb,GANsB,IAAlBsD,IACFJ,EAAqB3E,KAAM4f,EAAUC,GACrCE,EAAS1d,KAAKsB,MAAMkc,EAAU,GAAKxb,GACnC2b,EAAS3d,KAAKsB,MAAMkc,EAAU,GAAKvb,IAGjC8F,EAAiC,GAA3B4V,EAAS3b,EAAQ0b,GAAc,GAAK,EAAG,CAC/CD,EAAe,CAACF,EAAS,GAAIA,EAAS,IACtC,KACD,CACF,CAGD,KAAOD,EAAUjb,QAAU,KAEvBqY,EACE4C,EAAUA,EAAUjb,OAAS,GAC7Bib,EAAUA,EAAUjb,OAAS,GAC7Bob,GACE,IAKNH,EAAUM,MAGZN,EAAUzF,KAAK4F,EAxDU,CAyD1B,CAID,IAAK,IAAIrb,EAAIkb,EAAUjb,OAAS,EAAGD,GAAK,EAAGA,IACzCib,EAASxF,KAAKyF,EAAUlb,IAU1B,OAPAzE,KAAKwe,kBAAoBkB,EACzB1f,KAAKoe,kBAAoBnZ,EACzBjF,KAAKqe,oBAAsBlZ,EAC3BnF,KAAKse,iBAAmB9Y,EACxBxF,KAAKue,mBAAqBxY,EAC1B/F,KAAKme,qBAAuBqB,EAErBxf,KAAKwe,iBACb,CAEDN,yBACE,MAAMzb,EAAIzC,KAAKge,QACf/c,EAAOI,SAASoB,GAChB,MAAMyd,EAAMlgB,KAAK8E,QACjB,KAAMob,aAAexD,GAAQ,CAE3B,OADAzb,EAAOkf,UAAU1d,EAAGA,EAAGyd,EAAI1e,EAAG0e,EAAIze,GAC1Bye,EAAItH,eACV,KAAKH,EAAOY,cAAcC,WACxBrY,EAAOmf,OAAO3d,EAAGA,EAAGyd,EAAIzL,aAAayL,EAAIvH,YACzC,MAEF,KAAKF,EAAOY,cAAcmD,WACpB0D,EAAIvH,UAAY,GAAG1X,EAAOof,MAAM5d,EAAGA,GAAI,EAAG,GAKlD,MAAM6d,EAAcJ,EAAIrH,KAAO,IAC/B5X,EAAOof,MAAM5d,EAAGA,EAAG6d,EAAaA,EACjC,CAED,MAAMC,EAAgB,EAAIL,EAAI5M,QAAQkN,WAGtCvf,EAAOkf,UACL1d,EACAA,GACCyd,EAAI5M,QAAQmN,OAAOjf,EAAI+e,GACvBL,EAAI5M,QAAQmN,OAAOhf,EAAIye,EAAI5M,QAAQhP,QAAUic,GAEhDtf,EAAOof,MACL5d,EACAA,EACAyd,EAAI5M,QAAQjP,MAAQkc,EACpBL,EAAI5M,QAAQhP,OAASic,GAKvBvgB,KAAKie,YAAYd,QAClB,CAED4B,YAOE,OAJI/e,KAAKie,YAAYJ,SACnB7d,KAAKke,yBAGAle,KAAKge,OACb,EC/UY,MAAM0C,EACnB9gB,YAAY+W,GACV3W,KAAK2W,SAAWA,EAChB3W,KAAK2gB,GAAKhK,EAASgK,EACpB,CAIDC,WAAWP,GACT,OAAO,IACR,CAIDZ,aAAaY,GACX,MAAM,IAAIvX,MAAM,kDACjB,CAGD+X,aAAaC,EAAOC,GAClB,MAAMJ,EAAK3gB,KAAK2gB,GACVK,EAAYL,EAAGM,gBAmBrB,OAlBAN,EAAGO,YAAYP,EAAGQ,WAAYH,GAI9BL,EAAGS,cAAcT,EAAGQ,WAAYR,EAAGU,eAAgBV,EAAGW,eACtDX,EAAGS,cAAcT,EAAGQ,WAAYR,EAAGY,eAAgBZ,EAAGW,eACtDX,EAAGS,cAAcT,EAAGQ,WAAYR,EAAGa,mBAAoBT,GACvDJ,EAAGS,cAAcT,EAAGQ,WAAYR,EAAGc,mBAAoBV,GACnDD,GACFH,EAAGe,WACDf,EAAGQ,WACH,EACAR,EAAGgB,KACHhB,EAAGgB,KACHhB,EAAGiB,cACHd,GAGGE,CACR,CAGDa,kBAAkBf,GACZA,EAAMlD,UACR5d,KAAKqE,MAAQyc,EAAMgB,aACnB9hB,KAAKsE,OAASwc,EAAMiB,eAEpBjB,EAAMlV,iBAAiB,QAAQ,KAC7B5L,KAAKqE,MAAQyc,EAAMgB,aACnB9hB,KAAKsE,OAASwc,EAAMiB,aAAa,GAGtC,CAGDC,UAAY,ECvDC,MAAMC,UAAmBvB,EACtC9gB,YAAY+W,EAAUmK,GACpBpI,MAAM/B,GAEN3W,KAAKkiB,OAASpB,EACd9gB,KAAKmiB,WAAa,KAClBniB,KAAKoiB,SAAW,KAEhBpiB,KAAK6hB,kBAAkBf,EACxB,CAEDrB,eAEE,IAAKzf,KAAKkiB,OAAOtE,SAAU,OAAO,KAElC,IAAK5d,KAAKmiB,WAAY,CACpB,MAAME,EAASC,SAASC,cAAc,UACtCF,EAAOhe,MAAQrE,KAAKkiB,OAAOJ,cAAgB9hB,KAAKkiB,OAAO7d,MACvDge,EAAO/d,OAAStE,KAAKkiB,OAAOH,eAAiB/hB,KAAKkiB,OAAO5d,OACzD,MAAMke,EAAMH,EAAOI,WAAW,MAC9BD,EAAIE,UAAU1iB,KAAKkiB,OAAQ,EAAG,GAE9BliB,KAAKmiB,WAAaK,EAAI/C,aAAa,EAAG,EAAG4C,EAAOhe,MAAOge,EAAO/d,OAC/D,CAED,OAAOtE,KAAKmiB,UACb,CAEDvB,aAEE,MAAME,EAAQ9gB,KAAKkiB,OACnB,OAAKpB,EAAMlD,UAEW,OAAlB5d,KAAKoiB,WAEPpiB,KAAKoiB,SAAW1J,MAAMmI,aAAaC,EAAO9gB,KAAK2gB,GAAGgC,UAE7C3iB,KAAKoiB,UANgB,IAO7B,CAEDJ,UACwB,OAAlBhiB,KAAKoiB,UAAmBpiB,KAAK2gB,GAAGiC,cAAc5iB,KAAKoiB,SACxD,EC5CH,MAAMS,EAAe,CAErBA,OAAsB,6TAetBA,SAAwB,y9HA0KlBC,EAAgB,CAEtBA,OAAuB,w2FA8DvBA,SAAyB,2zCCvPzB,MAAMC,EACJnjB,YAAY+gB,EAAIqC,GACdhjB,KAAK2gB,GAAKA,EACV3gB,KAAKgjB,QAAUA,EACfhjB,KAAKijB,SAAW,GAChBjjB,KAAKkjB,QAAU,GAKf,MAAMC,EAAoBxC,EAAGyC,oBAC3BJ,EACArC,EAAG0C,iBAEL,IAAK,IAAI5e,EAAI,EAAGA,EAAI0e,EAAmB1e,IAAK,CAC1C,MAAMmG,KAAEA,GAAS+V,EAAG2C,iBAAiBN,EAASve,GAC9CzE,KAAKijB,SAASrY,GAAQ+V,EAAG4C,mBAAmBP,EAASpY,EACtD,CAED,MAAM4Y,EAAsB7C,EAAGyC,oBAC7BJ,EACArC,EAAG8C,mBAEL,IAAK,IAAIhf,EAAI,EAAGA,EAAI+e,EAAqB/e,IAAK,CAC5C,MAAMmG,KAAEA,GAAS+V,EAAG+C,gBAAgBV,EAASve,GAC7CzE,KAAKkjB,QAAQtY,GAAQ+V,EAAGgD,kBAAkBX,EAASpY,EACpD,CACF,EAGH,MAAMgZ,EACJhkB,YAAY+W,GACV3W,KAAK2W,SAAWA,EAChB3W,KAAK2gB,GAAKhK,EAASgK,GAGnB3gB,KAAK6jB,aAAe,GACpB,IAAK,MAAMC,KAAYlW,OAAOmE,KAAK6R,EAAcG,WAC/C/jB,KAAK6jB,aAAaC,GAAY,IAAIE,GAErC,CAGDC,cAAclZ,EAAQmZ,GACpB,MAAMvD,EAAK3gB,KAAK2gB,GACVwD,EAASxD,EAAGyD,aAAaF,GAI/B,GAHAvD,EAAG0D,aAAaF,EAAQpZ,GACxB4V,EAAG2D,cAAcH,IAEZxD,EAAG4D,mBAAmBJ,EAAQxD,EAAG6D,gBAAiB,CAErD,KAAM,sCADO7D,EAAG8D,iBAAiBN,EAElC,CAED,OAAOA,CACR,CAEDO,UAAUZ,EAAU/e,EAAgB,GAClC,MAAM4b,EAAK3gB,KAAK2gB,GAGVgE,EAAY3kB,KAAK6jB,aAAaC,GACpC,GAAIa,EAAUC,IAAI7f,GAChB,OAAO4f,EAAUnT,IAAIzM,GAChB,CACL,IAAI8f,EACJ,GAAQf,IACDF,EAAcG,UAAUe,SAC3BD,EAAa/B,OAIb+B,EAAahC,EAMjB,IAAIkC,EAAS,qBAAqBjB,MAGlC,IAAK,IAAIrf,EAAI,EAAGA,EAAIF,EAAYG,OAAQD,IAAK,CAC3C,MAAMmN,EAAarN,EAAYE,GACsB,IAAhDM,EAAgBP,EAAeoN,MAClCmT,GAAU,kBAAkBnT,MAE/B,CAED,MAAMoT,EAAahlB,KAAKikB,cACtBc,EAASF,EAAWI,OACpBtE,EAAGuE,eAECC,EAAanlB,KAAKikB,cACtBc,EAASF,EAAWO,SACpBzE,EAAG0E,iBAICrC,EAAUrC,EAAG2E,gBAKnB,GAJA3E,EAAG4E,aAAavC,EAASgC,GACzBrE,EAAG4E,aAAavC,EAASmC,GACzBxE,EAAG6E,YAAYxC,IAEVrC,EAAGyC,oBAAoBJ,EAASrC,EAAG8E,aAAc,CACpD,MAAMC,EAAO/E,EAAGgF,kBAAkB3C,GAClC,MAAM,IAAIla,MAAM,sCAAwC4c,EACzD,CAED,MAAMvB,EAAS,IAAIpB,EAAOpC,EAAIqC,GAE9B,OADA2B,EAAU5V,IAAIhK,EAAeof,GACtBA,CACR,CACF,EAGHP,EAAcG,UAAY,CAExB6B,QAAS,UAETC,WAAY,aAGZC,WAAY,aAGZC,UAAW,YAEXjB,SAAU,YChIG,MAAMkB,UAAgBtF,EACnC9gB,YAAY+W,EAAUtS,EAAOC,GAC3BoU,MAAM/B,GACN3W,KAAKqE,MAAQA,EACbrE,KAAKsE,OAASA,EAEd,MAAM2hB,EAAkBtP,EAASuP,uBAC/B7hB,EACAC,EACAtE,KAAK2gB,GAAGgC,SAEV3iB,KAAKmmB,iBAAmBF,EAExBjmB,KAAKomB,cAAgB,CACnBvN,KAAM,EACNyC,MAAO,CAAC,EAAG,EAAG,EAAG,IAGnBtb,KAAKyR,OACN,CAEDuQ,UACE,MAAMrB,EAAK3gB,KAAK2gB,GAChBA,EAAGiC,cAAc5iB,KAAKmmB,iBAAiBE,SACvC1F,EAAG2F,kBAAkBtmB,KAAKmmB,iBAAiBI,YAC5C,CAED3F,aACE,OAAO5gB,KAAKmmB,iBAAiBE,OAC9B,CAED1L,QAAQ6L,EAAKC,EAAKnL,EAAOzC,GACvB,MAAMlC,EAAW3W,KAAK2W,SACtBA,EAAS+P,gBAAgB1mB,KAAKmmB,kBAE9B,MAAMhC,EAASxN,EAASgQ,eAAejC,UACrCd,EAAcG,UAAUe,UAGpBnE,EAAK3gB,KAAK2gB,GAGViG,EAAgBjQ,EAASkQ,WAAW1C,GAGtCyC,GACFjG,EAAGmG,UAAU3C,EAAOlB,SAAS8D,cAAe/mB,KAAKqE,MAAOrE,KAAKsE,QAI/D,MAAM2U,EAAWqC,EAAMlT,mBACjB4e,EAAWhnB,KAAKomB,cAAc9K,OAElCsL,GACA3N,EAAS,KAAO+N,EAAS,IACzB/N,EAAS,KAAO+N,EAAS,IACzB/N,EAAS,KAAO+N,EAAS,IACzB/N,EAAS,KAAO+N,EAAS,MAEzBhnB,KAAKomB,cAAc9K,MAAQrC,EAC3B0H,EAAGsG,UACD9C,EAAOlB,SAASiE,WAChBjO,EAAS,GAAKA,EAAS,GACvBA,EAAS,GAAKA,EAAS,GACvBA,EAAS,GAAKA,EAAS,GACvBA,EAAS,MAKT2N,GAAiB5mB,KAAKomB,cAAcvN,OAASA,KAC/C7Y,KAAKomB,cAAcvN,KAAOA,EAC1B8H,EAAGwG,UAAUhD,EAAOlB,SAASmE,UAAWvO,IAG1C,MAAMwO,EAAYZ,EAAIjlB,EAAIglB,EAAIhlB,EACxB8lB,EAAYb,EAAIhlB,EAAI+kB,EAAI/kB,EAIxB0I,EAAkB,IAAT0O,GAAuB,IAATA,EAAa,GAAM,EAEhD8H,EAAGsG,UACD9C,EAAOlB,SAASsE,YAChBf,EAAIhlB,EAAI2I,EACRqc,EAAI/kB,EAAI0I,EACRkd,EACAC,GAQF,MAAME,EAAanlB,KAAKwD,KAAKwhB,EAAYA,EAAYC,EAAYA,GACjE3G,EAAGwG,UAAUhD,EAAOlB,SAASwE,aAAcD,GAE3C7G,EAAG+G,WAAW/G,EAAGgH,UAAW,EAAG,EAChC,CAEDlW,QACEzR,KAAK2W,SAAS+P,gBAAgB1mB,KAAKmmB,kBACnC,MAAMxF,EAAK3gB,KAAK2gB,GAChBA,EAAGiH,WAAW,EAAG,EAAG,EAAG,GACvBjH,EAAGlP,MAAMkP,EAAGkH,iBACb,EC3GH,MAAMC,EACU,IADVA,EAGS,EAHTA,EAIK,GAJLA,EAKQ,GAIC,MAAMC,UAAyBrH,EAC5C9gB,YAAY+W,EAAUqR,GACpBtP,MAAM/B,GAEN3W,KAAKioB,QAAU3F,SAASC,cAAc,UACtCviB,KAAKoiB,SAAWpiB,KAAK6gB,aAAa,KAAM7gB,KAAK2gB,GAAGuH,QAChDloB,KAAKmoB,QAAUH,EACfhoB,KAAKooB,UAAW,EAChBpoB,KAAKqoB,WAAY,EACjBroB,KAAKsoB,eAAiB,EAEtBtoB,KAAKqE,MAAQ,EACbrE,KAAKsE,OAAS,EACdtE,KAAK0F,SAAWoiB,EAA0B,EAC1C9nB,KAAK2F,QAAU3F,KAAK0F,QAAUoiB,EAE9B9nB,KAAKuoB,cAAcvoB,KAAKmoB,QACzB,CAGDK,iBACE,MAAMhG,EAAMxiB,KAAKioB,QAAQxF,WAAW,MACpCD,EAAIiG,KAAO,kBACXjG,EAAIkG,aAAe,SACpB,CAEGC,YAAQA,GACV3oB,KAAKooB,SAAWO,EAChB3oB,KAAKqoB,WAAY,CAClB,CAEDE,cAAcP,EAAQ3H,GACpB,MAAMgC,EAASriB,KAAKioB,QACdzF,EAAMH,EAAOI,WAAW,MAwC9BziB,KAAKwoB,iBAEL,MAAM7O,KAAEA,EAAIC,MAAEA,GAAUoO,EAClBY,EAAYpG,EAAIqG,YAAYlP,GAAMtV,MAElCykB,EAAWhB,EACXiB,EAAUjB,EAEVzjB,EAAQhC,KAAKuB,KAAKvB,KAAK4B,IAAI2kB,EAAWE,GAAY,EAAIC,GACtDzkB,EAAS,GAAK,EAAIykB,EAExB/oB,KAAKqE,MAAQA,EAAQyjB,EACrB9nB,KAAKsE,OAASA,EAASwjB,EAAyBA,EAEhDzF,EAAOhe,MAAQrE,KAAKqE,MAAQgc,EAC5BgC,EAAO/d,OAAStE,KAAKsE,OAAS+b,EAE9BrgB,KAAKwoB,iBAEL,MAAMhnB,EAAIsmB,EAA0B,EAC9BrmB,EAAID,EAEVghB,EAAIwG,aAAa3I,EAAO,EAAG,EAAGA,EAAO,EAAG,GAExCmC,EAAIyG,UAAY,OAChBzG,EAAI0G,YAAc,OAClB1G,EAAI2G,UAAYrB,EAChBtF,EAAI4G,OACAppB,KAAKooB,WACP5F,EAAInC,OAAO,EAAG,GACdmC,EAAIrC,WAAWngB,KAAKqE,MAAO,IApEE,EAAC7C,EAAGC,EAAG4nB,EAAGxiB,EAAGT,EAAGwT,KACzCxT,EAAIijB,EAAI,IAAGjjB,EAAIijB,EAAI,GACnBjjB,EAAIS,EAAI,IAAGT,EAAIS,EAAI,GACnBT,EAAI,IAERoc,EAAI8G,YACJ9G,EAAI+G,OAAO/nB,EAAI4E,EAAG3E,GAClB+gB,EAAIgH,MAAMhoB,EAAI6nB,EAAG5nB,EAAGD,EAAI6nB,EAAG5nB,EAAIoF,EAAGT,GAClCoc,EAAIgH,MAAMhoB,EAAI6nB,EAAG5nB,EAAIoF,EAAGrF,EAAI4E,EAAG3E,EAAIoF,EAAGT,GACxB,QAAVwT,GACF4I,EAAIiH,OAAOpnB,KAAK4B,IAAIzC,EAAI,EAAI4E,EAAG5E,EAAI6nB,EAAIjjB,GAAI3E,EAAIoF,GAC/C2b,EAAIiH,OAAOjoB,EAAI4E,EAAI,EAAG3E,EAAIoF,EAAIT,GAC9Boc,EAAIiH,OAAOjoB,EAAI4E,EAAG3E,EAAIoF,IACH,UAAV+S,GACT4I,EAAIkH,QAAQloB,EAAQ,KAAJ4E,EAAU3E,EAAIoF,EAAQ,EAAJT,EAAS,EAAGA,EAAI,EAAG,EAAG,EAAG/D,KAAKwO,IAElE2R,EAAIgH,MAAMhoB,EAAGC,EAAIoF,EAAGrF,EAAGC,EAAG2E,GAC1Boc,EAAIgH,MAAMhoB,EAAGC,EAAGD,EAAI6nB,EAAG5nB,EAAG2E,GAC1Boc,EAAImH,YACJnH,EAAIoH,SACJpH,EAAIqH,OAEU,UAAVjQ,IACF4I,EAAI8G,YACJ9G,EAAIkH,QACFloB,EAAI4E,EACJ3E,EAAIoF,EAAS,EAAJT,EAAS,EAClBA,EAAI,EACJA,EAAI,EACJ,EACA,EACA,EAAI/D,KAAKwO,IAEX2R,EAAIoH,SACJpH,EAAIqH,QACL,EAmCHC,CAAuBtoB,EAAGC,EAAG4C,EAAOC,EAAQwjB,EAAwBlO,GACpE4I,EAAIuH,UAEJvH,EAAIyG,UAAY,OAChBzG,EAAIwH,SAASrQ,EAAMnY,EAAIunB,EAAStnB,EAAIsnB,EAASD,GAE7C9oB,KAAKqoB,WAAY,EACjBroB,KAAKsoB,eAAiBjI,CACvB,CAEDO,WAAWP,GACT,IAAKrgB,KAAKqoB,WAAaroB,KAAKsoB,iBAAmBjI,EAAO,CACpDrgB,KAAKuoB,cAAcvoB,KAAKmoB,QAAS9H,GACjC,MAAMM,EAAK3gB,KAAK2gB,GAChBA,EAAGO,YAAYP,EAAGQ,WAAYnhB,KAAKoiB,UACnCzB,EAAGe,WACDf,EAAGQ,WACH,EACAR,EAAGgB,KACHhB,EAAGgB,KACHhB,EAAGiB,cACH5hB,KAAKioB,QAER,CAED,OAAOjoB,KAAKoiB,QACb,CAEDJ,UACEhiB,KAAK2gB,GAAGiC,cAAc5iB,KAAKoiB,SAC5B,EC7IY,MAAM6H,UAAmBvJ,EACtC9gB,YAAY+W,EAAUmK,GACpBpI,MAAM/B,GAEN3W,KAAKkiB,OAASpB,EACd9gB,KAAKioB,QAAU3F,SAASC,cAAc,UAEtCviB,KAAKkqB,mBAAqB,EAC1BlqB,KAAKmiB,WAAa,KAElBniB,KAAKmqB,gBAAkBxT,EAASgK,GAAGyJ,aACjCzT,EAASgK,GAAG0J,kBAGdrqB,KAAK6hB,kBAAkBf,GAEvB9gB,KAAKsqB,SAAW,IAAItG,GACrB,CAED9iB,wBAAwBmf,GACtB,OAAOhe,KAAK6B,IAAI7B,KAAKuB,KAAKvB,KAAKkoB,KAAKlK,IAtBlB,EAsB2C,EAC9D,CAEDZ,aAAaY,GACX,IAAKrgB,KAAKkiB,OAAOtE,SAAU,OAAO,KAGlC,MAAM4M,EAAWP,EAAWQ,iBAAiBpK,GAC7C,IAAKrgB,KAAKmiB,YAAcniB,KAAKkqB,qBAAuBM,EAAU,CAC5D,MAAMnI,EAASriB,KAAK0qB,iBAAiBF,GACrC,GAAe,OAAXnI,EAAiB,OAAO,KAG5BriB,KAAKmiB,WAAaE,EACfI,WAAW,MACXhD,aAAa,EAAG,EAAG4C,EAAOhe,MAAOge,EAAO/d,QAC3CtE,KAAKkqB,mBAAqBM,CAC3B,CAED,OAAOxqB,KAAKmiB,UACb,CAEDuI,iBAAiBF,GACf,MAAMnK,EAAQ,IAAMmK,EA7CF,GA+CZ1J,EAAQ9gB,KAAKkiB,OACnB,IAAI7d,EAAQyc,EAAMgB,aAAezB,EAC7B/b,EAASwc,EAAMiB,cAAgB1B,EAMnC,GAJAhc,EAAQhC,KAAKwF,MAAMxF,KAAK4B,IAAII,EAAOrE,KAAKmqB,kBACxC7lB,EAASjC,KAAKwF,MAAMxF,KAAK4B,IAAIK,EAAQtE,KAAKmqB,kBAG5B,IAAV9lB,GAA0B,IAAXC,EACjB,OAAO,KAIT,MAAM+d,EAASriB,KAAKioB,QACdzF,EAAMH,EAAOI,WAAW,MAM9B,OAJAJ,EAAOhe,MAAQA,EACfge,EAAO/d,OAASA,EAEhBke,EAAIE,UAAU5B,EAAO,EAAG,EAAGzc,EAAOC,GAC3BtE,KAAKioB,OACb,CAID0C,cAAcH,GAEZ,MAAMnI,EAASriB,KAAK0qB,iBAAiBF,GACrCxqB,KAAKsqB,SAASvb,IACZyb,EAGW,OAAXnI,EAAkB,KAAOriB,KAAK6gB,aAAawB,EAAQriB,KAAK2gB,GAAGuH,QAE9D,CAEDtH,WAAWP,GACT,IAAKrgB,KAAKkiB,OAAOtE,SAAU,OAAO,KASlC,MAAM4M,EAAWP,EAAWQ,iBAAiBpK,GAG7C,OAFKrgB,KAAKsqB,SAAS1F,IAAI4F,IAAWxqB,KAAK2qB,cAAcH,GAE9CxqB,KAAKsqB,SAAS9Y,IAAIgZ,EAC1B,CAEDxI,UACE,IAAK,MAAM4I,KAAO5qB,KAAKsqB,SAASxb,SAC9B9O,KAAK2gB,GAAGiC,cAAcgI,EAEzB,EC1GY,MAAMC,EACnBjrB,YAAYgL,EAAMC,EAAK4V,EAAS,CAAEjf,EAAG,EAAGC,EAAG,IACzCzB,KAAK4K,KAAOA,EACZ5K,KAAK6K,IAAMA,EAEX7K,KAAK2d,IAAM,IAAImN,MACf9qB,KAAK2d,IAAIoN,YAAc,YACvB/qB,KAAK2d,IAAIpc,IAAMvB,KAAK6K,IAGpB7K,KAAKgrB,UAAYhrB,KAAK6K,IAAIogB,MAAM,SAChCjrB,KAAKwgB,WAAaxgB,KAAKgrB,SAAW,EAAI,EAEtChrB,KAAKygB,OAASA,CACf,CAEGpc,YACF,OAAOrE,KAAK2d,IAAImE,YACjB,CAEGxd,aACF,OAAOtE,KAAK2d,IAAIoE,aACjB,ECRH,MAAMmJ,EAAiB,IAAIxoB,EAgBZ,MAAMyoB,EACnBvrB,YAAYwrB,EAASC,GACnB,MAAMhC,EAAI+B,EAAQnY,MAAM5O,MAClBwC,EAAIukB,EAAQnY,MAAM3O,OACxBtE,KAAKorB,QAAUA,EACfprB,KAAKiT,MAAQjT,KAAKsrB,YAAYjC,EAAGxiB,GACjC7G,KAAK2gB,GAAK3gB,KAAKiT,MAAMwP,WAAW,QAAS,CAAE8I,WAAW,IAElDF,EACFrrB,KAAKwrB,gBAAgBH,GAErBrrB,KAAKqrB,aAAe,KAGtBrrB,KAAK2mB,eAAiB,IAAI/C,EAAc5jB,MACxCA,KAAKyrB,WAAa,IAAIC,QACtB1rB,KAAK2rB,OAAS,IAAID,QAElB1rB,KAAK4rB,eAAiB,KACtB5rB,KAAK6rB,oBAAsB,KAC3B7rB,KAAK8rB,kBAAoB,EAGzB,MAAMnL,EAAK3gB,KAAK2gB,GAGhBA,EAAGoL,OAAOpL,EAAGqL,OACbrL,EAAGsL,UAAUtL,EAAGuL,IAAKvL,EAAGwL,qBACxBxL,EAAGyL,YAAYzL,EAAG0L,gCAAgC,GAGlD,MAAM1iB,EAASgX,EAAG/W,eAClB+W,EAAG2L,WAAW3L,EAAG4L,aAAc5iB,GAG/BgX,EAAG6L,WACD7L,EAAG4L,aAGH,IAAInrB,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IACnDuf,EAAG8L,aAIL9L,EAAG+L,cAAc/L,EAAGgM,UAEpB3sB,KAAK4sB,SAAW,IAAI5G,EAAQhmB,KAAMqpB,EAAGxiB,GAGrC7G,KAAK6sB,iBAAmB7sB,KAAKkmB,uBAC3BmD,EACAxiB,EACA8Z,EAAGgC,SACH,EAEH,CAGD/D,SAASkO,GACP,GAAI9sB,KAAK2rB,OAAO/G,IAAIkI,GAClB,OAAO9sB,KAAK2rB,OAAOna,IAAIsb,GAGzB,IAAI1nB,EAaJ,OATIA,EAFA0nB,aAAejC,EACbiC,EAAI9B,SACC,IAAI/I,EAAWjiB,KAAM8sB,EAAInP,KAEzB,IAAIsM,EAAWjqB,KAAM8sB,EAAInP,KAI3B,IAAIoK,EAAiB/nB,KAAM8sB,GAEpC9sB,KAAK2rB,OAAO5c,IAAI+d,EAAK1nB,GACdA,CACR,CAGD2nB,aAAa9P,GACX,GAAIjd,KAAKyrB,WAAW7G,IAAI3H,GACtB,OAAOjd,KAAKyrB,WAAWja,IAAIyL,GAE7B,MAAMrY,EAAW,IAAIkZ,EAAS9d,KAAMid,GAEpC,OADAjd,KAAKyrB,WAAW1c,IAAIkO,EAAQrY,GACrBA,CACR,CAMDshB,uBAAuB7hB,EAAOC,EAAQyc,EAAWiM,GAAU,GAEzD,MAAMrM,EAAK3gB,KAAK2gB,GACV0F,EAAU1F,EAAGM,gBACnBN,EAAGO,YAAYP,EAAGQ,WAAYkF,GAC9B1F,EAAGS,cAAcT,EAAGQ,WAAYR,EAAGU,eAAgBV,EAAGW,eACtDX,EAAGS,cAAcT,EAAGQ,WAAYR,EAAGY,eAAgBZ,EAAGW,eACtDX,EAAGS,cAAcT,EAAGQ,WAAYR,EAAGa,mBAAoBT,GACvDJ,EAAGS,cAAcT,EAAGQ,WAAYR,EAAGc,mBAAoBV,GACvDJ,EAAGe,WACDf,EAAGQ,WACH,EACAR,EAAGgB,KACHtd,EACAC,EACA,EACAqc,EAAGgB,KACHhB,EAAGiB,cACH,MAKF,MAAMqE,EAAkB,CACtBI,UACAhiB,QACAC,SACAiiB,YAAa5F,EAAGsM,qBAalB,GAXAjtB,KAAK0mB,gBAAgBT,GACrBtF,EAAGuM,qBACDvM,EAAGwM,YACHxM,EAAGyM,kBACHzM,EAAGQ,WACHkF,EACA,GAKE2G,EAAS,CACX,MAAMK,EAAe1M,EAAG2M,qBACxB3M,EAAG4M,iBAAiB5M,EAAG6M,aAAcH,GACrC1M,EAAG8M,oBAAoB9M,EAAG6M,aAAc7M,EAAG+M,cAAerpB,EAAOC,GACjEqc,EAAGgN,wBACDhN,EAAGwM,YACHxM,EAAGiN,yBACHjN,EAAG6M,aACHH,EAEH,CAED,OAAOpH,CACR,CAEDY,WAAW1C,GACT,GAAIA,IAAWnkB,KAAK4rB,eAAgB,CAClC,MAAMjL,EAAK3gB,KAAK2gB,GAChBA,EAAGkN,WAAW1J,EAAOnB,SAIrB,MAAM8K,EAAiB3J,EAAOjB,QAAQ6K,WAgBtC,OAfApN,EAAGqN,wBAAwBF,GAG3BnN,EAAGsN,oBACDH,EACA,EACAnN,EAAGuN,OACH,EACA,EACA,GAGFluB,KAAK4rB,eAAiBzH,EACtBnkB,KAAKmuB,oBAEE,CACR,CAED,OAAO,CACR,CAEDzH,gBAAgBT,GACVA,IAAoBjmB,KAAK6rB,sBAC3B7rB,KAAK6rB,oBAAsB5F,EACH,OAApBA,GAEFjmB,KAAK2gB,GAAGyN,gBAAgBpuB,KAAK2gB,GAAGwM,YAAa,MAC7CntB,KAAKmuB,qBAELnuB,KAAK2gB,GAAGyN,gBACNpuB,KAAK2gB,GAAGwM,YACRlH,EAAgBM,aAGlBvmB,KAAK2gB,GAAG0N,SAAS,EAAG,EAAGpI,EAAgB5hB,MAAO4hB,EAAgB3hB,SAGnE,CAEDknB,gBAAgBH,GACc,iBAAjBA,IACTA,EAAe/I,SAASgM,cAAcjD,IAExCrrB,KAAKqrB,aAAeA,EACpBrrB,KAAKqrB,aAAakD,UAAUC,IAAI,oBAChCxuB,KAAKqrB,aAAazR,MAAMvV,MAAQ,GAAGrE,KAAKorB,QAAQnY,MAAM5O,UACtDrE,KAAKqrB,aAAazR,MAAMtV,OAAS,GAAGtE,KAAKorB,QAAQnY,MAAM3O,WAEvDtE,KAAKqrB,aAAaoD,OAAOzuB,KAAKiT,MAC/B,CAGDyb,cAAcC,EAAQ7uB,EAAU,IAC9BA,EAAU8N,OAAOgC,OACf,CACEkU,SAAUF,EAAcG,UAAU6B,QAClCgJ,qBAAqB,GAEvB9uB,GAMF,MAAM+uB,EAAuBF,aAAkB9f,IACzCigB,EAA+C,mBAAnBhvB,EAAQkT,OACpC+b,EAAqBC,KAEtBH,IAAyBF,EAAO/J,IAAIoK,IACpCF,IAAuBhvB,EAAQkT,OAAOgc,IAS3C,GALID,EAAmB/uB,KAAKorB,QAAQnY,QAClCjT,KAAKivB,aAAajvB,KAAKorB,QAAQnY,MAAOnT,GAIpCivB,EAAmB/uB,KAAK4sB,UAAW,CACrC,MAAMsC,EAAYjuB,EAAO8Y,SACzB9Y,EAAOof,MACL6O,EACAA,EACAlvB,KAAK4sB,SAASvoB,OACbrE,KAAK4sB,SAAStoB,QAEjBrD,EAAOkf,UAAU+O,EAAWA,GAAY,IAAM,IAE9ClvB,KAAKmvB,YACHnvB,KAAK4sB,SACL9sB,EAAQgkB,SACRoL,EACA,EAEH,CAGD,IAAK,MAAMjS,KAAUjd,KAAKorB,QAAQgE,iBAE5BL,EAAmB9R,KAA8B,IAAnBA,EAAOnE,SACvC9Y,KAAKivB,aAAahS,EAAQnd,EAG/B,CAEDquB,mBACMnuB,KAAK4rB,gBAGP5rB,KAAK2gB,GAAGmG,UACN9mB,KAAK4rB,eAAe3I,SAASoM,YAC7BrvB,KAAKorB,QAAQnY,MAAM5O,MACnBrE,KAAKorB,QAAQnY,MAAM3O,QAIU,OAA7BtE,KAAK6rB,qBACP7rB,KAAK2gB,GAAG0N,SACN,EACA,EACAruB,KAAK2gB,GAAG2O,mBACRtvB,KAAK2gB,GAAG4O,oBAGb,CAGDC,UACE,MAAMC,EAAYzvB,KAAKiT,MAAMyc,wBACvBxe,EAAQnE,OAAO4iB,iBACfC,EAAgBvtB,KAAKwF,MAAM4nB,EAAUprB,MAAQ6M,GAC7C2e,EAAiBxtB,KAAKwF,MAAM4nB,EAAUnrB,OAAS4M,GAEnDlR,KAAKiT,MAAM5O,QAAUurB,GACrB5vB,KAAKiT,MAAM3O,SAAWurB,IAEtB7vB,KAAKiT,MAAM5O,MAAQurB,EACnB5vB,KAAKiT,MAAM3O,OAASurB,EACpB7vB,KAAK8rB,kBAAoBzpB,KAAK6B,IAC5B0rB,EAAgB5vB,KAAKorB,QAAQnY,MAAM5O,MACnCwrB,EAAiB7vB,KAAKorB,QAAQnY,MAAM3O,QAGtCtE,KAAKmuB,mBAER,CAEDhR,SACEnd,KAAKwvB,UAGLxvB,KAAK0mB,gBAAgB,MAGrB,MAAM/F,EAAK3gB,KAAK2gB,GAChBA,EAAGiH,WAAW,EAAG,EAAG,EAAG,GACvBjH,EAAGlP,MAAMkP,EAAGkH,kBAEZ7nB,KAAK0uB,eACN,CAEDpD,YAAYjC,EAAGxiB,GACb,MAAMoM,EAAQqP,SAASC,cAAc,UAerC,OAdAtP,EAAM5O,MAAQglB,EACdpW,EAAM3O,OAASuC,EAGfoM,EAAM2G,MAAMvV,MAAQ4O,EAAM2G,MAAMtV,OAAS,OAIzC2O,EAAM2G,MAAMkW,eAAiB,YAE7B7c,EAAM2G,MAAMkW,eAAiB,cAE7B7c,EAAM2G,MAAMkW,eAAiB,4BAEtB7c,CACR,CAGD8c,6BAA6B7P,EAAK8P,GAChC,MAAMC,EAAYjwB,KAAKkwB,eAAehQ,GACtC,IAAI1e,EAEFwuB,EAAiB3rB,MAAQ4rB,EAAUptB,MACnC7C,KAAKorB,QAAQnY,MAAM5O,MAAQ,GAE3B7C,EAAIyuB,EAAUttB,KAAOqtB,EAAiB3rB,MACtC2rB,EAAiBrH,SAAU,IAE3BnnB,EAAIyuB,EAAUptB,MACdmtB,EAAiBrH,SAAU,GAE7BnnB,EAAIa,KAAKwF,MAAMrG,EAAIwuB,EAAiBtqB,SACpC,MAAMjE,EAAIY,KAAKwF,MAAMooB,EAAUltB,IAAMitB,EAAiBrqB,SAEhDlD,EAAIxB,EAAO8Y,SAIjB,OAHA9Y,EAAOkf,UAAU1d,EAAGA,EAAGjB,EAAGC,GAC1BR,EAAOof,MAAM5d,EAAGA,EAAGutB,EAAiB3rB,MAAO2rB,EAAiB1rB,QAErD7B,CACR,CAED0sB,YACE/pB,EACA0e,EACA3iB,EACAkf,EACAxb,EACAsrB,EACAC,EACAC,GAEA,MAAM1P,EAAK3gB,KAAK2gB,GAEV2P,EAAclrB,EAAKwb,WAAWP,EAAQrgB,KAAK8rB,mBAEjD,IAAKwE,EAAa,OAElB,IAAIvrB,EAAgBF,EAAUA,EAAQG,SAAW,EACvB,iBAAfmrB,IAAyBprB,GAAiBorB,GACrD,MAAMhM,EAASnkB,KAAK2mB,eAAejC,UAAUZ,EAAU/e,GAIvD,GAHA/E,KAAK6mB,WAAW1C,GAChBxD,EAAG4P,iBAAiBpM,EAAOlB,SAASuN,aAAa,EAAOrvB,GAElC,IAAlB4D,EAAqB,CACvB,IAAK,MAAM0rB,KAAUlsB,EAAa,CAChC,MAAMmsB,EAAY7rB,EAAQ8M,cAAc8e,GACtB,IAAdC,GACF/P,EAAGwG,UAAUhD,EAAOlB,SAAS,KAAKwN,KAAWC,EAChD,CAGsC,IAAnC7rB,EAAQ8M,cAAcxM,UACxBwb,EAAGmG,UAAU3C,EAAOlB,SAAS0N,WAAYvrB,EAAKf,MAAOe,EAAKd,OAC7D,CAlZassB,MAoZdjQ,EAAGO,YAAYP,EAAGQ,WAAYmP,GAE9B3P,EAAGkQ,UAAU1M,EAAOlB,SAAS6N,UAAW,GAGpCC,MAAMC,QAAQZ,IAChBpwB,KAAK2gB,GAAGsQ,WAAWjxB,KAAK4rB,eAAe3I,SAASiO,YAAad,GAK3DtM,IAAaF,EAAcG,UAAUgC,WAAsC,iBAAlBsK,GAC3DrwB,KAAK2gB,GAAGwQ,WACNnxB,KAAK4rB,eAAe3I,SAASmO,WAjab,GAANR,EAkaAP,GAjaR,GAAM,GAAM,KAAQ,KACzBO,EAAK,GAAM,EAAK,KAAQ,KACzBA,EAAK,EAAK,KAAQ,MAoalB5wB,KAAK2gB,GAAG+G,WAAW1nB,KAAK2gB,GAAGgH,UAAW,EAAG,EAC1C,CAEDsH,aAAahS,EAAQnd,GACnB,MAAMwgB,EAAc1S,OAAOyjB,UAAUC,eAAeC,KAAKtU,EAAQ,QAC7DA,EAAOpE,KAAO,IACd,EAaJ,GAXA7Y,KAAKmvB,YACHnvB,KAAK4e,SAAS3B,EAAO3J,SACrBxT,EAAQgkB,SACR9jB,KAAK+sB,aAAa9P,GAAQ8B,YAC1BuB,EACArD,EAAOpY,QACP/E,EAAQqwB,WACRrwB,EAAQswB,UACRtwB,EAAQuwB,cAAgBvwB,EAAQuwB,cAAcpT,QAAUuU,GAIxD1xB,EAAQ8uB,qBACR3R,EAAOnG,eACuB,KAA9BmG,EAAOnG,cAAc6C,KACrB,CACA,MAAMqW,EAAmBhwB,KAAK4e,SAAS3B,EAAOnG,eAE9C9W,KAAKmvB,YACHa,EACAlwB,EAAQgkB,SACR9jB,KAAK+vB,6BAA6B9S,EAAQ+S,GAC1C,EAEH,CACF,CAEDpU,oBAAoBqB,GAClB,OAAOjd,KAAK+sB,aAAa9P,GAAQrB,qBAClC,CAEDsU,eAAejT,GACb,OAAOva,EAAUoc,WAAW9e,KAAK+sB,aAAa9P,GAAQ8B,YACvD,CAGD0S,eAAevR,EAAKkQ,GAClB,MAAMzP,EAAK3gB,KAAK2gB,GAChBA,EAAGiH,WAAW,EAAG,EAAG,EAAG,GACvBjH,EAAGlP,MAAMkP,EAAGkH,iBAAmBlH,EAAG+Q,oBAKlC/Q,EAAGoL,OAAOpL,EAAGgR,cAIbhR,EAAGiR,YAAYjR,EAAGkR,OAAQ,EAAG,GAG7BlR,EAAGmR,UAAUnR,EAAGoR,KAAMpR,EAAGoR,KAAMpR,EAAGqR,SAElCrR,EAAGyP,WAAU,GAAO,GAAO,GAAO,GAKlC,MAAM6B,EAAO,CACXnO,SAAUF,EAAcG,UAAU8B,WAClC+I,qBAAqB,EAErBuB,YAAa3rB,EAAe0tB,OAK1B9B,IACF6B,EAAK7B,UAAYA,EAAUhoB,mBAC3B6pB,EAAKnO,SAAWF,EAAcG,UAAU+B,YAE1C9lB,KAAK0uB,cAAc,IAAI7f,IAAI,CAACqR,IAAO+R,GAGnCtR,EAAGiR,YAAYjR,EAAGwR,MAAO,EAAG,GAE5BxR,EAAGmR,UAAUnR,EAAGoR,KAAMpR,EAAGoR,KAAMpR,EAAGoR,MAElCpR,EAAGyP,WAAU,GAAM,GAAM,GAAM,EAChC,CAEDpU,qBAAqBkE,EAAKkS,EAAS3W,EAAM4W,GACvC,IAAKnS,EAAIpH,QAAS,OAAO,EACnBsZ,aAAmBvjB,MAErBujB,EADEA,aAAmBrB,MACX,IAAIliB,IAAIujB,GAER,IAAIvjB,IAAI,CAACujB,KAIvB,MAAME,EAAS5vB,EAAU6vB,KACvBvyB,KAAKkwB,eAAehQ,GACpBgL,GACAxnB,YAKI8uB,EAAY9vB,EAAUwc,WAC1Btc,KACCA,IACDA,KACCA,KAEH,IAAK,MAAMtC,KAAU8xB,EACnB1vB,EAAU+vB,MAAMD,EAAWxyB,KAAKkwB,eAAe5vB,GAASkyB,GAI1D,GAFAA,EAAU9uB,aAEL4uB,EAAOzuB,WAAW2uB,GAAY,OAAO,EAC1C,GAAI/W,EAAM,OAAO,EAEjB,MAAMiX,EAAK1yB,KAAK6sB,iBAAiBxoB,MAAQ,EACnCsuB,EAAK3yB,KAAK6sB,iBAAiBvoB,OAAS,EACpCsuB,EAAelwB,EAAUmwB,aAAaP,EAAQE,GAAWxuB,OAC5D0uB,EACDA,GACCC,EACDA,GAGF,GAA2B,IAAvBC,EAAavuB,OAAuC,IAAxBuuB,EAAatuB,OAAc,OAAO,EAElEtE,KAAK0mB,gBAAgB1mB,KAAK6sB,kBAE1B7sB,KAAKyxB,eAAevR,EAAKmS,GAGzBryB,KAAK0uB,cAAc0D,EAAS,CAC1BtO,SAAUF,EAAcG,UAAU8B,WAElCsK,YAAa3rB,EAAe0tB,QAG9B,MAAMvR,EAAK3gB,KAAK2gB,GAEhBA,EAAGmS,QAAQnS,EAAGgR,cAEd,MAAMoB,EAAY,IAAIC,WACpBJ,EAAavuB,MAAQuuB,EAAatuB,OAAS,GAE7Cqc,EAAGsS,WACDL,EAAajwB,KAAO+vB,EACpBE,EAAa9vB,OAAS6vB,EACtBC,EAAavuB,MACbuuB,EAAatuB,OACbqc,EAAGgB,KACHhB,EAAGiB,cACHmR,GAIF,IAAK,IAAItuB,EAAI,EAAGA,EAAIsuB,EAAUruB,OAAQD,GAAK,EACzC,GAAyB,IAArBsuB,EAAUtuB,EAAI,GAAU,OAAO,EAGrC,OAAO,CACR,CAEDsX,oBAAoBmE,EAAKgT,EAAcb,GACrC,MAAMC,EAAS5vB,EAAU6vB,KACvBvyB,KAAKkwB,eAAehQ,GACpBgL,GACAxnB,YAEIgvB,EAAK1yB,KAAK6sB,iBAAiBxoB,MAAQ,EACnCsuB,EAAK3yB,KAAK6sB,iBAAiBvoB,OAAS,EAG1C,GAFAguB,EAAOtuB,OAAO0uB,EAAIA,GAAKC,EAAIA,GAEN,IAAjBL,EAAOjuB,OAAiC,IAAlBiuB,EAAOhuB,OAAc,OAAO,EAEtDtE,KAAK0mB,gBAAgB1mB,KAAK6sB,kBAC1B,MAAMlM,EAAK3gB,KAAK2gB,GAChBA,EAAGiH,WAAW,EAAG,EAAG,EAAG,GACvBjH,EAAGlP,MAAMkP,EAAGkH,iBAAmBlH,EAAG+Q,oBAElC1xB,KAAK0mB,gBAAgB1mB,KAAK6sB,kBAE1B7sB,KAAKyxB,eAAevR,EAAKmS,GAGzBryB,KAAK0uB,cAAc,KAAM,CACvB1b,OAAQgc,GAASA,IAAU9O,IAI7BS,EAAGmS,QAAQnS,EAAGgR,cAEd,MAAMoB,EAAY,IAAIC,WAAWV,EAAOjuB,MAAQiuB,EAAOhuB,OAAS,GAChEqc,EAAGsS,WACDX,EAAO3vB,KAAO+vB,EACdJ,EAAOxvB,OAAS6vB,EAChBL,EAAOjuB,MACPiuB,EAAOhuB,OACPqc,EAAGgB,KACHhB,EAAGiB,cACHmR,GAGF,MAAMzX,EAAQ4X,EAAa/qB,SAC3B,IAAK,IAAI1D,EAAI,EAAGA,EAAIsuB,EAAUruB,OAAQD,GAAK,EACzC,GAEuB,IAArBsuB,EAAUtuB,EAAI,IAG+B,IAAhB,KAA3BsuB,EAAUtuB,GAAK6W,EAAM,MAC0B,IAAhB,KAA/ByX,EAAUtuB,EAAI,GAAK6W,EAAM,MACsB,IAAhB,KAA/ByX,EAAUtuB,EAAI,GAAK6W,EAAM,KAE3B,OAAO,EAGX,OAAO,CACR,CAGD6X,KAAKjgB,EAASoM,GACZtf,KAAK0mB,gBAAgB1mB,KAAK6sB,kBAC1B,MAAMlM,EAAK3gB,KAAK2gB,GAChBA,EAAGiH,WAAW,EAAG,EAAG,EAAG,GACvBjH,EAAGlP,MAAMkP,EAAGkH,kBAEZ,MAAMuL,EAAgB,IAAIpP,IAC1B,IAAK,IAAIvf,EAAI,EAAGA,EAAIyO,EAAQxO,OAAQD,IAClC2uB,EAAcrkB,IAAImE,EAAQzO,GAAIA,GAGhCzE,KAAK0uB,cAAc,IAAI7f,IAAIqE,GAAU,CACnCid,YAAa3rB,EAAe0tB,MAC5BpO,SAAUF,EAAcG,UAAUgC,UAElCsK,cAAgB/vB,GAAW8yB,EAAc5hB,IAAIlR,KAG/C,MAAM+yB,EAAe,IAAIL,WAAW,GAC9BN,EAAK1yB,KAAK6sB,iBAAiBxoB,MAAQ,EACnCsuB,EAAK3yB,KAAK6sB,iBAAiBvoB,OAAS,EAC1Cqc,EAAGsS,WACD3T,EAAM9d,EAAIkxB,EACVpT,EAAM7d,EAAIkxB,EACV,EACA,EACAhS,EAAGgB,KACHhB,EAAGiB,cACHyR,GAGF,MAAMppB,EAhqBQ,GAAE7D,EAAGM,EAAGC,MAASP,GAAK,GAAOM,GAAK,EAAKC,GAAK,EAgqB5C2sB,CAAUD,GACxB,OAAe,IAAXppB,EAAqB,KAClBiJ,EAAQjJ,EAChB,CAEDyR,oBAAoBwE,EAAKZ,EAAO7D,GAC9B,IAAKyE,EAAIpH,QAAS,OAAO,EAGzB,IADY9Y,KAAKkwB,eAAehQ,GACvBnc,cAAcub,EAAM9d,EAAG8d,EAAM7d,GAAI,OAAO,EACjD,GAAIga,EAAM,OAAO,EAGjBzb,KAAK0mB,gBAAgB1mB,KAAK6sB,kBAC1B,MAAMlM,EAAK3gB,KAAK2gB,GAChBA,EAAGiH,WAAW,EAAG,EAAG,EAAG,GACvBjH,EAAGlP,MAAMkP,EAAGkH,kBAEZ7nB,KAAK0uB,cAAc,IAAI7f,IAAI,CAACqR,IAAO,CAAEiQ,YAAa3rB,EAAe0tB,QAEjE,MAAMmB,EAAe,IAAIL,WAAW,GAC9BN,EAAK1yB,KAAK6sB,iBAAiBxoB,MAAQ,EACnCsuB,EAAK3yB,KAAK6sB,iBAAiBvoB,OAAS,EAU1C,OATAqc,EAAGsS,WACD3T,EAAM9d,EAAIkxB,EACVpT,EAAM7d,EAAIkxB,EACV,EACA,EACAhS,EAAGgB,KACHhB,EAAGiB,cACHyR,GAEyB,IAApBA,EAAa,EACrB,CAED1Y,QAAQ6L,EAAKC,EAAKnL,EAAOzC,GACvB7Y,KAAK4sB,SAASjS,QAAQ6L,EAAKC,EAAKnL,EAAOzC,EACxC,CAEDnC,WACE1W,KAAK4sB,SAASnb,OACf,CAED8J,MAAM2E,GACJlgB,KAAK0mB,gBAAgB1mB,KAAK4sB,SAASzG,kBACnCnmB,KAAK0uB,cAAc,IAAI7f,IAAI,CAACqR,IAAO,CAAE0O,qBAAqB,GAC3D,CAED2E,cAAc1c,GACZ,MAAM2c,EAASlR,SAASC,cAAc,QACtCiR,EAAOjF,UAAUC,IAAI,mBAErB,MAAMiF,EAAUnR,SAASC,cAAc,QACvCkR,EAAQlF,UAAUC,IAAI,oBACtBiF,EAAQC,UAAY7c,EACpB2c,EAAO/E,OAAOgF,GAEd,MAAME,EAAWrR,SAASC,cAAc,SACxCoR,EAASzP,KAAO,OAChByP,EAASpF,UAAUC,IAAI,qBACvBgF,EAAO/E,OAAOkF,GAEd,MAAMC,EAAYtR,SAASC,cAAc,UAQzC,OAPAqR,EAAUrF,UAAUC,IAAI,sBACxBoF,EAAUF,UAAY,SACtBF,EAAO/E,OAAOmF,GAEd5zB,KAAKqrB,aAAaoD,OAAO+E,GACzBG,EAASE,QAEF,IAAIhzB,SAAQC,IACjB0yB,EAAO5nB,iBAAiB,UAAUkoB,IAChCA,EAAEC,iBACFP,EAAOQ,SACPlzB,EAAQ6yB,EAASpnB,MAAM,GACvB,GAEL,ECzwBY,MAAM0nB,EACnBr0B,YAAYqT,EAAOoP,EAAQ6R,GACzBl0B,KAAKm0B,OAASlhB,EACdjT,KAAKioB,QAAU5F,EAGXriB,KAAKioB,QAAQmM,SAAW,IAC1Bp0B,KAAKioB,QAAQmM,SAAW,GAG1Bp0B,KAAK4V,MAAQ,CAAEpU,EAAG,EAAGC,EAAG,EAAG4yB,MAAM,GACjCr0B,KAAKioB,QAAQrc,iBAAiB,YAAa5L,KAAKs0B,WAAW3zB,KAAKX,OAChEA,KAAKioB,QAAQrc,iBAAiB,YAAa5L,KAAKu0B,WAAW5zB,KAAKX,OAChEA,KAAKioB,QAAQrc,iBAAiB,UAAW5L,KAAKw0B,SAAS7zB,KAAKX,OAE5DA,KAAKioB,QAAQrc,iBAAiB,QAAS5L,KAAKy0B,OAAO9zB,KAAKX,OACxDA,KAAKioB,QAAQrc,iBAAiB,UAAW5L,KAAK00B,SAAS/zB,KAAKX,OAE5DA,KAAK+R,KAAO,GACZ/R,KAAK20B,WAAaT,CACnB,CAEDI,WAAWR,GACT,MAAMhwB,EAAO9D,KAAKioB,QAAQyH,wBACpBkF,EAAS50B,KAAKm0B,OAAO9vB,MAAQP,EAAKO,MAClCwwB,EAAS70B,KAAKm0B,OAAO7vB,OAASR,EAAKQ,OACnCwwB,GACAhB,EAAEiB,QAAUjxB,EAAKnB,MAAQiyB,EADzBE,GAEAhB,EAAEkB,QAAUlxB,EAAKf,KAAO8xB,EAG9B70B,KAAK4V,MAAQ,IACR5V,KAAK4V,MACRpU,EAAGszB,EAAe90B,KAAKm0B,OAAO9vB,MAAQ,EACtC5C,GAAIqzB,EAAe90B,KAAKm0B,OAAO7vB,OAAS,EAE3C,CAEDiwB,aACEv0B,KAAK4V,MAAQ,IACR5V,KAAK4V,MACRye,MAAM,EAET,CAEDG,WACEx0B,KAAK4V,MAAQ,IACR5V,KAAK4V,MACRye,MAAM,EAET,CAEDI,OAAOX,GACL,MAAMmB,EAAMj1B,KAAKk1B,YAAYpB,GAC7B9zB,KAAK+R,KAAO/R,KAAK+R,KAAKiB,QAAOmiB,GAAKA,IAAMF,GACzC,CAEDP,SAASZ,GACPA,EAAEC,iBAEF,MAAMkB,EAAMj1B,KAAKk1B,YAAYpB,IACG,IAA5B9zB,KAAK+R,KAAKqjB,QAAQH,IACpBj1B,KAAK+R,KAAKmI,KAAK+a,GAGjBj1B,KAAK20B,WAAWM,EACjB,CAEDC,YAAYpB,GACV,MAAc,YAAVA,EAAEmB,IAA0B,WAClB,cAAVnB,EAAEmB,IAA4B,aACpB,cAAVnB,EAAEmB,IAA4B,aACpB,eAAVnB,EAAEmB,IAA6B,cACrB,MAAVnB,EAAEmB,IAAoB,QACK,UAA3BnB,EAAE9pB,KAAKwN,UAAU,EAAG,GAAuBsc,EAAE9pB,KAAK,GAE/C8pB,EAAEmB,IAAI7d,aACd,CAEDvB,WAAWjL,GACT,MAAa,QAATA,EAAuB5K,KAAK+R,KAAKrN,OAAS,EACvC1E,KAAK+R,KAAKqjB,QAAQxqB,IAAS,CACnC,CAEDipB,QACE7zB,KAAKioB,QAAQ4L,OACd,ECpFH,MAAMwB,EAAkB,CAAC,kBAAmB,iBAG7B,MAAMC,EACnB11B,cAEEI,KAAKu1B,gBAAkB,eACxB,CAEG9sB,mBACF,OAAOkC,EAAMlC,YACd,CAED+sB,gBAGE,GAA6B,kBAAzBx1B,KAAKu1B,gBAAT,CACAv1B,KAAKu1B,gBAAkB,aAEvB,IACE,MAAME,QAAeC,UAAUC,aAAaC,aAAa,CAAEC,OAAO,UAG5DlrB,EAAMlC,aAAaqtB,SACzB91B,KAAK+1B,cAAe,EACpB/1B,KAAKg2B,YAAcP,EACnB,MAAMQ,EAAMj2B,KAAKyI,aAAaytB,wBAAwBT,GACtDz1B,KAAKm2B,SAAWn2B,KAAKyI,aAAa2tB,iBAClCH,EAAIzpB,QAAQxM,KAAKm2B,UACjBn2B,KAAKq2B,aAAe,IAAIj1B,aAAapB,KAAKm2B,SAASG,SACnDt2B,KAAKu1B,gBAAkB,WAQxB,CAPC,MAAOzB,GAEP,GADA9zB,KAAKu1B,gBAAkB,SACnBF,EAAgB5d,SAASqc,EAAElpB,MAG7B,MAAMkpB,EAFN3nB,QAAQC,KAAK,wBAIhB,CAtBoD,CAuBtD,CAEG6K,eACF,GAA6B,cAAzBjX,KAAKu1B,kBAAoCv1B,KAAKg2B,YAAYO,OAC5D,OAAQ,EAGVv2B,KAAKm2B,SAASK,uBAAuBx2B,KAAKq2B,cAC1C,IAAII,EAAM,EAEV,IAAK,IAAIhyB,EAAI,EAAGA,EAAIzE,KAAKq2B,aAAa3xB,OAAQD,IAC5CgyB,GAAOp0B,KAAKgE,IAAIrG,KAAKq2B,aAAa5xB,GAAI,GAExC,IAAIiyB,EAAMr0B,KAAKwD,KAAK4wB,EAAMz2B,KAAKq2B,aAAa3xB,QAY5C,OAVI1E,KAAK22B,aACPD,EAAMr0B,KAAK6B,IAAIwyB,EAAuB,GAAlB12B,KAAK22B,aAE3B32B,KAAK22B,WAAaD,EAGlBA,GAAO,KACPA,EAAMr0B,KAAKwD,KAAK6wB,GAChBA,EAAMr0B,KAAKwF,MAAY,IAAN6uB,GACjBA,EAAMr0B,KAAK4B,IAAIyyB,EAAK,KACbA,CACR,CAEDE,cAEE,OADA52B,KAAKwM,UACExM,KAAKiX,QACb,EClEY,MAAM4f,EACnBj3B,YAAYqT,EAAOC,EAAU,CAAA,GAAI4jB,UAAEA,EAAY,IAAO,IACpD92B,KAAKiT,MAAQA,EACbjT,KAAKkT,QAAUA,EAEftF,OAAO2O,OAAOrJ,GAEd,IAAK,MAAM+J,KAAUjd,KAAKovB,iBACxBnS,EAAO9K,SAAWnS,KAEpBA,KAAKiT,MAAMd,SAAWnS,KAEtBA,KAAK2W,SAAW,IAAIwU,EAASnrB,MAC7BA,KAAKwO,MAAQ,IAAIylB,EAAMj0B,KAAKiT,MAAOjT,KAAK2W,SAAS1D,OAAOgiB,IACtDj1B,KAAKuW,YAAY5W,EAAQP,YAAa,CAAE61B,OAAM,IAGhDj1B,KAAK+2B,gBAAkB,IAAIzB,EAE3Bt1B,KAAKg3B,gBAAkB,KAEvBh3B,KAAKsa,gBAAkB,GAGvBta,KAAKi3B,2BAA6B,IAAIvL,QAEtC1rB,KAAK+V,eAEL/V,KAAKgX,OAAS,KAGdkgB,aAAY,KACVl3B,KAAKe,MAAM,GACV,IAAO+1B,GAGV92B,KAAKm3B,aACN,CAEDC,OAAO/L,GACLrrB,KAAK2W,SAAS6U,gBAAgBH,GAC9BrrB,KAAK2W,SAAS1D,MAAMrH,iBAAiB,SAAS,KAKX,cAA7BjB,EAAMlC,aAAa4uB,OACrB1sB,EAAMlC,aAAaqtB,SAGrB,IAAIwB,EAAgBt3B,KAAK2W,SAASwc,KAAKnzB,KAAKovB,iBAAkB,CAC5D5tB,EAAGxB,KAAKwO,MAAMoH,MAAMpU,EACpBC,EAAGzB,KAAKwO,MAAMoH,MAAMnU,IAEjB61B,IACHA,EAAgBt3B,KAAKiT,OAGvB,MAAMskB,EAAmB,GACzB,IAAK,MAAM13B,KAAWy3B,EAAc9kB,SAC9B3S,EAAQW,QAAQb,EAAQL,QAAS,CAAA,EAAIg4B,IACvCC,EAAiBrd,KAAK,CAAEra,UAASS,OAAQg3B,IAI7Ct3B,KAAKoa,eAAemd,EAAiB,GAExC,CAEDC,YAKmC,cAA7B7sB,EAAMlC,aAAa4uB,OACrB1sB,EAAMlC,aAAaqtB,SAErB91B,KAAKuW,YAAY5W,EAAQT,YACzBc,KAAKwO,MAAMqlB,OACZ,CAGD4D,kBAAkBC,GAChB,IAAIH,EAAmB,GACvB,MAAMnF,EAAUpyB,KAAK23B,gBACrB,IAAK,MAAMr3B,KAAU8xB,EAAS,CAC5B,MAAMwF,EAAyBt3B,EAAOkS,SAASQ,QAAOmH,GACpDud,EAAevd,EAAI7Z,KAErB,IAAK,MAAM2qB,KAAS2M,EAClBL,EAAiBrd,KAAK,CAAEra,QAASorB,EAAO3qB,UAE3C,CACD,OAAOi3B,CACR,CAEDM,6BACE,MAAMC,EAAgB93B,KAAKy3B,mBAAkBtd,GAAMA,EAAG/Z,kBAChD23B,EAAkB,GACxB,IAAK,MAAMC,KAAqBF,EAAe,CAC7C,MAAMj4B,QAAEA,EAAOS,OAAEA,GAAW03B,EAC5B,IAAIC,EACJ,OAAQp4B,EAAQA,SACd,KAAKF,EAAQF,mBACXw4B,EAAYj4B,KAAK8V,MAAQjW,EAAQQ,OAAO,QAASC,GACjD,MACF,KAAKX,EAAQH,sBACXy4B,EAAYj4B,KAAKiX,SAAWpX,EAAQQ,OAAO,QAASC,GACpD,MACF,QACE,MAAM,IAAIwI,MAAM,yBAAyBjJ,EAAQA,WAIrD,MAAMq4B,IAAkBl4B,KAAKi3B,2BAA2BzlB,IAAI3R,GAC5DG,KAAKi3B,2BAA2BloB,IAAIlP,EAASo4B,IAIxCC,GAAiBD,GACpBF,EAAgB7d,KAAK8d,EAExB,CACDh4B,KAAKoa,eAAe2d,EACrB,CAEDh3B,OACEf,KAAKg3B,gBAAkB,KACvBh3B,KAAK63B,6BAGL,MAAMM,EAAyBn4B,KAAKsa,gBACpC,IAAK,IAAI7V,EAAI,EAAGA,EAAI0zB,EAAuBzzB,OAAQD,IACjD0zB,EAAuB1zB,GAAG5E,QAAQkB,OAIpCf,KAAKsa,gBAAkBta,KAAKsa,gBAAgBtH,QAC1C,EAAGnT,cAAeA,EAAQK,MAE7B,CAEDk4B,SAEEp4B,KAAK2W,SAASwG,OAAOnd,KAAKiT,MAAOjT,KAAKovB,kBAGtC,IAAK,MAAMnS,IAAU,IAAIrP,OAAOkB,OAAO9O,KAAKkT,SAAUlT,KAAKiT,OACzD,IAAK,MAAMolB,KAAWzqB,OAAOkB,OAAOmO,EAAOxK,UACzC4lB,EAAQC,UAAUt4B,KAAK2W,SAAS0U,aAGrC,CAED8L,cACEoB,sBAAsBv4B,KAAKm3B,YAAYx2B,KAAKX,OAC5CA,KAAKo4B,QACN,CAED7hB,YAAY1W,EAASC,GAEnB,GAAID,IAAYF,EAAQT,WAAY,CAClCc,KAAK+V,eACL/V,KAAKoW,gBACLpW,KAAKsa,gBAAkB,GAEvB,IAAK,MAAMke,KAAcx4B,KAAKkT,QAAS,CACtBlT,KAAKkT,QAAQslB,GACrBhf,OAAS,EACjB,CAED,IAAK,MAAMyD,KAAUjd,KAAK23B,gBACxB1a,EAAOpY,QAAQ4M,QACfwL,EAAOnK,aAAarB,OAEvB,CAED,MAAM8lB,EAAmBv3B,KAAKy3B,mBAAkB,CAACtd,EAAI7Z,IACnD6Z,EAAG3Z,QAAQX,EAASC,EAASQ,KAG/B,OAAON,KAAKoa,eAAemd,EAC5B,CAEDnd,eAAe5H,GAIb,IAAK,MAAM3S,KAAW2S,EAEjBxS,KAAKsa,gBAAgBrK,MACpBwoB,GACE54B,EAAQA,UAAY44B,EAAe54B,SACnCA,EAAQS,SAAWm4B,EAAen4B,UAGtCN,KAAKsa,gBAAgBJ,KAAKra,GAG9B,OAAOgB,QAAQ63B,IACblmB,EAASxK,KAAI,EAAGnI,UAASS,YAChBT,EAAQY,MAAMH,KAG1B,CAEG8uB,uBACF,OAAOxhB,OAAOkB,OAAO9O,KAAKkT,SACvBsH,SAAQyC,GAAUA,EAAO1C,cACzBoe,MAAK,CAAC1xB,EAAGN,IAAMM,EAAEsL,YAAc5L,EAAE4L,aACrC,CAEGolB,sBACF,MAAO,IAAI33B,KAAKovB,iBAAkBpvB,KAAKiT,MACxC,CAEDe,kBAAkBiJ,EAAQ2b,EAAYC,EAAmB5b,GACvD,IAAI6b,EAAe94B,KAAKovB,iBAExB,MAAM2J,EAAgBD,EAAa1D,QAAQnY,GAG3C,IAAI+b,EAFoBF,EAAa1D,QAAQyD,GAEZD,EAC7BI,EAAW,IAAGA,EAAW,GACzBA,EAAWF,EAAap0B,OAAS,IAAGs0B,EAAWF,EAAap0B,OAAS,GAGzEo0B,EAAaG,OAAOF,EAAe,GACnCD,EAAaG,OAAOD,EAAU,EAAG/b,GAKjC6b,EAAaI,SAAQ,CAACjc,EAAQhT,KAC5BgT,EAAO1K,YAActI,EAAQ,CAAC,GAEjC,CAEDmM,gBACE,IAAK,MAAM9V,KAAUN,KAAK23B,gBACxBr3B,EAAO+V,mBAEV,CAEGP,YAEF,OADW,IAAIL,KAASzV,KAAKm5B,YACjB,GACb,CAEDpjB,eACE/V,KAAKm5B,WAAa,IAAI1jB,IACvB,CAED+f,iBAAiB3e,GACf7W,KAAKgX,aAAehX,KAAK2W,SAAS4c,cAAc1c,EACjD,CAEGI,eAIF,OAH6B,OAAzBjX,KAAKg3B,kBACPh3B,KAAKg3B,gBAAkBh3B,KAAK+2B,gBAAgBH,eAEvC52B,KAAKg3B,eACb,EC1QY,MAAMoC,EACnBx5B,aAAY2M,MACVA,EAAQ,KAAM,IAAE8sB,SAChBA,EAAW,SAAQC,MACnBA,EAAK1f,MACLA,EAAQ,SAAQd,QAChBA,GAAU,EAAIwC,MACdA,EAAQtU,EAAMG,IAAI,IAAK,IAAK,IAAGpG,KAC/BA,EAAO,EAACkD,IACRA,EAAM,EAACC,IACPA,EAAM,IAAG1C,EACTA,GAAI,IAAIC,EACRA,EAAI,IAAG4C,MACPA,EAAKC,OACLA,IAEAtE,KAAKu5B,gBAELv5B,KAAKuM,MAAQA,EACbvM,KAAKq5B,SAAWA,EAChBr5B,KAAKw5B,eAAiBr6B,OAAO,qBAE7Ba,KAAKs5B,MAAQA,EACbt5B,KAAK4Z,MAAQA,EACb5Z,KAAK8Y,QAAUA,EACf9Y,KAAKsb,MAAQA,EACbtb,KAAKe,KAAOA,EACZf,KAAKiE,IAAMA,EACXjE,KAAKkE,IAAMA,EAEXlE,KAAKwB,EAAIA,EACTxB,KAAKyB,EAAIA,EACTzB,KAAKqE,MAAQA,EACbrE,KAAKsE,OAASA,CACf,CAEDi1B,gBACE,MAAM3qB,EAAO0T,SAASC,cAAc,OACpC3T,EAAK2f,UAAUC,IAAI,oBAEnB,MAAM8K,EAAQhX,SAASC,cAAc,OACrC+W,EAAM/K,UAAUC,IAAI,yBACpB5f,EAAK6f,OAAO6K,GAEZ,MAAM/sB,EAAQ+V,SAASC,cAAc,OACrChW,EAAMgiB,UAAUC,IAAI,yBACpB5f,EAAK6f,OAAOliB,GAEZ,MAAMktB,EAASnX,SAASC,cAAc,SACtCkX,EAAOvV,KAAO,QACduV,EAAOlL,UAAUC,IAAI,0BAErBiL,EAAO7tB,iBAAiB,SAAS8tB,IAC/B15B,KAAKq5B,SAASnyB,OAAOwyB,EAAMp5B,OAAOiM,OAAO,IAG3CqC,EAAK6f,OAAOgL,GAEZz5B,KAAK25B,KAAO,CAAE/qB,OAAM0qB,QAAO/sB,QAAOktB,SACnC,CAEDnB,UAAUjN,GAKR,GAJIA,IAAiBA,EAAauO,SAAS55B,KAAK25B,KAAK/qB,OACnDyc,EAAaoD,OAAOzuB,KAAK25B,KAAK/qB,OAG3B5O,KAAK8Y,QAAS,OAEnB,MAAMvM,EAAQvM,KAAKuM,QAEbstB,EAAS9I,MAAMC,QAAQzkB,GAE7B,GADAvM,KAAK25B,KAAK/qB,KAAK2f,UAAUuL,OAAO,yBAA0BD,GACtDA,GAEF,IACG9I,MAAMC,QAAQhxB,KAAKw5B,iBACpBO,KAAKC,UAAUztB,EAAMvE,IAAIkB,WACvB6wB,KAAKC,UAAUh6B,KAAKw5B,eAAexxB,IAAIkB,SACzC,CACAlJ,KAAK25B,KAAKptB,MAAM0tB,UAAY,GAC5B,IAAK,MAAOhwB,EAAO4N,KAAStL,EAAMsB,UAAW,CAC3C,MAAMqsB,EAAW5X,SAASC,cAAc,OACxC2X,EAAS3L,UAAUC,IAAI,4BAEvB,MAAM2L,EAAY7X,SAASC,cAAc,OACzC4X,EAAU5L,UAAUC,IAAI,iCACxB2L,EAAUzG,UAAYzpB,EAEtB,MAAMmwB,EAAc9X,SAASC,cAAc,OAC3C6X,EAAY7L,UAAUC,IAAI,mCAC1B4L,EAAY1G,UAAY7b,EAAK/P,WAE7BoyB,EAASzL,OAAO0L,GAChBD,EAASzL,OAAO2L,GAChBp6B,KAAK25B,KAAKptB,MAAMkiB,OAAOyL,EACxB,CACF,OAGG3tB,IAAUvM,KAAKw5B,iBACjBx5B,KAAK25B,KAAKptB,MAAMmnB,UAAYnnB,EAAMzE,YAKpC9H,KAAKw5B,eADHK,EACoB,IAAIttB,GAEJA,EAIJ,WAAhBvM,KAAKq6B,SACPr6B,KAAK25B,KAAKF,OAAOltB,MAAQA,GAM3B,MAAM+tB,EACW,KAAft6B,KAAKsb,MAAMlV,EAA2B,KAAfpG,KAAKsb,MAAM5U,EAA2B,KAAf1G,KAAKsb,MAAM3U,EAAY,IACjE,OACA,OACN3G,KAAK25B,KAAKptB,MAAMqN,MAAM2gB,YAAY,kBAAmBv6B,KAAKsb,MAAMxT,YAChE9H,KAAK25B,KAAKptB,MAAMqN,MAAM2gB,YAAY,uBAAwBD,EAC3D,CAEGxhB,cACF,OAAO9Y,KAAKw6B,QACb,CACG1hB,YAAQA,GACV9Y,KAAKw6B,SAAW1hB,EAChB9Y,KAAK25B,KAAK/qB,KAAKgL,MAAM6gB,WAAa3hB,EAAU,UAAY,QACzD,CAEGtX,QACF,OAAOxB,KAAKkZ,EACb,CACG1X,MAAEA,GACJxB,KAAKkZ,GAAK1X,EACVxB,KAAK25B,KAAK/qB,KAAKgL,MAAMjX,KAAUnB,EAAI,IAAP,IAC7B,CAEGC,QACF,OAAOzB,KAAKmZ,EACb,CACG1X,MAAEA,GACJzB,KAAKmZ,GAAK1X,EACVzB,KAAK25B,KAAK/qB,KAAKgL,MAAM7W,IAAS,IAAMtB,EAAT,IAC5B,CAEG4C,YACF,OAAOrE,KAAK06B,MACb,CACGr2B,UAAMA,GACRrE,KAAK06B,OAASr2B,EAEZrE,KAAK25B,KAAK/qB,KAAKgL,MAAMvV,MADnBA,EAC2B,GAAGA,WAEHmtB,CAEhC,CAEGltB,aACF,OAAOtE,KAAK26B,OACb,CACGr2B,WAAOA,GACTtE,KAAK26B,QAAUr2B,EAEbtE,KAAK25B,KAAK/qB,KAAKgL,MAAMtV,OADnBA,EAC4B,GAAGA,WAEHktB,CAEjC,CAEG5X,YACF,OAAO5Z,KAAKq6B,MACb,CACGzgB,UAAMA,GACR5Z,KAAKq6B,OAASzgB,EACd5Z,KAAK25B,KAAK/qB,KAAK2f,UAAUuL,OACvB,2BACU,WAAVlgB,GAEF5Z,KAAK25B,KAAK/qB,KAAK2f,UAAUuL,OACvB,0BACU,UAAVlgB,GAEF5Z,KAAK25B,KAAK/qB,KAAK2f,UAAUuL,OACvB,2BACU,WAAVlgB,EAEH,CAEG3V,UACF,OAAOjE,KAAK46B,IACb,CACG32B,QAAIA,GACNjE,KAAK46B,KAAO32B,EACZjE,KAAK25B,KAAKF,OAAOx1B,IAAMA,CACxB,CAEGC,UACF,OAAOlE,KAAK66B,IACb,CACG32B,QAAIA,GACNlE,KAAK66B,KAAO32B,EACZlE,KAAK25B,KAAKF,OAAOv1B,IAAMA,CACxB,CAEGnD,WACF,OAAOf,KAAK86B,KACb,CACG/5B,SAAKA,GACPf,KAAK86B,MAAQ/5B,EACbf,KAAK25B,KAAKF,OAAO14B,KAAOA,CACzB,CAEGu4B,YACF,OAAOt5B,KAAK+6B,MACb,CACGzB,UAAMA,GACRt5B,KAAK+6B,OAASzB,EACdt5B,KAAK25B,KAAKL,MAAM5F,UAAY4F,CAC7B"}